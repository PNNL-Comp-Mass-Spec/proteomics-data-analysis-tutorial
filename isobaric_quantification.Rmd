# Isobaric Quantification Pipelines {#isobaric-quantification-pipelines}

<!---
TODO:
* Overview of isobaric labeling
--->

Section summary to be added later. Please continue to subsections.


## Global Proteomics Data {#global-proteomics-data}

This pipeline shows how to process TMT data that is processed outside of PNNL's DMS. Section \@ref(phosphoproteomics-data) shows how to process data from the DMS. For convenience, the results of MS-GF+ and MASIC processing are provided in a companion `PlexedPiperTestData` package. For this section, we need three packages: `PlexedPiper` for isobaric quantification, `PlexedPiperTestData`, and `dplyr` to manipulate data frames.

<!---
For these examples, we need two packages: PlexedPiper and PlexedPiperTestData. The former is used to interface with the DMS, while the latter is tailored to isobaric quantification.
--->

```{r include=FALSE}
# Global chunk options
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```


```{r iso-lab-setup}
# Setup
library(PlexedPiper)
library(PlexedPiperTestData)
library(dplyr)
```

```{r include=FALSE}
library(kableExtra)
```


### Prepare MS/MS Identifications {#prepare-MS2-IDs-global}

#### Read MS-GF+ Data {-}

```{r read-msgf, results='hide'}
# Get file path
path_to_MSGF_results <- system.file("extdata/global/msgf_output", 
                                    package = "PlexedPiperTestData")
# Read MS-GF+ data from path
msnid <- read_msgf_data(path_to_MSGF_results)
```

Normally, this would display a progress bar in the console as the data is being fetched. However, the output was suppressed to save space. We can view a summary of the MSnID object with the `show()` function.

```{r}
show(msnid)
```

`msnid` consists of 4 spectrum files (datasets), and contains a total of 1,156,754 peptide-spectrum-matches (PSMs), 511,617 total peptides, and 128,378 total accessions (proteins). The reported FDR is the empirical **false-discovery rate**, which is calculated as the ratio of the number of false (decoy) PSMs, peptides, or accessions to their true (non-decoy) counterparts. Calculation of these counts and their FDRs is shown below.

```{r eval=FALSE}
# Calculating the counts and FDRs from the show() output ---
# Spectrum Files:
# Count
psms(msnid) %>% 
  distinct(Dataset) %>%
  nrow() # 48

# PSMs:
# Count
psms(msnid) %>% 
  distinct(Dataset, Scan, peptide, isDecoy) %>%
  # Assign intermediate to variable
  assign("x_psm", ., envir = globalenv()) %>% 
  nrow() # 1156754
# FDR
nrow(x_psm[x_psm$isDecoy == TRUE, ]) / 
  nrow(x_psm[x_psm$isDecoy == FALSE, ]) 
# 0.3127463 = 31%

# peptides:
# Count
psms(msnid) %>% 
  distinct(peptide, isDecoy) %>% 
  assign("x_peptide", ., envir = globalenv()) %>%
  nrow() # 511617
# FDR
nrow(x_peptide[x_peptide$isDecoy == TRUE, ]) / 
  nrow(x_peptide[x_peptide$isDecoy == FALSE, ])
# 0.611245 = 61%

# Accessions:
# Count
length(accessions(msnid)) # or
psms(msnid) %>% 
  distinct(accession, isDecoy) %>% 
  assign("x_acc", ., envir = globalenv()) %>%
  nrow() # 128378
# FDR
nrow(x_acc[x_acc$isDecoy == TRUE, ]) / 
  nrow(x_acc[x_acc$isDecoy == FALSE, ])
# 0.9827024 = 98%
```

Now that we have an `MSnID` object, we need to process it. 

#### Correct Isotope Selection Error {-}

Occasionally, the instrument selects a peak with +1 or more C13 atoms, rather than the monoisotopic (lowest mass) peak. While MS-FG+ is still capable of correctly identifying those, the downstream calculations of mass measurement error need to be fixed. The `correct_peak_selection` method corrects for these mass measurement errors.

```{r}
# Correct for isotope selection error
msnid <- correct_peak_selection(msnid)
```

#### Remove Contaminants {-}

Now, we will remove contaminants such as the pig trypsin that was used for protein digestion. We can use `grepl` to search for all accessions that contain "Contaminant".

```{r}
# All unique contaminants
unique(msnid$accession[grepl("Contaminant", msnid$accession)])
```

To remove contaminants, we use `apply_filter` with an appropriate character string that tells the function what rows to keep. In this case, we keep rows where the accession does not contain "Contaminant". We will use `show` to see how the counts change.

```{r}
# Remove contaminants
msnid <- apply_filter(msnid, "!grepl('Contaminant', accession)")
show(msnid)
```

#### MS/MS ID Filter: Peptide Level {-}

The next step is to use the `PepQValue` column from the MSnID object and the absolute deviation of the mass measurement error of parent ions (in ppm) to maximize the number of PSMs while ensuring that the empirical peptide-level FDR is at most 1%.

```{r global-fdr-filter-peptide}
# 1% FDR filter at the peptide level
msnid <- filter_msgf_data(msnid,
                          level = "peptide",
                          fdr.max = 0.01)
show(msnid)
```

We can see that filtering drastically reduces the number of PSMs, and the empirical peptide-level FDR is now 1%. However, notice that the empirical protein-level FDR is still fairly high.

#### MS/MS ID Filter: Protein Level {-}

A while ago, the proteomics field established the hard-and-fast two-peptides-per-protein rule. That is, we can not be confident if a protein is identified by the detection of only one peptide. This rule penalizes short proteins and doesn't consider that there are some very long proteins (e.g. Titin 3.8 MDa) that easily have more then two matching peptides even in reversed sequence. Thus, we propose to normalize the number of peptides per protein length and use that as a filtering criterion.

We need the FASTA (pronounced FAST-AYE) file to get the length of each protein, which we can then use to calculate the associated number of peptides per 1000 amino acids. This new `peptides_per_1000aa` column is used to filter the MSnID object so that the empirical accession-level FDR is at most 1%.

```{r message=FALSE, warning=FALSE}
# Get path to FASTA file
path_to_FASTA <- system.file(
  "extdata/Rattus_norvegicus_NCBI_RefSeq_2018-04-10.fasta.gz", 
  package = "PlexedPiperTestData"
)

# Compute number of peptides per 1000 amino acids
msnid <- compute_num_peptides_per_1000aa(msnid, path_to_FASTA)

# 1% FDR filter at the protein level
msnid <- filter_msgf_data(msnid,
                          level = "accession",
                          fdr.max = 0.01)
show(msnid)
```

#### Inference of Parsimonious Protein Set {-}

The situation when a certain peptide sequence matches multiple proteins adds complication to the downstream quantitative analysis, as it is not clear which protein this peptide is originating from. There are common ways for dealing with this. One is to simply retain uniquely matching peptides and discard shared peptides (`unique_only = TRUE`). Alternatively (in case of `unique_only = FALSE`) assign the shared peptides to the proteins with the larger number of uniquely mapping peptides. If there is a choice between multiple proteins with equal numbers of uniquely mapping peptides, the shared peptides are assigned to the first protein according to alphanumeric order. This step could be done prior to filtering at the accession level, but the removal of an accession will completely remove its associated peptides.

<!---
TODO:
* Include a visual for inference of the parsimonious protein set.
--->

```{r}
# Inference of parsimonious protein set
msnid <- infer_parsimonious_accessions(msnid, unique_only = FALSE)
show(msnid)
```

Notice that the protein-level FDR increased above the acceptable threshold, so we need to reapply the filter.

```{r}
# 1% FDR filter at the protein level
msnid <- filter_msgf_data(msnid,
                          level = "accession",
                          fdr.max = 0.01)
show(msnid)
```

Once all filtering is done, we can remove the decoy accessions. We use the `apply_filter` function again and only keep entries where `isDecoy` is `FALSE`.

```{r}
# Remove Decoy Accessions
msnid <- apply_filter(msnid, "!isDecoy")
show(msnid)
```

After processing, we are left with 318,448 PSMs, 81,048 peptides, and 5,143 proteins. The empirical FDRs are the same as before, but can not be calculated because we removed the decoys.

```{r global-msnid-table, echo=FALSE}
kable(head(psms(msnid), 10), digits = 3, row.names = FALSE, 
      caption = "<left>First 10 rows of the processed MS-GF+ results.</left>",
      escape = FALSE, format = "html") %>% 
  kable_styling(full_width = FALSE, font_size = 12) %>%
  scroll_box(height = "20em", width = "100%")
```

</br>

Table \@ref(tab:global-msnid-table) shows the first 10 rows of the processed MS-GF+ output.


### Prepare Reporter Ion Intensities {#reporter-ion-intensities}

#### Read MASIC Output {-}

MASIC is a tool for extracting ion intensities. With proper parameter settings, it can be used for extracting TMT (or iTRAQ) reporter ion intensities. In addition, it reports a number of other helpful metrics. Notably, the interference score at the parent ion level and the signal-to-noise ratio (S/N) at the reporter ion level (computed by Thermo software). The interference score reflects the proportion of the ion population that was isolated for fragmentation that is due to the targeted ion. In other words, 1 - InterferenceScore is due to co-isolated species that have similar elution time and parent ion m/z.

```{r results='hide'}
# Path to MASIC data
path_to_MASIC_results <- system.file("extdata/global/masic_output", 
                                     package = "PlexedPiperTestData")

# Read MASIC data
masic_data <- read_masic_data(path_to_MASIC_results, interference_score = TRUE)
```

Normally, this would display two progress bars in the console as the data is being fetched. However, the output was suppressed to save space.

```{r global-masic-table, echo=FALSE}
kable(head(masic_data, 10), digits = 3, row.names = FALSE, 
      caption = "<left>First 10 rows of the MASIC data.</left>",
      escape = FALSE, format = "html") %>% 
  kable_styling(full_width = FALSE, font_size = 12) %>%
  scroll_box(height = "20em", width = "100%")
```

</br>

Table \@ref(tab:global-masic-table) shows the first 10 rows of `masic_data`.


#### Filter MASIC Data {-}

Currently, we recommend keeping entries where at least 50% of the ion population is due to the targeted ion (interference score $\geq$ 0.5) and not filtering by S/N.

```{r}
# Filter MASIC data
masic_data <- filter_masic_data(masic_data, 
                                interference_score_threshold = 0.5,
                                s2n_threshold = 0)
```

### Create Study Design Tables {#fetch-study-design-tables}

To convert from PSMs and reporter ion intensities to meaningful quantitative data, it is necessary to know what are the samples in the reporter channels and what is the intended reference channel (or combination of channels). The entire study design is captured by three tables - fractions, samples, references. With newly processed data, these typically do not exist, and must be created. If the tables already exist, the code to access them is as follows.

```{r eval=FALSE}
# Read tables from folder:
fractions <- read_tsv(system.file("extdata/study_design/fractions.txt", 
                                  package = "PlexedPiperTestData"))
samples <- read_tsv(system.file("extdata/study_design/samples.txt", 
                                package = "PlexedPiperTestData"))
references <- read_tsv(system.file("extdata/study_design/references.txt", 
                                   package = "PlexedPiperTestData"))

# If using a data package from the DMS:
study_design <- read_study_design_from_DMS(data_package_num)
fractions <- study_design$fractions
samples <- study_design$samples
references <- study_design$references
```


#### Fractions {-}

The fractions table consists of two columns: `Dataset` and `PlexID`. The `Dataset` column contains all of the unique datasets from `msnid$Dataset` or `masic_data$Dataset`. The `PlexID` column contains the plex ID associated with each dataset, and is typically an "S" followed by a number ("S1", "S2", etc.). We can extract the plex ID from the datasets. In this case, the plex ID always comes after "_W_", so we can use a regular expression (regex) to capture it (the first argument of `gsub`). The regex below says to capture an "S" followed by a single digit that appears after "_W_" and before an underscore.

```{r}
# Create fractions table
fractions <- data.frame(Dataset = unique(masic_data$Dataset)) %>% 
  mutate(PlexID = gsub(".*_W_(S\\d{1})_.*", "\\1", Dataset))
```

```{r fractions-table, echo=FALSE}
kable(head(fractions, 10), row.names = FALSE, 
      caption = "<left>First 10 rows of the fractions table.</left>",
      escape = FALSE, format = "html") %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

</br>

Table \@ref(tab:fractions-table) shows the first 10 rows of `fractions`.


#### Samples {-}

The samples table contains columns `PlexID`, `QuantBlock`, `ReporterName`, `ReporterAlias`, and `MeasurementName`. The plex ID must be the same as the plex ID in the `fractions` table. `ReporterName` is the reporter ion name ("126", "127N", "127C", etc.). `ReporterAlias` is the intermediate between `ReporterName` and `MeasurementName` and is used for defining the reference. `MeasurementName` determines the column names for the final cross-tab, and must be unique and begin with a letter. `MeasurementName` is easily constructed by prepending `PlexID` to the `ReporterName`. Finally, `QuantBlock` can be thought of as a way of defining sub-plex. In a typical TMT experiment, `QuantBlock` is always 1. In case of 5 pairwise comparisons within TMT10, there will be 5 QuantBlocks (1-5) with a reference for each `QuantBlock`.

For this experiment, channel 131 will serve as the reference, so we set `MeasurementName` to `NA` when `ReporterName` is `"131"`. This will make the reference channel absent from the quantitative cross-tab. In cases where reporter ion intensities are not normalized by a reference channel (reference = 1) or they are normalized by the average of select channels, do not set any `MeasurementName` to `NA`.

```{r}
# TMT10 Reporter Converter table from MSnID package
conv <- reporter_converter$tmt10
plexes <- unique(fractions$PlexID)

# Reference channel
ref_channel <- "131"

# Create samples table
samples <- data.frame(PlexID = rep(plexes, each = nrow(conv)),  
                      ReporterName = rep(conv$ReporterName, 
                                         length(plexes))) %>% 
  mutate(ReporterAlias = sprintf("%s_%s", PlexID, ReporterName),
         MeasurementName = ReporterAlias,
         QuantBlock = 1,
         # Comment out this next part if the reference
         # is not one of the reporter ion channels.
         MeasurementName = ifelse(ReporterName == ref_channel,
                                  NA, MeasurementName)
  )
```

```{r samples-table, echo=FALSE}
kable(head(samples, 10), row.names = FALSE, 
      caption = "<left>First 10 rows of the samples table.</left>",
      escape = FALSE, format = "html") %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

</br>

Table \@ref(tab:samples-table) shows the first 10 rows of `samples`.


#### References {-}

Reference can be a certain channel, average of multiple channels, or 1. The general form is an expression with `ReporterAlias` names as variables. It is evaluated for each `PlexID`/`QuantBlock` combination and applied to divide reporter ion intensities within corresponding `PlexID`/`QuantBlock`.

```{r}
# Create references table
references <- samples %>% 
  # Filter to reference channel
  filter(ReporterName == ref_channel) %>% 
  # Select required columns and rename ReporterAlias to Reference
  select(PlexID, Reference = ReporterAlias, QuantBlock)
```

```{r references-table, echo=FALSE}
kable(references, row.names = FALSE, 
      caption = "<left>References table.</left>",
      escape = FALSE, format = "html") %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

</br>

Table \@ref(tab:references-table) shows the first 10 rows of `references`. The code to use the geometric average instead of a single channel as the reference is shown below. The geometric average is the product of the reporter ion channels to the power of (1/number of channels). For each `PlexID` group, collapse the vector of reporter ion names with `*`, surround them in parentheses, and raise to the power of (1/number of channels).

```{r eval=FALSE}
# Use geometric average as reference
references <- samples %>%
  group_by(PlexID, QuantBlock) %>%
  summarise(Reference = sprintf("(%s)^(1/%d)", 
                                paste(ReporterAlias, collapse = "*"), n()))

# Do not normalize by reference channel (use 1 as the reference)
references <- samples %>% 
  distinct(PlexID, QuantBlock) %>% 
  mutate(Reference = 1)
```

Now that we have the three study design tables, we should save them.

<!---
TODO:
Explain how to add the study design tables to the DMS.
--->

```{r eval=FALSE}
# Save study design tables
write.table(fractions, file = "fractions.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
write.table(samples, file = "samples.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
write.table(references, file = "references.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
```


### Create Quantitative Cross-tab {#global-quant-crosstab}

This is the final step where MS/MS IDs and reporter ions are linked together and aggregated to the peptide or accession (i.e. protein) level. To retain protein IDs while aggregating to peptide level, set `aggregation_level <- c("accession","peptide")`. The entries are $log_2$-transformed after being normalized by the reference.

```{r}
# Set aggregation level
aggregation_level <- c("accession")
# Create cross-tab
crosstab <- create_crosstab(msnid, masic_data,
                            aggregation_level = aggregation_level,
                            fractions, samples, references)
```

```{r echo=FALSE}
kable(head(crosstab, 10), row.names = TRUE, 
      caption = "<left>First 10 rows of the global quantitative cross-tab.</left>",
      escape = FALSE, format = "html") %>% 
  kable_styling(full_width = FALSE, font_size = 12) %>% 
  scroll_box(height = "20em", width = "100%")
```

</br>

In order to demonstrate prioritized inference in Section \@ref(phosphoproteomics-data), we need to save the row names of this cross-tab.

```{r}
# Save protein names
saveRDS(rownames(crosstab), file = "data/3442_global_protein_names.rds")
```

We should save the cross-tab as well. To do so, we need to convert the row names to a column called `protein`.

```{r}
# Modify cross-tab for saving
crosstab <- crosstab %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column("protein")

# Save cross-tab
write.table(crosstab, file = "data/global_quant_crosstab.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
```


## Phosphoproteomics Data {#phosphoproteomics-data}

This pipeline shows how to process data from the DMS. The number of the data package is `3626`. For this section, we need the `PlexedPiper` package for isobaric quantification and `PNNL.DMS.utils` to interface with the DMS. Also, some details will be omitted if they were already provided in Section \@ref(global-proteomics-data).

```{r message=FALSE}
# Setup
library(PNNL.DMS.utils)
library(PlexedPiper)
library(Biostrings)
library(dplyr) # %>%
```


### Prepare MS/MS Identifications {#prepare-MS2-IDs-phospho}

#### Read MS-GF+ Output {-}

```{r results='hide'}
# Read MS-GF+ data
data_package_num <- 3626
msnid <- read_msgf_data_from_DMS(data_package_num)
```

```{r}
show(msnid)
```


#### Remove Non-Phosphorylated Peptides {-}

In this case, the phosphorylation of an amino acid is marked by a `*` appearing after the amino acid. We will not consider unmodified peptides, so we can filter them out. The `*` is a special character that must be escaped with backslashes, and the backslashes must also be escaped.

```{r}
# Remove non-phosphorylated peptides
# (peptides that do not contain a *)
msnid <- apply_filter(msnid, "grepl('\\\\*', peptide)")
show(msnid)
```


#### Correct Isotope Selection Error {-}

```{r}
# Correct for isotope selection error
msnid <- correct_peak_selection(msnid)
```


#### Remove Contaminants {-}

```{r}
# Remove contaminants
msnid <- apply_filter(msnid, "!grepl('Contaminant', accession)")
show(msnid)
```


#### AScore {-}

Phospho datasets involve AScore jobs for improving phosphosite localization. There should be one AScore job per data package. The fetched object is a data.frame that links datasets, scans and original PTM localization to newly suggested locations. Importantly, it contains `AScore` column that signifies the confidence of PTM assignment. AScore > 17 is considered confident.

```{r results='hide'}
# Filter PTMs by AScore
ascore <- get_AScore_results(data_package_num)
msnid <- best_PTM_location_by_ascore(msnid, ascore)
```

```{r}
show(msnid)
```


#### MS/MS ID Filter: Peptide Level {-}

```{r}
# 1% FDR filter at the peptide level
msnid <- filter_msgf_data(msnid,
                          level = "peptide",
                          fdr.max = 0.01)
show(msnid)
```

#### MS/MS ID Filter: Protein Level {-}

```{r message=FALSE, warning=FALSE}
# Get path to FASTA file
path_to_FASTA <- path_to_FASTA_used_by_DMS(data_package_num)

# Compute number of peptides per 1000 amino acids
msnid <- compute_num_peptides_per_1000aa(msnid, path_to_FASTA)

# 1% FDR filter at the protein level
msnid <- filter_msgf_data(msnid,
                          level = "accession",
                          fdr.max = 0.01)
show(msnid)
```

#### Inference of Parsimonious Protein Set {-}

<!---
TODO:
* Talk about using prior information from global cross-tab to improve inference of the parsimonious protein set for phospho data.
--->

```{r}
# Load proteins from global crosstab
global_proteins <- readRDS("data/3442_global_protein_names.rds")
# Inference of parsimonious protein set
msnid <- infer_parsimonious_accessions(msnid, unique_only = FALSE,
                                       prior = global_proteins)
show(msnid)
```

Notice that the protein-level FDR increased above the acceptable threshold, so we need to reapply the filter.

```{r}
# 1% FDR filter at the protein level
msnid <- filter_msgf_data(msnid,
                          level = "accession",
                          fdr.max = 0.01)
show(msnid)
```

```{r}
# Remove Decoy Accessions
msnid <- apply_filter(msnid, "!isDecoy")
show(msnid)
```

#### Map Sites to Protein Sequences {-}

Prepare FASTA to make sure entry names in FASTA file match MSnID accessions. The plan is to make this conversion automatic. `map_mod_sites` creates number of columns describing mapping of the site/s onto the protein sequences. The most important for the user is `SiteID`.

```{r}
# Create AAStringSet
fst <- readAAStringSet(path_to_FASTA)
# Remove contaminants
fst <- fst[!grepl("Contaminant", names(fst)), ]
# First 6 names
head(names(fst))
```

```{r}
# Modify names to match accessions(msnid)
names(fst) <- strsplit(names(fst), split = " ") %>% 
  # Select text before first space
  lapply(function(x) x[1]) %>% 
  unlist()
# First 6 names
head(names(fst))
```

```{r}
# Main mapping call
msnid <- map_mod_sites(object = msnid, fasta = fst, 
                       accession_col = "accession", 
                       peptide_mod_col = "peptide", 
                       mod_char = "*",
                       site_delimiter = "lower")
```

```{r phospho-msnid-table, echo=FALSE}
fix_phos <- function(x) {
  gsub("\\*", "\\\\*", x)
}
x <- head(psms(msnid), 10) %>% 
  mutate_if(is.character, fix_phos)
kable(x, digits = 3, row.names = FALSE, 
      caption = "<left>First 10 rows of the processed MS-GF+ results.</left>",
      escape = FALSE, format = "html") %>% 
  kable_styling(full_width = FALSE, font_size = 12) %>%
  scroll_box(height = "20em", width = "100%")
```

</br>

Table \@ref(tab:phospho-msnid-table) shows the first 10 rows of the processed MS-GF+ output.


### Prepare Reporter Ion Intensities {#phospho-reporter-ion-intensities}

#### Read MASIC Output {-}

```{r results='hide'}
# Read MASIC data
masic_data <- read_masic_data_from_DMS(data_package_num, 
                                       interference_score = TRUE)
```


#### Filter MASIC Data {-}

```{r}
# Filter MASIC data
masic_data <- filter_masic_data(masic_data, 
                                interference_score_threshold = 0.5,
                                s2n_threshold = 0)
```


### Create Study Design Tables

#### Fractions {-}

```{r}
# Create fractions table
fractions <- data.frame(Dataset = unique(masic_data$Dataset)) %>% 
  mutate(PlexID = gsub(".*_P_(S\\d{1})_.*", "\\1", Dataset))
```


#### Samples {-}

```{r}
# TMT10 Reporter Converter table from MSnID package
conv <- reporter_converter$tmt10
plexes <- unique(fractions$PlexID)

# Reference channel
ref_channel <- "131"

# Create samples table
samples <- data.frame(PlexID = rep(plexes, each = nrow(conv)),  
                      ReporterName = rep(conv$ReporterName, 
                                         length(plexes))) %>% 
  mutate(ReporterAlias = sprintf("%s_%s", PlexID, ReporterName),
         MeasurementName = ReporterAlias,
         QuantBlock = 1,
         # Comment out this next part if the reference
         # is not one of the reporter ion channels.
         MeasurementName = ifelse(ReporterName == ref_channel,
                                  NA, MeasurementName)
  )
```

#### References {-}

```{r}
# Create references table
references <- samples %>% 
  # Filter to reference channel
  filter(ReporterName == ref_channel) %>% 
  # Select required columns and rename ReporterAlias to Reference
  select(PlexID, Reference = ReporterAlias, QuantBlock)
```


### Create Quantitative Cross-tab {#phospho-create-crosstab}

```{r}
# Set aggregation level
aggregation_level <- c("accession", "peptide")
# Create cross-tab
crosstab <- create_crosstab(msnid, masic_data,
                            aggregation_level = aggregation_level,
                            fractions, samples, references)
```

```{r echo=FALSE}
x <- head(crosstab, 10)
rownames(x) <- gsub("\\*", "\\\\*", rownames(x))
rownames(x) <- gsub("\\@", "\\@\\\\hphantom{}", rownames(x))
kable(x, row.names = TRUE, 
      caption = "<left>First 10 rows of the phospho quantitative cross-tab.</left>", format = "html",
      escape = FALSE) %>% 
  kable_styling(font_size = 12) %>% 
  scroll_box(height = "20em", width = "100%")
```

</br>

We will save the cross-tab for later sections.

```{r}
# Modify cross-tab for saving
crosstab <- crosstab %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column("phospho_peptide")

# Save cross-tab
write.table(crosstab, file = "data/phospho_quant_crosstab.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
```

