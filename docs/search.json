[{"path":"index.html","id":"welcome","chapter":"Welcome!","heading":"Welcome!","text":"tutorial much work-progress. Even sections appear finished likely changed. update significant progress made. Thank patience.","code":""},{"path":"index.html","id":"miscellaneous-resources","chapter":"Welcome!","heading":"Miscellaneous Resources","text":"highly recommended review resources presented section continuing rest book.Proteomics Overview\nProtein Analysis Shotgun/Bottom-Proteomics\nModern Proteomics – Sample Preparation, Analysis Practical Applications\nLiquid Chromatography Mass Spectrometry-Based Proteomics: Biological Technological Aspects\nProtein Analysis Shotgun/Bottom-ProteomicsModern Proteomics – Sample Preparation, Analysis Practical ApplicationsLiquid Chromatography Mass Spectrometry-Based Proteomics: Biological Technological AspectsMass Spectrometry\nWarwick School Life Sciences Teaching Animations\nTandem Mass Spectrometry Peptide Protein Sequence Analysis\nMaestro: Comprehensive, Multi-Stage Spectrum Identification Protein Mass Spectrometry\nSearching databases protein identification - part 1 (YouTube video)\nMass spectrometry proteomics - part one (YouTube video)\nElectrospray Ionisation Mass Spectrometry: Principles Clinical Applications\nMass SpectrometryWarwick School Life Sciences Teaching AnimationsTandem Mass Spectrometry Peptide Protein Sequence AnalysisMaestro: Comprehensive, Multi-Stage Spectrum Identification Protein Mass SpectrometrySearching databases protein identification - part 1 (YouTube video)Mass spectrometry proteomics - part one (YouTube video)Electrospray Ionisation Mass Spectrometry: Principles Clinical ApplicationsPNNL’s Data Management System (DMS)PNNL’s Data Management System (DMS)Integrative Omics PRISMWikiIntegrative Omics PRISMWikiUniversal Protein Resource (UniProt): protein sequence annotation dataUniversal Protein Resource (UniProt): protein sequence annotation dataFalse Discovery Rate (FDR)\ntalk protein‐level false discovery rates shotgun proteomics\nPosterior Error Probabilities False Discovery Rates: Two Sides Coin\nFalse Discovery Rate: PEAKS FDR Estimation\nFalse discovery rates spectral identification\nFalse Discovery Rate (FDR)talk protein‐level false discovery rates shotgun proteomicsPosterior Error Probabilities False Discovery Rates: Two Sides CoinFalse Discovery Rate: PEAKS FDR EstimationFalse discovery rates spectral identificationRStudio CheatsheetsRStudio CheatsheetsPattern matching regular expressions\nR Data Science: Strings\nRegexOne: Learn Regular Expressions simple, interactive exercises.\nPattern matching regular expressionsR Data Science: StringsRegexOne: Learn Regular Expressions simple, interactive exercises.","code":""},{"path":"isobaric-quantification-pipelines.html","id":"isobaric-quantification-pipelines","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"Section 1 Isobaric Quantification Pipelines","text":"Section summary added later. Please continue subsections.","code":""},{"path":"isobaric-quantification-pipelines.html","id":"global-proteomics-data","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1 Global Proteomics Data","text":"pipeline shows process TMT data processed outside PNNL’s DMS. Section 1.2 shows process data DMS. convenience, results MS-GF+ MASIC processing provided companion PlexedPiperTestData package. section, need three packages: PlexedPiper isobaric quantification, PlexedPiperTestData, dplyr manipulate data frames.","code":"\n# Setup\nlibrary(PlexedPiper)\nlibrary(PlexedPiperTestData)\nlibrary(dplyr)\nlibrary(ggplot2) # plotting\nlibrary(knitr) # embed images"},{"path":"isobaric-quantification-pipelines.html","id":"prepare-MS2-IDs-global","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.1 Prepare MS/MS Identifications","text":"","code":""},{"path":"isobaric-quantification-pipelines.html","id":"read-ms-gf-data","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.1.1 Read MS-GF+ Data","text":"Normally, display progress bar console data fetched. However, output suppressed save space. can view summary MSnID object show() function.msnid consists 4 spectrum files (datasets), contains total 1,156,754 peptide-spectrum-matches (PSMs), 511,617 total peptides, 128,378 total accessions (proteins). reported FDR empirical false-discovery rate, calculated ratio number false (decoy) PSMs, peptides, accessions true (non-decoy) counterparts. Calculation counts FDRs shown .Now MSnID object, need process .","code":"\n# Get file path\npath_to_MSGF_results <- system.file(\"extdata/global/msgf_output\", \n                                    package = \"PlexedPiperTestData\")\n# Read MS-GF+ data from path\nmsnid <- read_msgf_data(path_to_MSGF_results)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  48 \n## #PSMs: 1156754 at 31 % FDR\n## #peptides: 511617 at 61 % FDR\n## #accessions: 128378 at 98 % FDR\n# Calculating the counts and FDRs from the show() output ---\n# Spectrum Files:\n# Count\npsms(msnid) %>% \n  distinct(Dataset) %>%\n  nrow() # 48\n\n# PSMs:\n# Count\npsms(msnid) %>% \n  distinct(Dataset, Scan, peptide, isDecoy) %>%\n  # Assign intermediate to variable\n  assign(\"x_psm\", ., envir = globalenv()) %>% \n  nrow() # 1156754\n# FDR\nnrow(x_psm[x_psm$isDecoy == TRUE, ]) / \n  nrow(x_psm[x_psm$isDecoy == FALSE, ]) \n# 0.3127463 = 31%\n\n# peptides:\n# Count\npsms(msnid) %>% \n  distinct(peptide, isDecoy) %>% \n  assign(\"x_peptide\", ., envir = globalenv()) %>%\n  nrow() # 511617\n# FDR\nnrow(x_peptide[x_peptide$isDecoy == TRUE, ]) / \n  nrow(x_peptide[x_peptide$isDecoy == FALSE, ])\n# 0.611245 = 61%\n\n# Accessions:\n# Count\nlength(accessions(msnid)) # or\npsms(msnid) %>% \n  distinct(accession, isDecoy) %>% \n  assign(\"x_acc\", ., envir = globalenv()) %>%\n  nrow() # 128378\n# FDR\nnrow(x_acc[x_acc$isDecoy == TRUE, ]) / \n  nrow(x_acc[x_acc$isDecoy == FALSE, ])\n# 0.9827024 = 98%"},{"path":"isobaric-quantification-pipelines.html","id":"correct-isotope-selection-error","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.1.2 Correct Isotope Selection Error","text":"Occasionally, instrument selects non-monoisotopic peak parent ions fragmentation, peptides 1 Daltons considered. (exact, difference 1.0033548378 Da, \\(^{13}\\text{C}\\)-\\(^{12}\\text{C}\\).) MS-FG+ still capable correctly identifying peptides, downstream calculations mass measurement error need fixed (Figure 1.1), used filtering later (Section 1.1.1.4). correct_peak_selection function corrects mass measurement errors.\nFigure 1.1: Histogram mass measurement errors correction.\n","code":"\n# Correct for isotope selection error\nmsnid <- correct_peak_selection(msnid)"},{"path":"isobaric-quantification-pipelines.html","id":"remove-contaminants","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.1.3 Remove Contaminants","text":"Now, remove contaminants pig trypsin used protein digestion. can use grepl search accessions contain “Contaminant.”remove contaminants, use apply_filter appropriate character string tells function rows keep. case, keep rows accession contain “Contaminant.” use show see counts change.","code":"\n# All unique contaminants\nunique(msnid$accession[grepl(\"Contaminant\", msnid$accession)])##  [1] \"Contaminant_K2C1_HUMAN\"      \"Contaminant_K1C9_HUMAN\"     \n##  [3] \"Contaminant_ALBU_HUMAN\"      \"Contaminant_ALBU_BOVIN\"     \n##  [5] \"Contaminant_TRYP_PIG\"        \"Contaminant_K1C10_HUMAN\"    \n##  [7] \"XXX_Contaminant_K1C9_HUMAN\"  \"Contaminant_K22E_HUMAN\"     \n##  [9] \"Contaminant_Trypa3\"          \"Contaminant_Trypa5\"         \n## [11] \"XXX_Contaminant_K1C10_HUMAN\" \"XXX_Contaminant_K22E_HUMAN\" \n## [13] \"XXX_Contaminant_K2C1_HUMAN\"  \"Contaminant_TRYP_BOVIN\"     \n## [15] \"XXX_Contaminant_ALBU_HUMAN\"  \"XXX_Contaminant_ALBU_BOVIN\" \n## [17] \"XXX_Contaminant_TRYP_BOVIN\"  \"Contaminant_CTRB_BOVIN\"     \n## [19] \"Contaminant_Trypa1\"          \"Contaminant_Trypa6\"         \n## [21] \"Contaminant_CTRA_BOVIN\"      \"XXX_Contaminant_TRYP_PIG\"   \n## [23] \"XXX_Contaminant_CTRB_BOVIN\"  \"XXX_Contaminant_CTRA_BOVIN\" \n## [25] \"Contaminant_Trypa2\"\n# Remove contaminants\nmsnid <- apply_filter(msnid, \"!grepl('Contaminant', accession)\")\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  48 \n## #PSMs: 1155442 at 31 % FDR\n## #peptides: 511196 at 61 % FDR\n## #accessions: 128353 at 98 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"global-peptide-filter","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.1.4 MS/MS ID Filter: Peptide Level","text":"next step filter MS/MS identifications empirical pwptide-level FDR less threshold number MS/MS IDs maximized. use \\(-log_{10}\\) PepQValue column one filtering criteria assign new column psms(msnid) called msmsScore. PepQValue column MS-GF+ Spectrum E-value, reflects well theoretical experimental fragmentation spectra match; therefore, high values msmsScore indicate good match (see Figure 1.2).\nFigure 1.2: Density plot msmsScore dashed line indicating baseline, un-optimized cutoff.\nfiltering criteria absolute deviation mass measurement error parent ions parts-per-million (ppm), assigned absParentMassErrorPPM column psms(msnid) (see Figure 1.3).\nFigure 1.3: Density plot absParentMassErrorPPM dashed line indicating baseline, un-optimized cutoff.\nNow, filter PSMs.can see filtering drastically reduces number PSMs, empirical peptide-level FDR now 1%. However, notice empirical protein-level FDR still fairly high.","code":"\n# 1% FDR filter at the peptide level\nmsnid <- filter_msgf_data(msnid,\n                          level = \"peptide\",\n                          fdr.max = 0.01)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  48 \n## #PSMs: 464482 at 0.45 % FDR\n## #peptides: 96486 at 1 % FDR\n## #accessions: 27120 at 9.2 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"msms-id-filter-protein-level","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.1.5 MS/MS ID Filter: Protein Level","text":"Now, need filter proteins FDR 1%. ago, proteomics field established hard--fast two-peptides-per-protein rule. , confident identification protein requires confident identification least 2 peptides. rule penalizes short proteins doesn’t consider long proteins (e.g. Titin 3.8 MDa) easily two matching peptides even reversed sequence. Thus, propose normalize number peptides per protein length use filtering criterion (Figure 1.5).order get protein lengths, need FASTA (pronounced FAST-AYE) file contains protein sequences used database search. first three entries FASTA file shown Figure 1.4.\nFigure 1.4: First three entries FASTA file.\nprotein, divide number associated peptides length protein multiply value 1000. new peptides_per_1000aa column used filter criteria.\nFigure 1.5: Density plot peptides_per_1000aa. Proteins values greater 1 selected default prior optimization. plot area zoomed .\nNow, filter proteins 1% FDR.","code":"\n# Get path to FASTA file\npath_to_FASTA <- system.file(\n  \"extdata/Rattus_norvegicus_NCBI_RefSeq_2018-04-10.fasta.gz\", \n  package = \"PlexedPiperTestData\"\n)\n\n# Compute number of peptides per 1000 amino acids\nmsnid <- compute_num_peptides_per_1000aa(msnid, path_to_FASTA)\n# 1% FDR filter at the protein level\nmsnid <- filter_msgf_data(msnid,\n                          level = \"accession\",\n                          fdr.max = 0.01)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  48 \n## #PSMs: 458097 at 0.16 % FDR\n## #peptides: 92036 at 0.32 % FDR\n## #accessions: 15630 at 1 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"inference-of-parsimonious-protein-set","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.1.6 Inference of Parsimonious Protein Set","text":"situation certain peptide sequence matches multiple proteins adds complication downstream quantitative analysis, clear protein peptide originating . common ways dealing . One simply retain uniquely matching peptides discard shared peptides (unique_only = TRUE). Alternatively, assign shared peptides proteins larger number uniquely mapping peptides (unique_only = FALSE). choice multiple proteins equal numbers uniquely mapping peptides, shared peptides assigned first protein according alphanumeric order (Figure 1.6). step done prior filtering accession level, peptides assigned low-confidence protein, protein removed filtering, peptides lost. Instead, better filter set confidently-identified proteins determine parsimonious set.\nFigure 1.6: Visual explanation inference parsimonious protein set.\nNotice protein-level FDR increased acceptable threshold, need reapply filter.filtering done, can remove decoy accessions. use apply_filter function keep entries isDecoy FALSE.processing, left 444,213 PSMs, 90,156 peptides, 5,171 proteins. Table 1.1 shows first 6 rows processed MS-GF+ output.\nTable 1.1: First 6 rows processed MS-GF+ results.","code":"\n# Inference of parsimonious protein set\nmsnid <- infer_parsimonious_accessions(msnid, unique_only = FALSE)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  48 \n## #PSMs: 445006 at 0.15 % FDR\n## #peptides: 90478 at 0.27 % FDR\n## #accessions: 5251 at 1.1 % FDR\n# 1% FDR filter at the protein level\nmsnid <- filter_msgf_data(msnid,\n                          level = \"accession\",\n                          fdr.max = 0.01)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  48 \n## #PSMs: 444850 at 0.14 % FDR\n## #peptides: 90384 at 0.25 % FDR\n## #accessions: 5222 at 0.99 % FDR\n# Remove Decoy Accessions\nmsnid <- apply_filter(msnid, \"!isDecoy\")\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  48 \n## #PSMs: 444213 at 0 % FDR\n## #peptides: 90156 at 0 % FDR\n## #accessions: 5171 at 0 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"reporter-ion-intensities","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.2 Prepare Reporter Ion Intensities","text":"","code":""},{"path":"isobaric-quantification-pipelines.html","id":"read-masic-output","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.2.1 Read MASIC Output","text":"MASIC tool extracting ion intensities. proper parameter settings, can used extracting TMT (iTRAQ) reporter ion intensities. addition, reports number helpful metrics. Notably, interference score parent ion level signal--noise ratio (S/N) reporter ion level (computed Thermo software). interference score reflects proportion ion population isolated fragmentation due targeted ion. words, 1 - InterferenceScore due co-isolated species similar elution time parent ion m/z.Normally, display two progress bars console data fetched. However, output suppressed save space.\nTable 1.2: First 6 rows MASIC data.Table 1.2 shows first 6 rows masic_data.","code":"\n# Path to MASIC data\npath_to_MASIC_results <- system.file(\"extdata/global/masic_output\", \n                                     package = \"PlexedPiperTestData\")\n\n# Read MASIC data\nmasic_data <- read_masic_data(path_to_MASIC_results, interference_score = TRUE)"},{"path":"isobaric-quantification-pipelines.html","id":"filter-masic-data","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.2.2 Filter MASIC Data","text":"Currently, recommend keeping entries least 50% ion population due targeted ion (interference score \\(\\geq\\) 0.5) filtering S/N.","code":"\n# Filter MASIC data\nmasic_data <- filter_masic_data(masic_data, \n                                interference_score_threshold = 0.5,\n                                s2n_threshold = 0)"},{"path":"isobaric-quantification-pipelines.html","id":"fetch-study-design-tables","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.3 Create Study Design Tables","text":"convert PSMs reporter ion intensities meaningful quantitative data, necessary know samples reporter channels intended reference channel (combination channels). entire study design captured three tables - fractions, samples, references. newly processed data, typically exist, must created. tables already exist, code access follows.","code":"\n# Read tables from folder:\nfractions <- read_tsv(system.file(\"extdata/study_design/fractions.txt\", \n                                  package = \"PlexedPiperTestData\"))\nsamples <- read_tsv(system.file(\"extdata/study_design/samples.txt\", \n                                package = \"PlexedPiperTestData\"))\nreferences <- read_tsv(system.file(\"extdata/study_design/references.txt\", \n                                   package = \"PlexedPiperTestData\"))\n\n# If using a data package from the DMS:\nstudy_design <- read_study_design_from_DMS(data_package_num)\nfractions <- study_design$fractions\nsamples <- study_design$samples\nreferences <- study_design$references"},{"path":"isobaric-quantification-pipelines.html","id":"fractions","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.3.1 Fractions","text":"fractions table consists two columns: Dataset PlexID. Dataset column contains unique datasets msnid$Dataset masic_data$Dataset. PlexID column contains plex ID associated dataset, typically “S” followed number (“S1,” “S2,” etc.). can extract plex ID datasets. case, plex ID always comes “W,” can use regular expression (regex) capture (first argument gsub). regex says capture “S” followed single digit appears “W” underscore.\nTable 1.3: First 10 rows fractions table.Table 1.3 shows first 10 rows fractions.","code":"\n# Create fractions table\nfractions <- data.frame(Dataset = unique(masic_data$Dataset)) %>% \n  mutate(PlexID = gsub(\".*_W_(S\\\\d{1})_.*\", \"\\\\1\", Dataset))"},{"path":"isobaric-quantification-pipelines.html","id":"samples","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.3.2 Samples","text":"samples table contains columns PlexID, QuantBlock, ReporterName, ReporterAlias, MeasurementName. plex ID must plex ID fractions table. ReporterName reporter ion name (“126,” “127N,” “127C,” etc.). ReporterAlias intermediate ReporterName MeasurementName used defining reference. MeasurementName determines column names final cross-tab, must unique begin letter. MeasurementName usually sample names; however, information, instead prepend PlexID ReporterName create MeasurementName. Finally, QuantBlock can thought way defining sub-plex. typical TMT experiment, QuantBlock always 1. case 5 pairwise comparisons within TMT10, 5 QuantBlocks (1-5) reference QuantBlock.experiment, channel 131 serve reference, set MeasurementName NA ReporterName \"131\". make reference channel absent quantitative cross-tab. cases reporter ion intensities normalized reference channel (reference = 1) normalized average select channels, set MeasurementName NA.\nTable 1.4: First 10 rows samples table.Table 1.4 shows first 10 rows samples.","code":"\n# TMT10 Reporter Converter table from MSnID package\nconv <- reporter_converter$tmt10\nplexes <- unique(fractions$PlexID)\n\n# Reference channel\nref_channel <- \"131\"\n\n# Create samples table\nsamples <- data.frame(PlexID = rep(plexes, each = nrow(conv)),  \n                      ReporterName = rep(conv$ReporterName, \n                                         length(plexes))) %>% \n  mutate(ReporterAlias = sprintf(\"%s_%s\", PlexID, ReporterName),\n         MeasurementName = ReporterAlias,\n         QuantBlock = 1,\n         # Comment out this next part if the reference\n         # is not one of the reporter ion channels.\n         MeasurementName = ifelse(ReporterName == ref_channel,\n                                  NA, MeasurementName)\n  )"},{"path":"isobaric-quantification-pipelines.html","id":"references","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.3.3 References","text":"Reference can certain channel, average multiple channels, 1. general form expression ReporterAlias names variables. evaluated PlexID/QuantBlock combination applied divide reporter ion intensities within corresponding PlexID/QuantBlock.\nTable 1.5: References table.Table 1.5 shows first 10 rows references. code use geometric average instead single channel reference shown . geometric average product reporter ion channels power (1/number channels). PlexID group, collapse vector reporter ion names *, surround parentheses, raise power (1/number channels).Now three study design tables, save .","code":"\n# Create references table\nreferences <- samples %>% \n  # Filter to reference channel\n  filter(ReporterName == ref_channel) %>% \n  # Select required columns and rename ReporterAlias to Reference\n  select(PlexID, Reference = ReporterAlias, QuantBlock)\n# Use geometric average as reference\nreferences <- samples %>%\n  group_by(PlexID, QuantBlock) %>%\n  summarise(Reference = sprintf(\"(%s)^(1/%d)\", \n                                paste(ReporterAlias, collapse = \"*\"), n()))\n\n# Do not normalize by reference channel (use 1 as the reference)\nreferences <- samples %>% \n  distinct(PlexID, QuantBlock) %>% \n  mutate(Reference = 1)\n# Save study design tables\nwrite.table(fractions, file = \"fractions.txt\",\n            sep = \"\\t\", quote = FALSE, row.names = FALSE)\nwrite.table(samples, file = \"samples.txt\",\n            sep = \"\\t\", quote = FALSE, row.names = FALSE)\nwrite.table(references, file = \"references.txt\",\n            sep = \"\\t\", quote = FALSE, row.names = FALSE)"},{"path":"isobaric-quantification-pipelines.html","id":"global-quant-crosstab","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.1.4 Create Quantitative Cross-tab","text":"final step MS/MS IDs reporter ions linked together aggregated peptide accession (.e. protein) level. retain protein IDs aggregating peptide level, set aggregation_level <- c(\"accession\",\"peptide\"). entries \\(log_2\\)-transformed normalized reference.\nTable 1.6: First 6 rows global quantitative cross-tab.order demonstrate prioritized inference Section 1.2, need save row names cross-tab.save cross-tab well. , need convert row names column called protein.","code":"\n# Set aggregation level\naggregation_level <- c(\"accession\")\n# Create cross-tab\ncrosstab <- create_crosstab(msnid, masic_data,\n                            aggregation_level = aggregation_level,\n                            fractions, samples, references)\n# Save protein names\nsaveRDS(rownames(crosstab), file = \"data/3442_global_protein_names.rds\")\n# Modify cross-tab for saving\ncrosstab <- crosstab %>% \n  as.data.frame() %>% \n  tibble::rownames_to_column(\"protein\")\n\n# Save cross-tab\nwrite.table(crosstab, file = \"data/global_quant_crosstab.txt\",\n            sep = \"\\t\", quote = FALSE, row.names = FALSE)"},{"path":"isobaric-quantification-pipelines.html","id":"phosphoproteomics-data","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2 Phosphoproteomics Data","text":"pipeline shows process data DMS. number data package 3626. section, need PlexedPiper package isobaric quantification PNNL.DMS.utils interface DMS. Also, details omitted already provided Section 1.1.","code":"\n# Setup\nlibrary(PNNL.DMS.utils)\nlibrary(PlexedPiper)\nlibrary(Biostrings)\nlibrary(dplyr) # %>%"},{"path":"isobaric-quantification-pipelines.html","id":"prepare-MS2-IDs-phospho","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1 Prepare MS/MS Identifications","text":"","code":""},{"path":"isobaric-quantification-pipelines.html","id":"read-ms-gf-output","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.1 Read MS-GF+ Output","text":"","code":"\n# Read MS-GF+ data\ndata_package_num <- 3626\nmsnid <- read_msgf_data_from_DMS(data_package_num)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 612667 at 55 % FDR\n## #peptides: 396540 at 75 % FDR\n## #accessions: 121521 at 98 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"remove-non-phosphorylated-peptides","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.2 Remove Non-Phosphorylated Peptides","text":"case, phosphorylation amino acid marked * appearing amino acid. consider unmodified peptides, can filter . * special character must escaped backslashes, backslashes must also escaped.","code":"\n# Remove non-phosphorylated peptides\n# (peptides that do not contain a *)\nmsnid <- apply_filter(msnid, \"grepl('\\\\\\\\*', peptide)\")\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 537749 at 57 % FDR\n## #peptides: 353634 at 76 % FDR\n## #accessions: 118817 at 98 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"correct-isotope-selection-error-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.3 Correct Isotope Selection Error","text":"","code":"\n# Correct for isotope selection error\nmsnid <- correct_peak_selection(msnid)"},{"path":"isobaric-quantification-pipelines.html","id":"remove-contaminants-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.4 Remove Contaminants","text":"","code":"\n# Remove contaminants\nmsnid <- apply_filter(msnid, \"!grepl('Contaminant', accession)\")\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 537572 at 57 % FDR\n## #peptides: 353489 at 76 % FDR\n## #accessions: 118797 at 98 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"filter-by-ascore","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.5 Filter by AScore","text":"Phospho datasets involve AScore jobs improving phosphosite localization. one AScore job per data package. fetched object data.frame links datasets, scans original PTM localization newly suggested locations. Importantly, contains AScore column signifies confidence PTM assignment. AScore > 17 considered confident.","code":"\n# Filter PTMs by AScore\nascore <- get_AScore_results(data_package_num)\nmsnid <- best_PTM_location_by_ascore(msnid, ascore)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 188791 at 30 % FDR\n## #peptides: 101873 at 53 % FDR\n## #accessions: 90677 at 93 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"msms-id-filter-peptide-level","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.6 MS/MS ID Filter: Peptide Level","text":"","code":"\n# 1% FDR filter at the peptide level\nmsnid <- filter_msgf_data(msnid,\n                          level = \"peptide\",\n                          fdr.max = 0.01)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 76103 at 0.49 % FDR\n## #peptides: 23378 at 1 % FDR\n## #accessions: 16090 at 4.7 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"msms-id-filter-protein-level-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.7 MS/MS ID Filter: Protein Level","text":"","code":"\n# Get path to FASTA file\npath_to_FASTA <- path_to_FASTA_used_by_DMS(data_package_num)\n\n# Compute number of peptides per 1000 amino acids\nmsnid <- compute_num_peptides_per_1000aa(msnid, path_to_FASTA)\n\n# 1% FDR filter at the protein level\nmsnid <- filter_msgf_data(msnid,\n                          level = \"accession\",\n                          fdr.max = 0.01)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 72481 at 0.12 % FDR\n## #peptides: 21266 at 0.26 % FDR\n## #accessions: 9424 at 0.98 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"inference-of-parsimonious-protein-set-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.8 Inference of Parsimonious Protein Set","text":"Notice protein-level FDR increased acceptable threshold, need reapply filter.","code":"\n# Load proteins from global crosstab\nglobal_proteins <- readRDS(\"data/3442_global_protein_names.rds\")\n# Inference of parsimonious protein set\nmsnid <- infer_parsimonious_accessions(msnid, unique_only = FALSE,\n                                       prior = global_proteins)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 72481 at 0.12 % FDR\n## #peptides: 21266 at 0.26 % FDR\n## #accessions: 2895 at 1.6 % FDR\n# 1% FDR filter at the protein level\nmsnid <- filter_msgf_data(msnid,\n                          level = \"accession\",\n                          fdr.max = 0.01)\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 70340 at 0.075 % FDR\n## #peptides: 20117 at 0.15 % FDR\n## #accessions: 2351 at 0.99 % FDR\n# Remove Decoy Accessions\nmsnid <- apply_filter(msnid, \"!isDecoy\")\nshow(msnid)## MSnID object\n## Working directory: \".\"\n## #Spectrum Files:  23 \n## #PSMs: 70287 at 0 % FDR\n## #peptides: 20086 at 0 % FDR\n## #accessions: 2328 at 0 % FDR"},{"path":"isobaric-quantification-pipelines.html","id":"map-sites-to-protein-sequences","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.1.9 Map Sites to Protein Sequences","text":"Prepare FASTA make sure entry names FASTA file match MSnID accessions. plan make conversion automatic. map_mod_sites creates number columns describing mapping site/s onto protein sequences. important user SiteID.\nTable 1.7: First 6 rows processed MS-GF+ results.Table 1.7 shows first 6 rows processed MS-GF+ output.","code":"\n# Create AAStringSet\nfst <- readAAStringSet(path_to_FASTA)\n# Remove contaminants\nfst <- fst[!grepl(\"Contaminant\", names(fst)), ]\n# First 6 names\nhead(names(fst))## [1] \"NP_783171.2 cathepsin R precursor [Rattus norvegicus]\"                    \n## [2] \"NP_001101862.2 zinc finger protein ZIC 2 [Rattus norvegicus]\"             \n## [3] \"NP_113721.4 UDP-glucuronosyltransferase 2B2 precursor [Rattus norvegicus]\"\n## [4] \"NP_714948.1 Ly-49 stimulatory receptor 3 [Rattus norvegicus]\"             \n## [5] \"NP_001000704.1 olfactory receptor Olr931 [Rattus norvegicus]\"             \n## [6] \"NP_001000638.1 olfactory receptor Olr652 [Rattus norvegicus]\"\n# Modify names to match accessions(msnid)\nnames(fst) <- strsplit(names(fst), split = \" \") %>% \n  # Select text before first space\n  lapply(function(x) x[1]) %>% \n  unlist()\n# First 6 names\nhead(names(fst))## [1] \"NP_783171.2\"    \"NP_001101862.2\" \"NP_113721.4\"    \"NP_714948.1\"   \n## [5] \"NP_001000704.1\" \"NP_001000638.1\"\n# Main mapping call\nmsnid <- map_mod_sites(object = msnid, fasta = fst, \n                       accession_col = \"accession\", \n                       peptide_mod_col = \"peptide\", \n                       mod_char = \"*\",\n                       site_delimiter = \"lower\")"},{"path":"isobaric-quantification-pipelines.html","id":"phospho-reporter-ion-intensities","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.2 Prepare Reporter Ion Intensities","text":"","code":""},{"path":"isobaric-quantification-pipelines.html","id":"read-masic-output-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.2.1 Read MASIC Output","text":"","code":"\n# Read MASIC data\nmasic_data <- read_masic_data_from_DMS(data_package_num, \n                                       interference_score = TRUE)"},{"path":"isobaric-quantification-pipelines.html","id":"filter-masic-data-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.2.2 Filter MASIC Data","text":"","code":"\n# Filter MASIC data\nmasic_data <- filter_masic_data(masic_data, \n                                interference_score_threshold = 0.5,\n                                s2n_threshold = 0)"},{"path":"isobaric-quantification-pipelines.html","id":"create-study-design-tables","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.3 Create Study Design Tables","text":"","code":""},{"path":"isobaric-quantification-pipelines.html","id":"fractions-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.3.1 Fractions","text":"","code":"\n# Create fractions table\nfractions <- data.frame(Dataset = unique(masic_data$Dataset)) %>% \n  mutate(PlexID = gsub(\".*_P_(S\\\\d{1})_.*\", \"\\\\1\", Dataset))"},{"path":"isobaric-quantification-pipelines.html","id":"samples-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.3.2 Samples","text":"","code":"\n# TMT10 Reporter Converter table from MSnID package\nconv <- reporter_converter$tmt10\nplexes <- unique(fractions$PlexID)\n\n# Reference channel\nref_channel <- \"131\"\n\n# Create samples table\nsamples <- data.frame(PlexID = rep(plexes, each = nrow(conv)),  \n                      ReporterName = rep(conv$ReporterName, \n                                         length(plexes))) %>% \n  mutate(ReporterAlias = sprintf(\"%s_%s\", PlexID, ReporterName),\n         MeasurementName = ReporterAlias,\n         QuantBlock = 1,\n         # Comment out this next part if the reference\n         # is not one of the reporter ion channels.\n         MeasurementName = ifelse(ReporterName == ref_channel,\n                                  NA, MeasurementName)\n  )"},{"path":"isobaric-quantification-pipelines.html","id":"references-1","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.3.3 References","text":"","code":"\n# Create references table\nreferences <- samples %>% \n  # Filter to reference channel\n  filter(ReporterName == ref_channel) %>% \n  # Select required columns and rename ReporterAlias to Reference\n  select(PlexID, Reference = ReporterAlias, QuantBlock)"},{"path":"isobaric-quantification-pipelines.html","id":"phospho-create-crosstab","chapter":"Section 1 Isobaric Quantification Pipelines","heading":"1.2.4 Create Quantitative Cross-tab","text":"\nTable 1.8: First 6 rows phospho quantitative cross-tab.save cross-tab later sections.","code":"\n# Set aggregation level\naggregation_level <- c(\"SiteID\")\n# Create cross-tab\ncrosstab <- create_crosstab(msnid, masic_data,\n                            aggregation_level = aggregation_level,\n                            fractions, samples, references)\n# Modify cross-tab for saving\ncrosstab <- crosstab %>% \n  as.data.frame() %>% \n  tibble::rownames_to_column(\"SiteID\")\n\n# Save cross-tab\nwrite.table(crosstab, file = \"data/phospho_quant_crosstab.txt\",\n            sep = \"\\t\", quote = FALSE, row.names = FALSE)"},{"path":"exploratory-data-analysis.html","id":"exploratory-data-analysis","chapter":"Section 2 Exploratory Data Analysis","heading":"Section 2 Exploratory Data Analysis","text":"","code":"\nlibrary(MSnSet.utils)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(scales)\n\n# Set the theme for all plots. Base text size is set to 14 pts.\ntheme_set(theme_bw(base_size = 14))\n\n# Load the MSnSet\ndata(cptac_oca)"},{"path":"exploratory-data-analysis.html","id":"count-features-in-samples","chapter":"Section 2 Exploratory Data Analysis","heading":"2.1 Count Features in Samples","text":"count number features identified sample, use colSums tally number entries NA.Three methods visualizing information presented . begin lollipop plot.","code":"\n# Calculate the number of proteins \n# identified (not NA) in each sample\nplot_data <- pData(oca.set) %>% \n  mutate(num_proteins = colSums(!is.na(exprs(oca.set)))) %>% \n  # For the lollipop plot, it is best to sort num_peptides\n  # and preserve the ordering by converting the sample names\n  # to a factor. This is how we can specify the order of categorical\n  # variables in plots.\n  arrange(num_proteins) %>% \n  mutate(sample_name = rownames(.),\n         sample_name = factor(sample_name, levels = sample_name))\n\n# Could also be accomplished with\n# oca.set$num_proteins = colSums(!is.na(exprs(oca.set)))\n# but we need to change the ordering for the lollipop plot"},{"path":"exploratory-data-analysis.html","id":"lollipop-plot","chapter":"Section 2 Exploratory Data Analysis","heading":"2.1.1 Lollipop Plot","text":"Lollipop plots similar bar graphs, composed line segments terminating points. good alternative bar graphs better minimize amount non-data ink. doesn’t matter much figures made digital media, still reduces visual clutter comes bars; however, good alternative stacked bar graphs. ggplot, can construct lollipop plots combining geom_segment() geom_point() layer.case, using lollipop plot good use space. Notice plot lengthened sample names readable, number proteins detected ; lot space just taken lines. case, better use table another plot type like boxplot.","code":"\n# Lollipop plot\nggplot(plot_data) +\n  geom_segment(aes(x = 0, xend = num_proteins, \n                   y = sample_name, yend = sample_name)) +\n  geom_point(aes(x = num_proteins, y = sample_name)) +\n  scale_x_continuous(name = \"Number of Proteins Detected\", \n                     # Remove space between data and y axis \n                     # (start lines at x = 0)\n                     expand = expansion(mult = c(0, 0.05))) +\n  # Remove unnecessary y-axis title and the major y-axis grid lines\n  theme(axis.title.y = element_blank(),\n        panel.grid.major.y = element_blank())"},{"path":"exploratory-data-analysis.html","id":"boxplot","chapter":"Section 2 Exploratory Data Analysis","heading":"2.1.2 Boxplot","text":"boxplot good identifying labeling potential outliers, limited displaying summary data. using graphics::boxplot() example, rather ggplot2 equivalent, easier y-axis uncluttered.Notice boxplot takes lot less space, less informative can directly compare samples. Also, lose lot fine details shape distribution. address latter point, can instead use density plot.","code":"\n# Boxplot\nboxplot(plot_data$num_proteins, horizontal = TRUE,\n        xlab = \"Number of Proteins Detected\", col = NA)"},{"path":"exploratory-data-analysis.html","id":"density-plot","chapter":"Section 2 Exploratory Data Analysis","heading":"2.1.3 Density Plot","text":"density plot like smoothed histogram. fact, one benefits histogram don’t deal bins, choice number bins can drastically change overall shape histogram.outliers boxplot appear points beyond whiskers, outliers density plots appear small bumps tails distribution.\noutliers, case, can see two peaks number identified proteins concentrated. something captured boxplot, useful try different plot types.","code":"\nggplot(plot_data) +\n  geom_density(aes(x = num_proteins), \n               # Change fill color, make it translucent, remove outline\n               fill = \"lightblue\", alpha = 0.5, color = NA) +\n  scale_x_continuous(name = \"Number of Proteins Detected\", \n                     # Remove space between data and y axis\n                     expand = expansion(mult = 0),\n                     limits = c(NA, 7800),\n                     breaks = seq(6600, 7800, 200)) +\n  scale_y_continuous(name = \"Density\",\n                     # Remove space between data and x axis (start y axis at 0)\n                     expand = expansion(mult = c(0, 0.05)),\n                     # Use scientific notation for labels\n                     labels = label_scientific()) +\n  theme_bw(base_size = 14) +\n  # Adjust plot margin so that the 7800 label is not cut off\n  theme(plot.margin = unit(c(6, 16, 6, 6), units = \"pt\"))"},{"path":"exploratory-data-analysis.html","id":"estimate-blood-contamination","chapter":"Section 2 Exploratory Data Analysis","heading":"2.2 Estimate Blood Contamination","text":"","code":"\n# NOTE: eval set to FALSE\nblood_proteins <- \"HBA_HUMAN HBB_HUMAN HBD_HUMAN HBG1_HUMAN FIBA_HUMAN\nFIBB_HUMAN FIBG_HUMAN SPTB1_HUMAN THRB_HUMAN ALBU_HUMAN A1AG1_HUMAN\nA1AG2_HUMAN CAH1_HUMAN GLPA_HUMAN GLPB_HUMAN GLPC_HUMAN\"\n\nblood_proteins <- gsub(\"\\\\s|\\\\n\", \"\\\\|\", blood_proteins)\n\nm1$blood_contamination <-\n  apply(exprs(m1)[grepl(blood_proteins, featureNames(m1)), ],\n        2, mean, na.rm = TRUE)"},{"path":"exploratory-data-analysis.html","id":"pca","chapter":"Section 2 Exploratory Data Analysis","heading":"2.3 PCA","text":"","code":""},{"path":"exploratory-data-analysis.html","id":"overview","chapter":"Section 2 Exploratory Data Analysis","heading":"2.3.1 Overview","text":"overview PCA.","code":""},{"path":"exploratory-data-analysis.html","id":"pca-plots","chapter":"Section 2 Exploratory Data Analysis","heading":"2.3.2 PCA Plots","text":"\nFigure 2.1: figure caption\nreferencing Figure 2.1.","code":"\n# Default plot\nplot_pca_v3(oca.set, phenotype = \"SUBTYPE\")\n# New legend title\nlegend.title <- \"Subtype\"\n\nplot_pca_v3(oca.set, phenotype = \"SUBTYPE\") +\n  # Change the titles of the point color and ellipse fill legends\n  guides(color = guide_legend(title = legend.title),\n         # Do not include this line if show.ellipse = FALSE\n         fill = guide_legend(title = legend.title)) +\n  # Change base text size. theme_set() does not work here\n  theme_bw(base_size = 14)"},{"path":"exploratory-data-analysis.html","id":"list-top-contributing-features","chapter":"Section 2 Exploratory Data Analysis","heading":"2.3.3 List Top-Contributing Features","text":"MSnSet.utils, function allows us determine features contribute principal component. main part code .","code":"\n# V is the matrix of eigenvectors that have been scaled to unit vectors.\ncutoff <- sqrt(1 / nrow(V))\n\nres <- apply(V, 2, function(w) {\n    # Subset to values at least equal to the cutoff in magnitude\n    x <- w[which(abs(w) >= cutoff)]\n    # Order this subset by magnitude\n    x[order(abs(x), decreasing = TRUE)]\n  })"},{"path":"DEA.html","id":"DEA","chapter":"Section 3 Differential Expression Analysis","heading":"Section 3 Differential Expression Analysis","text":"overview goes .chapter, need following packages.","code":"\nlibrary(MSnSet.utils)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(scales)\n\n# Load the MSnSet\ndata(\"longitudinal_biomarker_study\")"},{"path":"DEA.html","id":"dea-with-limma","chapter":"Section 3 Differential Expression Analysis","heading":"3.1 DEA with limma","text":"section covers differential expression analysis limma package. basic workflow DEA limma fit linear model feature, , empirical Bayesian methods used moderate test statisticsThe limma user’s guide invaluable resource.","code":""},{"path":"DEA.html","id":"dichotomous-predictors","chapter":"Section 3 Differential Expression Analysis","heading":"3.1.1 Dichotomous Predictors","text":"","code":"\nres1 <- limma_a_b(longitudinal_biomarker_study, \n                  model.str = \"~ Type\",\n                  coef.str = \"Type\")"},{"path":"DEA.html","id":"continuous-predictors","chapter":"Section 3 Differential Expression Analysis","heading":"3.1.2 Continuous Predictors","text":"","code":""},{"path":"DEA.html","id":"reference-level-comparisons","chapter":"Section 3 Differential Expression Analysis","heading":"3.1.3 Reference Level Comparisons","text":"","code":""},{"path":"DEA.html","id":"custom-contrasts","chapter":"Section 3 Differential Expression Analysis","heading":"3.1.4 Custom Contrasts","text":"","code":""},{"path":"DEA.html","id":"p-value-histograms","chapter":"Section 3 Differential Expression Analysis","heading":"3.2 p-value Histograms","text":"histogram fairly uniform, means features likely significant adjustment.adjustment, 2 proteins significantly-different case control groups.","code":"\nhist(res1$P.Value, \n     breaks = seq(0, 1, 0.05), \n     main = \"Histogram of Case vs Control p-values\", \n     xlab = \"p-value\")\nhist(res1$adj.P.Val, \n     breaks = seq(0, 1, 0.05), \n     main = \"Histogram of Case vs Control Adjusted p-values\", \n     xlab = \"BH-adjusted p-value\")"},{"path":"DEA.html","id":"volcano-plots","chapter":"Section 3 Differential Expression Analysis","heading":"3.3 Volcano Plots","text":"","code":"\n# Base volcano plot\nplot_volcano(logFC = res1$logFC, significance = res1$P.Value)\nplot_data <- res1 %>%\n        rownames_to_column(\"feature\") %>%\n        mutate(point_color = case_when(\n                logFC >= 0 & P.Value < 0.05 ~ \"Up\",\n                logFC < 0 & P.Value < 0.05 ~ \"Down\"))\n\nfeatures_to_label <- plot_data %>% \n        # Select top 3 most significant proteins in each group\n        filter(point_color != \"NS\") %>%\n        group_by(point_color) %>%\n        slice_min(order_by = P.Value, n = 3) %>% \n        mutate(feature_label = feature)\n\nplot_data <- left_join(plot_data, features_to_label)\n# Add significance cutoff line, color points based on significance\n# and logFC, label the 3 most significant points for both positive \n# and negative logFC.\nplot_volcano(logFC = plot_data$logFC, significance = plot_data$P.Value, \n             sig_threshold = 0.05, threshold_line_color = \"black\",\n             point_color = plot_data$point_color, \n             feature_labels = plot_data$feature_label, \n             plot_theme = theme_bw(base_size = 14)) +\n        # Modify point colors\n        scale_color_manual(values = c(\"red3\", \"#5555ff\"),\n                           breaks = c(\"Up\", \"Down\"), \n                           na.value = \"grey70\") +\n        # Remove legend\n        theme(legend.position = \"none\") +\n        # Modify plot labels\n        labs(x = expression(paste(\"log\"[2],\"(fold-change)\")), \n             y = \"Unadjusted p-value\")"},{"path":"pathway-analysis.html","id":"pathway-analysis","chapter":"Section 4 Pathway Analysis","heading":"Section 4 Pathway Analysis","text":"Section 3, covered analysis individual feature level (protein, peptide, phosphoprotein, etc.). DEA useful, without set shortcomings. instance, may features pass significance threshold correcting multiple hypothesis testing. Alternatively, may many features statistically significant, interpreting list can tedious “prone investigator bias toward hypothesis interest” (Maleki et al., 2020). Another issue single-feature analysis fails detect subtle, yet coordinated changes groups related features (Subramanian et al., 2005).order address , , issues, pathway analysis instead examines priori defined gene sets—groups genes participate biological pathway, share cellular location, etc. section, explore common annotation databases, well two pathway analysis methods: -Representation Analysis (ORA) Gene Set Enrichment Analysis (GSEA).","code":""},{"path":"pathway-analysis.html","id":"annotation-databases","chapter":"Section 4 Pathway Analysis","heading":"4.1 Annotation Databases","text":"section, explore common annotation databases used pathway analysis.","code":""},{"path":"pathway-analysis.html","id":"gene-ontology","chapter":"Section 4 Pathway Analysis","heading":"4.1.1 Gene Ontology","text":"Gene Ontology (GO) database divided three separate domains: Biological Process, Cellular Component, Molecular Function (see Gene Ontology overview details regarding domain). domain structured directed acyclic graph (DAG) nodes terms edges relations terms (part , , part, regulates). Nodes can connected multiple child parent nodes, group genes annotated child node subset annotated parent node(s) (2021; Goeman et al., 2008).","code":""},{"path":"pathway-analysis.html","id":"semantic-similarity","chapter":"Section 4 Pathway Analysis","heading":"4.1.1.1 Semantic Similarity","text":"Due DAG structure domain, often redundancy pathway analysis results. example, suppose terms GO:0006119, GO:0009060, GO:0046034 significantly -represented biological processes. GO:0009060 GO:0046034 parent terms GO:0006119. Due relationship, terms likely provide much information, inclusion three terms output unnecessary. order resolve redundancy, can calculate semantic similarity pairs GO terms, “assesses likeness meaning two concepts” (Pesquita, 2017). Basically, two terms highly related, can use criteria (adjusted p-value level DAG) retain one terms. , use GOSemSim package calculate semantic similarity terms.\nTable 4.1: Semantic Similarity select GO terms\nmeasure \"Lin\", \"Jiang\", \"Wang\", semantic similarity term 1. true methods.can see Table 4.1 GO:0009060 GO:0046034 low semantic similarity, GO:0006119 highly similar parent terms. makes sense parent terms related/connected DAG.Now semantic similarities, can remove redundant terms. clusterProfiler function called simplify calculate semantic similarity remove terms. default, two terms semantic similarity greater 0.7, simplify retains term lowest adjusted p-value. See post Guangchuang Yu details clusterProfiler::simplify.","code":"\n## Calculate semantic similarity between GO terms\nlibrary(GOSemSim)\nlibrary(org.Hs.eg.db)\n\n# GO DATA for measuring semantic similarity.\n# keytype is \"ENTREZID\" by default and \n# information content is calculated (computeIC = TRUE)\nsemData <- godata(OrgDb = \"org.Hs.eg.db\", ont = \"BP\")\nterms <- c(\"GO:0006119\", \"GO:0009060\", \"GO:0046034\")\n# measure = \"Rel\" is the default for clusterProfiler::simplify\n# See code for clusterProfiler:::simplify_internal\nsim <- mgoSim(GO1 = terms, GO2 = terms, semData = semData, \n              measure = \"Rel\", combine = NULL) "},{"path":"pathway-analysis.html","id":"go-subsetsslims","chapter":"Section 4 Pathway Analysis","heading":"4.1.1.2 GO Subsets/Slims","text":"Another way handle redundancy GO terms use GO slim, subset general research-relevant terms GO. GO slims can downloaded biomaRt package can used access GO slim accessions.Unfortunately, every GO accession maps domain use biomaRt (unsure case), won’t able separate terms. However, two ways can still use GO slim accessions. Either follow steps using clusterProfiler::enricher (shown Pfam subsection Section 4.2.2) conversion tables created org.Hs.eg.db subset GO slim accessions, remove non GO slim accessions final results readjust remaining p-values (easier approach).","code":"\n## Create human GO slim\nlibrary(biomaRt)\nlibrary(clusterProfiler) # gcSample data\nlibrary(dplyr)\n\nmart <- useMart(biomart = \"ENSEMBL_MART_ENSEMBL\",\n                dataset = \"hsapiens_gene_ensembl\")\n# Uncomment to determine which attributes to select in getBM()\n# View(listAttributes(mart)) \n\n# The GO slim columns are goslim_goa_accession and goslim_goa_description.\n# We will map from the Entrez IDs in gcSample to these attributes.\ndata(gcSample)\nuniverse <- unique(unlist(gcSample))\nGO_slim <- getBM(filters = \"entrezgene_id\",\n                 attributes = c(\"entrezgene_id\",\n                                \"goslim_goa_accession\",\n                                \"goslim_goa_description\"),\n                 values = universe, # Subset to these Entrez IDs\n                 mart = mart) %>% \n  # Convert entrezgene_id from integer to character\n  mutate_all(as.character)"},{"path":"pathway-analysis.html","id":"reactome","chapter":"Section 4 Pathway Analysis","heading":"4.1.2 Reactome","text":"Home - Reactome Pathway Database","code":""},{"path":"pathway-analysis.html","id":"kegg","chapter":"Section 4 Pathway Analysis","heading":"4.1.3 KEGG","text":"KEGG: Kyoto Encyclopedia Genes Genomes","code":""},{"path":"pathway-analysis.html","id":"pfam","chapter":"Section 4 Pathway Analysis","heading":"4.1.4 Pfam","text":"Pfam: Home page\nPfam Documentation\nprofile Hidden Markov Models","code":""},{"path":"pathway-analysis.html","id":"ora","chapter":"Section 4 Pathway Analysis","heading":"4.2 Over-Representation Analysis","text":"","code":""},{"path":"pathway-analysis.html","id":"ora-overview","chapter":"Section 4 Pathway Analysis","heading":"4.2.1 Overview","text":"-Representation Analysis (ORA) used determine priori defined gene sets present (-represented) subset “interesting” genes expected chance (Huang et al., 2009). Essentially, identifies gene sets—rather individual genes—significantly different two conditions.gene set, enrichment p-value calculated using Binomial distribution, Hypergeometric distribution, Fisher exact test, Chi-square test. Although list -encompassing, popular statistical methods (Huang et al., 2009). formula calculating enrichment p-value particular gene set using Hypergeometric distribution.\\[\nP(X\\geq x) = 1 - P(X \\leq x-1) = 1 - \\sum\\limits_{=0}^{x-1}\\frac{\\hphantom{}{M \\choose }{N - M \\choose n-}}{N \\choose n}\n\\]equation, \\(N\\) number background genes, \\(n\\) number “interesting” (.e. statistically-significant) genes, \\(M\\) number genes annotated particular gene set \\(S\\), \\(x\\) number “interesting” genes annotated \\(S\\). numerator sum number samples \\(n\\) genes can taken population \\(N\\) genes exactly \\(\\) genes annotated \\(S\\) \\(n-\\) annotated \\(S\\). denominator sum total number samples size \\(n\\) can taken population size \\(N\\).example, suppose list 8000 genes, 400 differentially expressed. Also suppose 100 8000 genes annotated particular gene set \\(S\\). 100 genes, 20 differentially expressed. probability 20 (100) genes annotated \\(S\\) differentially expressed chance given \\[\nP(X\\geq 20) = 1 - P(X \\leq 19) = 1-\\sum \\limits_{=0}^{19}\\frac{\\hphantom{}{100 \\choose }{8000 - 100 \\choose 400-}}{8000 \\choose 400} = 7.88 \\times 10^{-8}\n\\], extremely unlikely 20 100 genes set significantly differentially expressed chance (least, prior adjustment multiple comparisons). code calculate p-value isAfter p-value calculated applicable gene sets, multiple comparison adjustment performed.","code":"\nphyper(q = 20 - 1, m = 400, n = 8000 - 400, k = 100, lower.tail = FALSE)"},{"path":"pathway-analysis.html","id":"ora-examples","chapter":"Section 4 Pathway Analysis","heading":"4.2.2 Examples","text":"examples, show perform ORA GOstats, clusterProfiler, ReactomePA packages. databases cover Gene Ontology, Reactome, Pfam. details different annotation databases, please see Section 4.1.Normally, use DEA table create two character vectors: one significantly expressed genes genes tested (referred “background” “universe”); instead, use gcSample data comes clusterProfiler treat eighth cluster vector significant genes entire list gene universe. gene represented human Entrez gene ID, default keytype used clusterProfiler functions keytype compatible ReactomePA::enrichPathway.important note genes unique start. terms two clusters gcSample may overlap, must use unique sake examples. DEA results gene-centric, use ORA. Instead, switch GSEA summarize ranking metric way make gene-centric (.e. take average, min, max, etc. metrics gene group).","code":"\n## Setup\n# Required packages\nlibrary(clusterProfiler) # GO, KEGG, and custom ORA\nlibrary(ReactomePA) # Reactome ORA\nlibrary(GOstats) # GO, KEGG, and Pfam ORA\nlibrary(PFAM.db) # Map Pfam IDs to descriptions\nlibrary(org.Hs.eg.db) # Human annotation database\nlibrary(kableExtra)\nlibrary(dplyr)\ndata(\"gcSample\") # Data for examples\nsig_genes <- gcSample[[8]] # significant genes\nuniverse <- unique(unlist(gcSample)) # universe"},{"path":"pathway-analysis.html","id":"gene-ontology-1","chapter":"Section 4 Pathway Analysis","heading":"4.2.2.1 Gene Ontology","text":"first use clusterProfiler package test biological processes -represented set interesting genes. example, consider gene sets size 20 500. order test either molecular functions, cellular components, three ontologies , set ont \"MF\", \"CC\", \"\", respectively.\nTable 4.2: Top significantly -represented biological processes enrichGO output.\n4436 biological processes tested. , 2049 passed size filter, 182 significantly -represented multiple testing correction. top 10 shown Table 4.2.Remove Redundant GO TermsBy default, two terms semantic similarity 0.7, clusterProfiler::simplify retains significantly -represented term.\nTable 4.3: Simplified top significantly -represented biological processes enrichGO output.\nNotice GO:0009060 present Table 4.3 anymore, since highly similar GO:0006119, latter significant. removing redundant GO terms, 96 pass significance threshold.Instead retaining terms based adjusted p-value, ignore significance instead retain either parent child terms (select_fun = min select_fun = max, respectively). code provided .Another alternative use gene ID GO slim ID conversion table. See Semantic Similarity subsection Section 4.1 details.Now, perform GO ORA GOstats package. begin creating object class GOHyperGParams passing hyperGTest calculation Hypergeometric p-values. filter p-value, since adjusted p-values provided must calculate .Now, need filter gene set size (limit 20 500), adjust p-values, filter based adjusted p-values.\nTable 4.4: -represented biological processes obtained using GOstats package.\n4435 biological processes tested. , 2049 passed size filter, 182 significantly -represented multiple testing correction. top 10 shown Table 4.4. total number biological processes tested 1 less number reported enrichGO results. enrichGO includes “biological_process” root GO:0008150.Remove Redundant GO TermsWhile function akin clusterProfiler::simplify process results, argument called conditional. Setting conditional TRUE tells hyperGTest use term-term relationships calculating p-values (Falcon et al., 2021). approach actually akin Modular Enrichment Analysis (MEA) -Representation Analysis (also called Singular Enrichment Analysis; Huang et al. (2009)).process results compare.\nTable 4.5: Simplified -represented biological processes obtained using GOstats package.\nNow, 2953 terms showed summary. , 1445 passed size filter, 31 significantly -represented multiple testing correction. top 10 shown Table 4.5. major difference results ones enrichGO using simplify p-value adjustment affected simplify, redundant GO terms removed . conditional method actually akin performing modular enrichment analysis (MEA) ORA (also called singular enrichment analysis)","code":"\n## GO BP ORA with clusterProfiler\n# This takes a while\ncp_ora_go <- enrichGO(\n  gene = sig_genes, \n  OrgDb = \"org.Hs.eg.db\", \n  keyType = \"ENTREZID\", \n  ont = \"BP\", # BP, CC, MF, or ALL for all ontologies\n  pvalueCutoff = 0.05,\n  qvalueCutoff = 1, # Do not filter by q-value\n  pAdjustMethod = \"BH\", \n  universe = universe, \n  minGSSize = 20, \n  maxGSSize = 500, \n  readable = TRUE # Convert Entrez ID to gene symbol\n)\n# Remove redundant GO terms with simplify\ncp_ora_go_sim <- simplify(cp_ora_go)\n## GO BP ORA with GOstats\nhyperg_ora_go <- new(\n  Class = \"GOHyperGParams\",\n  ontology = \"BP\",\n  geneIds = sig_genes,\n  universeGeneIds = universe,\n  annotation = \"org.Hs.eg.db\",\n  pvalueCutoff = 1, # Do not filter by p-value\n  testDirection = \"over\",\n  conditional = FALSE\n) %>%\n  hyperGTest() # Hypergeometric testing\nres_go_ora <- summary(hyperg_ora_go) %>%\n  # Filter by size\n  filter(Size >= 20, Size <= 500) %>%\n  # Adjust p-values\n  mutate(p.adjust = p.adjust(Pvalue, method = \"BH\")) %>%\n  # Filter and sort by adjusted p-values\n  arrange(p.adjust) %>% \n  filter(p.adjust < 0.05)\n## Conditional GO BP ORA with GOstats\nhyperg_ora_go_sim <- new(\n  Class = \"GOHyperGParams\",\n  ontology = \"BP\",\n  geneIds = sig_genes,\n  universeGeneIds = universe,\n  annotation = \"org.Hs.eg.db\",\n  pvalueCutoff = 1, # Do not filter by p-value\n  testDirection = \"over\",\n  conditional = TRUE # Use structure of GO graph\n) %>%\n  hyperGTest() # Hypergeometric testing"},{"path":"pathway-analysis.html","id":"reactome-1","chapter":"Section 4 Pathway Analysis","heading":"4.2.2.2 Reactome","text":"GOstats dedicated class test Reactome pathway -representation, can use ReactomePA. example, consider pathways size 20 500. enrichPathway accepts Entrez gene IDs input. cases Entrez ID readily available, must convert . Alternatively, use custom ORA function enricher, allows us use ID type (use demonstrated Pfam example).\nTable 4.6: Top significantly -represented Reactome pathways enrichPathway output.\n919 Reactome pathways tested. , 388 passed size filter, 155 significantly -represented multiple testing correction. top 10 shown Table 4.6.","code":"\n## Reactome ORA with ReactomePA\ncp_ora_reactome <- enrichPathway(\n  gene = sig_genes, \n  organism = \"human\", \n  pvalueCutoff = 0.05, \n  pAdjustMethod = \"BH\", \n  qvalueCutoff = 1, # Do not filter by q-value\n  universe = universe, \n  minGSSize = 20, \n  maxGSSize = 500,\n  readable = TRUE # Convert Entrez ID to gene symbol\n)"},{"path":"pathway-analysis.html","id":"pfam-1","chapter":"Section 4 Pathway Analysis","heading":"4.2.2.3 Pfam","text":"dedicated ORA function Pfam entries clusterProfiler, general ORA function called enricher can used term gene conversion table. function also much faster dedicated enrichGO enrichPathway functions, may preferred running many separate -representation analyses. conversion table generated biomaRt package follows.addition term gene conversion table, can supply term name table maps Pfam IDs human-readable descriptions. org.Hs.eg.db provide Pfam descriptions, PFAM.db annotation data package Bimap information. Now two conversion tables, perform ORA limit output Pfam entries size 15 500.\nTable 4.7: Top Pfam entries enricher output.\n275 Pfam entries tested. , 24 passed size filter, 0 significantly -represented multiple testing correction. none significant, top 10 shown Table 4.7 can compare results hyperGTest.Now, perform Pfam ORA GOstats package. begin constructing new object class PFAMHyperGParams passing hyperGTest calculation Hypergeometric p-values. filter p-value, since adjusted p-values provided must calculate .Now, need filter gene set size (limit 15 500) adjust p-values. Normally, also filter based adjusted p-values, skip step can compare output clusterProfiler::enricher.last step add human-readable Pfam descriptions. use TERM2NAME data frame just change column names easy joining.\nTable 4.8: Top Pfam entries obtained using GOstats package.\n260 Pfam entries tested. , 16 passed size filter, none significantly -represented multiple testing correction. top 10 shown Table 4.8.Notice table Table 4.7 different. one, sizes entries always . example, PF01391 size 31 according mapping file created biomaRt package, size 30 according org.Hs.eg.db. leads differences number total Pfam entries remain filtering size , subsequently, differences adjusted p-values.","code":"\n# NOT RUN ---\nlibrary(biomaRt)\n\nmart <- useMart(biomart = \"ENSEMBL_MART_ENSEMBL\",\n                dataset = \"hsapiens_gene_ensembl\")\nView(listAttributes(mart)) # Determine which columns to return\n\nconv_tbl <- getBM(filters = \"entrezgene_id\",\n                  attributes = c(\"entrezgene_id\",\n                                 \"pfam\"),\n                  values = universe,\n                  mart = mart) %>%\n  mutate_all(as.character)\nsaveRDS(conv_tbl, file = \"data/pfam_conv_tbl.rds\")\n# Entrez to Pfam ID mapping file created with biomaRt package\nTERM2GENE <- readRDS(\"data/pfam_conv_tbl.rds\") %>% \n  # Remove blank terms\n  filter(pfam != \"\") %>% \n  # Reorder and rename columns. \n  # ! These specific column names must be used in this exact order\n  dplyr::select(term = pfam, gene = entrezgene_id)\n\n# Pfam IDs to descriptions\nlibrary(PFAM.db)\nTERM2NAME <- as.data.frame.Bimap(PFAMDE)\n# ! These specific column names must be used in this exact order\ncolnames(TERM2NAME) <- c(\"term\", \"name\")\n\n## Pfam ORA with clusterProfiler\ncp_ora_pfam <- enricher(\n  gene = sig_genes,\n  pvalueCutoff = 0.05,\n  pAdjustMethod = \"BH\",\n  universe = universe,\n  minGSSize = 15,\n  maxGSSize = 500,\n  qvalueCutoff = 1,\n  TERM2GENE = TERM2GENE,\n  TERM2NAME = TERM2NAME\n)\n## Pfam ORA with GOstats\nhyperg_pfam_ora <- new(\n  Class = \"PFAMHyperGParams\",\n  geneIds = sig_genes,\n  universeGeneIds = universe,\n  annotation = \"org.Hs.eg.db\",\n  pvalueCutoff = 1,\n  testDirection = \"over\"\n) %>%\n  hyperGTest() # Hypergeometric testing\nres_pfam_ora <- summary(hyperg_pfam_ora) %>%\n  # Filter by Pfam entry size\n  filter(Size >= 15, Size <= 500) %>%\n  # Adjust p-values\n  mutate(p.adjust = p.adjust(Pvalue, method = \"BH\")) %>%\n  # Sort by adjusted p-values\n  arrange(p.adjust)\n# Pfam entries to descriptions\ncolnames(TERM2NAME) <- c(\"PFAMID\", \"Description\")\nres_pfam_ora <- left_join(res_pfam_ora, TERM2NAME)"},{"path":"pathway-analysis.html","id":"considerations","chapter":"Section 4 Pathway Analysis","heading":"4.2.3 Considerations","text":"choice threshold statistical significance multiple comparison adjustment method can greatly impact analysis (Huang et al., 2009).ORA fails incorporate direction gene regulation. (genes given set mainly -regulated?). good idea split DEA results sign logFC apply ORA two sets. Use GSEA instead.\ngenes differentially expressed, ORA unlikely yield useful reliable results. example, suppose 30 8000 genes significant. 100 genes annotated particular gene set, 3 significant. associated Hypergeometric p-value 0.006, set considered significantly -represented 0.01 level (least, prior adjustment multiple comparisons); however, 2 genes set significant, p-value increases 10-fold 0.0536 longer significant even 0.05 level.DEA results gene-centric (.e. DEA performed protein phosphosite level), may cases two proteins associated gene, one significantly differentially abundant. case, way categorize gene significant , ORA used. problem arise DEA results gene-centric gene may counted significant multiple times, leads artificial -representation.","code":""},{"path":"pathway-analysis.html","id":"gsea","chapter":"Section 4 Pathway Analysis","heading":"4.3 Gene Set Enrichment Analysis","text":"","code":""},{"path":"pathway-analysis.html","id":"gsea-overview","chapter":"Section 4 Pathway Analysis","heading":"4.3.1 Overview","text":"Gene Set Enrichment Analysis (GSEA) employs “-cutoff” strategy utilizes experimental value (fold change, moderated t-statistic, Z-Score) rank list \\(N\\) genes descending order. Using ranked list \\(L\\), values ranking metric, priori defined gene set \\(S\\), can calculate enrichment score. done “walking list \\(L\\), increasing running-sum statistic encounter gene \\(S\\) decreasing encounter genes \\(S\\).” maximum deviation zero running-sum statistic enrichment score \\(S\\), denoted \\(ES(S)\\). genes \\(S\\) randomly distributed throughout \\(L\\), \\(ES(S)\\) relatively small; however, randomly distributed (.e. primarily located near either end \\(L\\)), \\(ES(S)\\) relatively large (Mootha et al., 2003; Subramanian et al., 2005).assess statistical significance \\(ES(S)\\), permute phenotype labels expression data recalculate ranking metric subsequent enrichment score \\(ES_{\\text{NULL}}\\). Alternatively, permute genes: given \\(S\\) size \\(k\\), randomly select \\(k\\) genes list \\(L\\) calculate enrichment score \\(ES_{\\text{NULL}}\\). method implemented fgsea , consequently, clusterProfiler, though “strictly accurate” preserve correlations genes (Subramanian et al., 2005). Regardless permutation approach, repeated one thousand tens thousands times produce empirical null distribution. , define nominal p-value proportion \\(ES_{\\text{NULL}}\\) extreme \\(ES(S)\\). p-value obtained every gene set, apply appropriate adjustment multiple hypothesis testing. phenotype randomization approach summarized Figure 1: Schematic overview GSEA paper Mootha et al. (2003). mathematical details GSEA provided .Let \\(x = \\{x_1, ..., x_N : x_i > x_j \\ \\forall < j\\}\\) vector ranking metric values. Also let \\(S\\) particular gene set size \\(k\\) \\(NS = \\sum\\limits_{\\S}|x_i|\\). define value running sum gene \\(\\) \\[\nr_i = \\begin{cases}\n0 & \\text{} = 0, \\\\\nr_{-1} + \\frac{1}{NS}|x_i| & \\text{} 1 \\leq \\leq N \\text{ } \\S, \\\\\nr_{-1} - \\frac{1}{N-k} & \\text{} 1 \\leq \\leq N \\text{ } \\\\S\n\\end{cases}\n\\]\\(ES(S)\\) largest (terms absolute value) element \\(r_N\\). notation slightly modified version presented paper Korotkevich et al. (2016).","code":""},{"path":"pathway-analysis.html","id":"examples","chapter":"Section 4 Pathway Analysis","heading":"4.3.2 Examples","text":"","code":""},{"path":"pathway-analysis.html","id":"gene-ontology-2","chapter":"Section 4 Pathway Analysis","heading":"4.3.2.1 Gene Ontology","text":"","code":""},{"path":"pathway-analysis.html","id":"reactome-2","chapter":"Section 4 Pathway Analysis","heading":"4.3.2.2 Reactome","text":"","code":""},{"path":"pathway-analysis.html","id":"pfam-2","chapter":"Section 4 Pathway Analysis","heading":"4.3.2.3 Pfam","text":"","code":""},{"path":"pathway-analysis.html","id":"considerations-1","chapter":"Section 4 Pathway Analysis","heading":"4.3.3 Considerations","text":"GSEA influenced arbitrary cutoff statistical significance. especially useful features pass threshold adjustment multiple testing, also means depend choice p-value adjustment.genes experiment allowed “contribute enrichment analysis differing degrees” (Huang et al., 2009). addresses point brought beginning Section 4 biological changes may result small changes many related genes. GSEA allows detection changes.sign enrichment score tell us category set genes primarily - -regulated. example, suppose test difference means two groups gene using limma package. Since ranking metrics incorporate direction change, positive enrichment score mean majority genes particular set -regulated relative B/-regulated B relative .choice ranking metric important.\n","code":""},{"path":"references-2.html","id":"references-2","chapter":"References","heading":"References","text":"","code":""}]
