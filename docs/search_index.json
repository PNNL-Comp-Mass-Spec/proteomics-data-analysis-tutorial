[["index.html", "Proteomics Data Analysis in R/Bioconductor Welcome!", " Proteomics Data Analysis in R/Bioconductor Tyler Sagendorf January 04, 2022 Welcome! This tutorial is very much a work-in progress. Even sections that appear finished are likely to be changed. I will update this when significant progress is made. Thank you for your patience. It is highly recommended to review the resources below before continuing with the rest of the tutorial. Proteomics Overview Protein Analysis by Shotgun/Bottom-up Proteomics Modern Proteomics  Sample Preparation, Analysis and Practical Applications Liquid Chromatography Mass Spectrometry-Based Proteomics: Biological and Technological Aspects Mass Spectrometry Warwick School of Life Sciences Teaching Animations Tandem Mass Spectrometry for Peptide and Protein Sequence Analysis Maestro: Comprehensive, Multi-Stage Spectrum Identification in Protein Mass Spectrometry Searching databases for protein identification - part 1 (YouTube video) Mass spectrometry for proteomics - part one (YouTube video) Electrospray Ionisation Mass Spectrometry: Principles and Clinical Applications PNNLs Data Management System (DMS) Integrative Omics PRISMWiki Universal Protein Resource (UniProt): protein sequence and annotation data False Discovery Rate (FDR) How to talk about proteinlevel false discovery rates in shotgun proteomics Posterior Error Probabilities and False Discovery Rates: Two Sides of the Same Coin False Discovery Rate: PEAKS FDR Estimation False discovery rates in spectral identification RStudio Cheatsheets Pattern matching with regular expressions R for Data Science: Strings RegexOne: Learn Regular Expressions with simple, interactive exercises. "],["isobaric-quantification-pipelines.html", "Section 1 Isobaric Quantification Pipelines", " Section 1 Isobaric Quantification Pipelines "],["global-proteomics-data.html", "1.1 Global Proteomics Data", " 1.1 Global Proteomics Data This pipeline shows how to process TMT data that is processed outside of PNNLs DMS. Section 1.2 shows how to process data from the DMS. For convenience, the results of MS-GF+ and MASIC processing are provided in a companion PlexedPiperTestData package. In addition, we will need PlexedPiper for isobaric quantification, dplyr to manipulate data frames, and MSnbase to create MSnSet objects. # Setup library(PlexedPiper) library(PlexedPiperTestData) library(dplyr) The pipeline can be broken up into 4 major chunks: prepare MS/MS identifications, prepare reporter ion intensities, create a quantitative cross-tab, and create an MSnSet object. 1.1.1 Read MS-GF+ Data The first step in the preparation of the MS/MS identifications is to fetch the data. In this case, the data exists in the PlexedPiperTestData package in a local folder, so we use system.file to get the file path and read_msgf_data to read the MS-GF+ output. # Get file path path_to_MSGF_results &lt;- system.file(&quot;extdata/global/msgf_output&quot;, package = &quot;PlexedPiperTestData&quot;) # Read MS-GF+ data from path msnid &lt;- read_msgf_data(path_to_MSGF_results) Normally, this would display a progress bar in the console as the data is being fetched. However, the output was suppressed to save space. We can view a summary of the MSnID object with the show() function. show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 1156754 at 31 % FDR ## #peptides: 511617 at 61 % FDR ## #accessions: 128378 at 98 % FDR This summary tells us that msnid consists of 4 spectrum files (datasets), and contains a total of 1,156,754 peptide-spectrum-matches (PSMs), 511,617 total peptides, and 128,378 total accessions (proteins). The reported FDR is the empirical false-discovery rate, which is calculated as the ratio of the number of false (decoy) PSMs, peptides, or accessions to their true (non-decoy) counterparts. Calculation of these counts and their FDRs is shown below. # How to calculate the counts and FDRs from the show() output ## Spectrum Files # Count psms(msnid) %&gt;% distinct(Dataset) %&gt;% nrow() # 48 ## PSMs # Count psms(msnid) %&gt;% distinct(Dataset, Scan, peptide, isDecoy) %&gt;% # Assign intermediate to variable assign(&quot;x_psm&quot;, ., envir = globalenv()) %&gt;% nrow() # 1156754 # FDR nrow(x_psm[x_psm$isDecoy == TRUE, ]) / nrow(x_psm[x_psm$isDecoy == FALSE, ]) # 0.3127463 = 31% ## peptides # Count psms(msnid) %&gt;% distinct(peptide, isDecoy) %&gt;% assign(&quot;x_peptide&quot;, ., envir = globalenv()) %&gt;% nrow() # 511617 # FDR nrow(x_peptide[x_peptide$isDecoy == TRUE, ]) / nrow(x_peptide[x_peptide$isDecoy == FALSE, ]) # 0.611245 = 61% ## accessions # Count length(accessions(msnid)) # or psms(msnid) %&gt;% distinct(accession, isDecoy) %&gt;% assign(&quot;x_acc&quot;, ., envir = globalenv()) %&gt;% nrow() # 128378 # FDR nrow(x_acc[x_acc$isDecoy == TRUE, ]) / nrow(x_acc[x_acc$isDecoy == FALSE, ]) # 0.9827024 = 98% Now that we have an MSnID object, we need to process it. We begin by correcting for the isotope selection error. 1.1.2 Correct Isotope Selection Error Carbon has two stable isotopes: \\(^{12}\\text{C}\\) and \\(^{13}\\text{C}\\), with natural abundances of 98.93% and 1.07%, respectively. That is, we expect that about 1 out of every 100 carbon atoms is naturally going to be a \\(^{13}\\text{C}\\), while the rest are \\(^{12}\\text{C}\\). In larger peptides with many carbon atoms, it is more likely that at least one atom will be a \\(^{13}\\text{C}\\) than all atoms will be \\(^{12}\\text{C}\\). In cases such as these, a non-monoisotopic ion will be selected by the instrument for fragmentation. (#fig:MS1_peak)MS1 spectra with peak at non-monoisotopic precursor ion. In Figure @ref(fig:MS1_peak), the monoisotopic ion (m/z of 1427.29) is not the most abundant, so it is not selected as the precursor. Instead, the ion with a \\(^{13}\\text{C}\\) in place of a \\(^{12}\\text{C}\\) is selected for fragmentation. We calculate the mass difference between these two ions as the difference between the mass-to-charge ratios multiplied by the ion charge. In this case, the mass difference is 1 Dalton, or about the difference between \\(^{13}\\text{C}\\) and \\(^{12}\\text{C}\\). (More accurately, the difference between these isotopes is 1.0033548378 Da.) While MS-GF+ is still capable of correctly identifying these peptides, the downstream calculations of mass measurement error need to be fixed because they are used for filtering later on (Section 1.1.4). The correct_peak_selection function corrects these mass measurement errors, and Figure 1.1 shows the distribution of the mass measurement errors before and after correction. # Correct for isotope selection error msnid &lt;- correct_peak_selection(msnid) Figure 1.1: Histogram of mass measurement errors before and after correction. 1.1.3 Remove Contaminants Now, we will remove contaminants such as the trypsin that was used for protein digestion. We can use grepl to search for all accessions that contain the string \"Contaminant\". Displaying these contaminants is not necessary during processing. This is just for demonstration purposes to see what will be removed. # All unique contaminants accessions(msnid)[grepl(&quot;Contaminant&quot;, accessions(msnid))] ## [1] &quot;Contaminant_K2C1_HUMAN&quot; &quot;Contaminant_K1C9_HUMAN&quot; ## [3] &quot;Contaminant_ALBU_HUMAN&quot; &quot;Contaminant_ALBU_BOVIN&quot; ## [5] &quot;Contaminant_TRYP_PIG&quot; &quot;Contaminant_K1C10_HUMAN&quot; ## [7] &quot;XXX_Contaminant_K1C9_HUMAN&quot; &quot;Contaminant_K22E_HUMAN&quot; ## [9] &quot;Contaminant_Trypa3&quot; &quot;Contaminant_Trypa5&quot; ## [11] &quot;XXX_Contaminant_K1C10_HUMAN&quot; &quot;XXX_Contaminant_K22E_HUMAN&quot; ## [13] &quot;XXX_Contaminant_K2C1_HUMAN&quot; &quot;Contaminant_TRYP_BOVIN&quot; ## [15] &quot;XXX_Contaminant_ALBU_HUMAN&quot; &quot;XXX_Contaminant_ALBU_BOVIN&quot; ## [17] &quot;XXX_Contaminant_TRYP_BOVIN&quot; &quot;Contaminant_CTRB_BOVIN&quot; ## [19] &quot;Contaminant_Trypa1&quot; &quot;Contaminant_Trypa6&quot; ## [21] &quot;Contaminant_CTRA_BOVIN&quot; &quot;XXX_Contaminant_TRYP_PIG&quot; ## [23] &quot;XXX_Contaminant_CTRB_BOVIN&quot; &quot;XXX_Contaminant_CTRA_BOVIN&quot; ## [25] &quot;Contaminant_Trypa2&quot; To remove contaminants, we use apply_filter with an appropriate character string that tells the function what rows to keep. In this case, we keep rows where the accession does not contain Contaminant. We will use show to see how the counts change. # Remove contaminants msnid &lt;- apply_filter(msnid, &quot;!grepl(&#39;Contaminant&#39;, accession)&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 1155442 at 31 % FDR ## #peptides: 511196 at 61 % FDR ## #accessions: 128353 at 98 % FDR We can see that the number of PSMs decreased by about 1300, peptides by ~400, and proteins by 25 (the 25 contaminants that were displayed). 1.1.4 MS/MS ID Filter: Peptide Level The next step is to filter the MS/MS identifications such that the empirical peptide-level FDR is less than some threshold and the number of MS/MS IDs is maximized. We will use the \\(-log_{10}\\) of the PepQValue column as one of our filtering criteria and assign it to a new column in psms(msnid) called msmsScore. The PepQValue column is the MS-GF+ Spectrum E-value, which reflects how well the theoretical and experimental fragmentation spectra match; therefore, high values of msmsScore indicate a good match (see Figure 1.2). Figure 1.2: Density plot of msmsScore. The other filtering criteria is the absolute deviation of the mass measurement error of the precursor ions in parts-per-million (ppm), which is assigned to the absParentMassErrorPPM column in psms(msnid) (see Figure 1.3). Figure 1.3: Density plot of absParentMassErrorPPM. Now, we will filter the PSMs. # 1% FDR filter at the peptide level msnid &lt;- filter_msgf_data(msnid, level = &quot;peptide&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 464474 at 0.45 % FDR ## #peptides: 96485 at 1 % FDR ## #accessions: 27119 at 9.2 % FDR We can see that filtering drastically reduces the number of PSMs, and the empirical peptide-level FDR is now 1%. However, notice that the empirical protein-level FDR is still fairly high. 1.1.5 MS/MS ID Filter: Protein Level Now, we need to filter proteins so that the FDR is at most 1%. A while ago, the proteomics field established the hard-and-fast two-peptides-per-protein rule. That is, the confident identification of a protein requires the confident identification of at least 2 peptides. This rule penalizes short proteins and doesnt consider that there are some very long proteins (e.g. Titin 3.8 MDa) that easily have more then two matching peptides even in the reversed sequence. Thus, we propose to normalize the number of peptides per protein length and use that as a filtering criterion (Figure 1.5). In order to get the protein lengths, we need the FASTA (pronounced FAST-AYE) file that contains the protein sequences used in the database search. The first three entries of the FASTA file are shown in Figure 1.4. Figure 1.4: First three entries of the FASTA file. For each protein, we divide the number of associated peptides by the length of that protein and multiply this value by 1000. This new peptides_per_1000aa column is used as the filter criteria. # Get path to FASTA file path_to_FASTA &lt;- system.file( &quot;extdata/Rattus_norvegicus_NCBI_RefSeq_2018-04-10.fasta.gz&quot;, package = &quot;PlexedPiperTestData&quot; ) # Compute number of peptides per 1000 amino acids msnid &lt;- compute_num_peptides_per_1000aa(msnid, path_to_FASTA) Figure 1.5: Density plot of peptides_per_1000aa. The plot area has been zoomed in. Now, we filter the proteins to 1% FDR. # 1% FDR filter at the protein level msnid &lt;- filter_msgf_data(msnid, level = &quot;accession&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 458090 at 0.16 % FDR ## #peptides: 92036 at 0.32 % FDR ## #accessions: 15630 at 1 % FDR 1.1.6 Inference of Parsimonious Protein Set The situation when a certain peptide sequence matches multiple proteins adds complication to the downstream quantitative analysis, as it is not clear which protein this peptide is originating from. There are common ways for dealing with this. One is to simply retain uniquely matching peptides and discard shared peptides (unique_only = TRUE). Alternatively, assign the shared peptides to the proteins with the larger number of uniquely mapping peptides (unique_only = FALSE). If there is a choice between multiple proteins with equal numbers of uniquely mapping peptides, the shared peptides are assigned to the first protein according to alphanumeric order (Figure 1.6). Figure 1.6: Visual explanation of the inference of the parsimonious protein set. # Inference of parsimonious protein set msnid &lt;- infer_parsimonious_accessions(msnid, unique_only = FALSE) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 444999 at 0.15 % FDR ## #peptides: 90478 at 0.27 % FDR ## #accessions: 5251 at 1.1 % FDR Notice that the protein-level FDR increased slightly above the 1% threshold. In this case, the difference isnt significant, so we can ignore it. Note: If the peptide or accession-level FDR increases significantly above 1% after inference of the parsimonious protein set, consider lowering the FDR cutoff (for example, to 0.9%) and redoing the previous processing steps. Filtering at the peptide and accession level should each be done a single time. 1.1.7 Remove Decoy PSMs The final step in preparing the MS/MS identifications is to remove the decoy PSMs. We use the apply_filter function again and only keep entries where isDecoy is FALSE. # Remove Decoy PSMs msnid &lt;- apply_filter(msnid, &quot;!isDecoy&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 444338 at 0 % FDR ## #peptides: 90232 at 0 % FDR ## #accessions: 5196 at 0 % FDR After processing, we are left with 444,345 PSMs, 90,232 peptides, and 5,196 proteins. Table 1.1 shows the first 6 rows of the processed MS-GF+ output. Table 1.1: First 6 rows of the processed MS-GF+ results. Dataset ResultID Scan FragMethod SpecIndex Charge PrecursorMZ DelM DelM_PPM MH peptide Protein NTT DeNovoScore MSGFScore MSGFDB_SpecEValue Rank_MSGFDB_SpecEValue EValue QValue PepQValue IsotopeError accession calculatedMassToCharge chargeState experimentalMassToCharge isDecoy spectrumFile spectrumID pepSeq msmsScore absParentMassErrorPPM peptides_per_1000aa MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 1862 27707 HCD 324 2 928.541 -0.001 -0.526 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 285 282 0 1 0 0.000 0.000 0 NP_113986.1 928.541 2 928.541 FALSE MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 27707 AAAAAAAAAAAAAAGAAGK Inf 0.589 25.769 MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 4192 27684 HCD 906 3 619.363 -0.002 -0.887 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 156 144 0 1 0 0.000 0.000 0 NP_113986.1 619.363 3 619.363 FALSE MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 27684 AAAAAAAAAAAAAAGAAGK Inf 0.991 25.769 MoTrPAC_Pilot_TMT_W_S2_06_12Oct17_Elm_AQ-17-09-02 26263 27336 HCD 5187 3 619.363 0.000 0.197 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 118 85 0 1 0 0.000 0.000 0 NP_113986.1 619.363 3 619.363 FALSE MoTrPAC_Pilot_TMT_W_S2_06_12Oct17_Elm_AQ-17-09-02 27336 AAAAAAAAAAAAAAGAAGK Inf 0.091 25.769 MoTrPAC_Pilot_TMT_W_S2_07_12Oct17_Elm_AQ-17-09-02 1471 27096 HCD 415 3 619.363 -0.001 -0.591 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 157 156 0 1 0 0.000 0.000 0 NP_113986.1 619.363 3 619.363 FALSE MoTrPAC_Pilot_TMT_W_S2_07_12Oct17_Elm_AQ-17-09-02 27096 AAAAAAAAAAAAAAGAAGK Inf 0.684 25.769 MoTrPAC_Pilot_TMT_W_S2_05_12Oct17_Elm_AQ-17-09-02 28664 10441 HCD 4849 2 586.832 -0.001 -0.728 1172.659 R.AAAAADLANR.S NP_001007804.1 2 124 124 0 1 0 0.002 0.003 0 NP_001007804.1 586.833 2 586.832 FALSE MoTrPAC_Pilot_TMT_W_S2_05_12Oct17_Elm_AQ-17-09-02 10441 AAAAADLANR 2.480 0.746 34.755 MoTrPAC_Pilot_TMT_W_S1_24_12Oct17_Elm_AQ-17-09-02 41775 8033 HCD 7889 2 831.447 0.000 0.000 1661.886 G.AAAAAEAESGGGGGK.K NP_001128630.1 1 176 76 0 1 0 0.001 0.003 0 NP_001128630.1 831.447 2 831.447 FALSE MoTrPAC_Pilot_TMT_W_S1_24_12Oct17_Elm_AQ-17-09-02 8033 AAAAAEAESGGGGGK 2.583 0.106 580.844 1.1.8 Read MASIC Output MASIC is a tool for extracting ion intensities. With proper parameter settings, it can be used for extracting TMT (or iTRAQ) reporter ion intensities. In addition, it reports a number of other helpful metrics. Notably, the interference score at the precursor ion level and the signal-to-noise ratio (S/N) at the reporter ion level (computed by Thermo software). The interference score reflects the proportion of the ion population that was isolated for fragmentation that is due to the targeted ion. In other words, 1 - InterferenceScore is due to co-isolated species that have similar elution time and precursor ion m/z. The first step in the preparation of the reporter ion intensity data is to read the MASIC results. We use a local file path and the read_masic_data function. By default, the interference score is not included, so we need to set that argument to TRUE in order to filter the results. # Path to MASIC data path_to_MASIC_results &lt;- system.file(&quot;extdata/global/masic_output&quot;, package = &quot;PlexedPiperTestData&quot;) # Read MASIC data masic_data &lt;- read_masic_data(path_to_MASIC_results, interference_score = TRUE) Normally, this would display progress bars in the console as the data is being fetched. However, the output was suppressed to save space. Table 1.2: First 6 rows of the MASIC data. Dataset ScanNumber Collision.Mode ParentIonMZ BasePeakIntensity BasePeakMZ ReporterIonIntensityMax Ion_126.128 Ion_127.125 Ion_127.131 Ion_128.128 Ion_128.134 Ion_129.131 Ion_129.138 Ion_130.135 Ion_130.141 Ion_131.138 Weighted.Avg.Pct.Intensity.Correction Ion_126.128_SignalToNoise Ion_127.125_SignalToNoise Ion_127.131_SignalToNoise Ion_128.128_SignalToNoise Ion_128.134_SignalToNoise Ion_129.131_SignalToNoise Ion_129.138_SignalToNoise Ion_130.135_SignalToNoise Ion_130.141_SignalToNoise Ion_131.138_SignalToNoise Ion_126.128_Resolution Ion_127.125_Resolution Ion_127.131_Resolution Ion_128.128_Resolution Ion_128.134_Resolution Ion_129.131_Resolution Ion_129.138_Resolution Ion_130.135_Resolution Ion_130.141_Resolution Ion_131.138_Resolution ParentIonIndex MZ SurveyScanNumber OptimalPeakApexScanNumber PeakApexOverrideParentIonIndex CustomSICPeak PeakScanStart PeakScanEnd PeakScanMaxIntensity PeakMaxIntensity PeakSignalToNoiseRatio FWHMInScans PeakArea ParentIonIntensity PeakBaselineNoiseLevel PeakBaselineNoiseStDev PeakBaselinePointsUsed StatMomentsArea CenterOfMassScan PeakStDev PeakSkew PeakKSStat StatMomentsDataCountUsed InterferenceScore MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 2 hcd 407.74 227695.44 407.741 92236.87 70562.39 24864.62 17165.80 35625.00 92236.87 9640.23 8578.05 6996.69 11833.07 32281.34 0 71.47 25.17 17.38 36.04 93.32 9.75 8.67 7.07 11.96 32.71 44102 42700 42100 41800 44404 40500 39500 36800 41100 42302 0 407.742 1 12 -1 0 1 19 12 2901600 211.000 5 50422000 2579600 13750 97562 10113 47031000 11 5.68 -0.189 0.353 10 0.996 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 3 hcd 396.72 59127.97 529.294 34294.90 23706.89 13559.32 5856.83 16322.71 34294.90 4853.11 7938.24 0.00 1465.03 18182.27 0 26.12 14.94 6.45 17.97 37.77 5.34 8.74 NA 1.61 19.93 42702 41100 37000 40400 43404 36400 39700 NA 29800 41802 1 396.718 1 12 -1 0 1 19 12 2181900 19.690 5 34508000 1690600 110841 1120000 10166 31578000 11 5.59 -0.217 0.347 10 0.993 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 4 hcd 438.23 110444.82 362.224 14053.40 12459.86 11785.91 10932.51 10653.32 12328.62 5959.86 9905.82 8387.04 11166.70 14053.40 0 12.40 11.75 10.90 10.64 12.31 5.96 9.91 8.40 11.18 14.13 42006 40702 41402 40700 40400 38800 40200 38900 40400 41002 2 438.227 1 131 18 0 1 114 107 8255600 9.465 44 444610000 658727 872195 2620000 10129 343470000 82 22.80 -0.626 1.099 89 1.000 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 5 hcd 481.50 37082.72 206.466 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 3 481.505 1 23 -1 0 1 52 23 401824 27.990 23 16244000 344491 14356 65777 10109 14899000 26 14.10 0.054 0.504 39 1.000 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 6 hcd 549.28 21077.05 128.129 21077.05 0.00 10998.67 0.00 21077.05 2725.50 0.00 0.00 0.00 0.00 6800.70 0 NA 9.19 NA 17.57 2.27 NA NA NA NA 5.66 NA 40302 NA 42102 46600 NA NA NA NA 40300 4 549.279 1 15 -1 0 1 16 15 363656 0.700 5 5941200 347071 519640 1990000 10109 2528900 15 2.49 -0.583 0.430 5 1.000 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 8 hcd 388.72 40605.85 356.719 8087.76 6166.82 1371.27 2418.35 8087.76 5485.35 0.00 0.00 1543.48 1943.96 7436.60 0 6.92 1.54 2.71 9.04 6.13 NA NA 1.72 2.16 8.26 40000 26400 30400 40400 44300 NA NA 28800 28500 38700 5 388.720 7 12 -1 0 1 30 12 478135 28.710 19 10718000 291189 16653 142562 10142 9961100 16 8.60 -0.051 0.283 18 0.969 Table 1.2 shows the first 6 rows of masic_data. 1.1.9 Filter MASIC Data The only other step in reporter ion intensity data preparation is to filter the results. Currently, we recommend keeping entries where at least 50% of the ion population is due to the targeted ion (interference score \\(\\geq\\) 0.5) and not filtering by S/N. # Filter MASIC data masic_data &lt;- filter_masic_data(masic_data, interference_score_threshold = 0.5, s2n_threshold = 0) 1.1.10 Create Study Design Tables To convert from PSMs and reporter ion intensities to meaningful quantitative data, it is necessary to know what are the samples in the reporter channels and what is the intended reference channel (or combination of channels). The entire study design is captured by three tables - fractions, samples, references. With newly processed data, these typically do not exist, and must be created. The next sections show how to create these tables. 1.1.11 Fractions The fractions table consists of two columns: Dataset and PlexID. The Dataset column contains all of the unique datasets from msnid$Dataset or masic_data$Dataset. The PlexID column contains the plex ID associated with each dataset, and is typically an S followed by a number (S1, S2, etc.). We can extract the plex ID from the datasets. In this case, the plex ID always comes after W, so we can use a regular expression (regex) to capture it (the first argument of gsub). The regex below says to capture an S followed by a single digit that appears after W and before an underscore. # Create fractions table fractions &lt;- data.frame(Dataset = unique(masic_data$Dataset)) %&gt;% mutate(PlexID = gsub(&quot;.*_W_(S\\\\d{1})_.*&quot;, &quot;\\\\1&quot;, Dataset)) Table 1.3: First 10 rows of the fractions table. Dataset PlexID MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_02_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_03_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_04_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_05_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_06_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_08_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_09_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_10_12Oct17_Elm_AQ-17-09-02 S1 Table 1.3 shows the first 10 rows of fractions. 1.1.12 Samples The samples table contains columns PlexID, QuantBlock, ReporterName, ReporterAlias, and MeasurementName. The plex ID must be the same as the plex ID in the fractions table. ReporterName is the reporter ion name (126, 127N, 127C, etc.). ReporterAlias is the intermediate between ReporterName and MeasurementName and is used for defining the reference. MeasurementName determines the column names for the final cross-tab, and must be unique and begin with a letter. Finally, QuantBlock can be thought of as a way of defining sub-plex. In a typical TMT experiment, QuantBlock is always 1. In case of 5 pairwise comparisons within TMT10, there will be 5 QuantBlocks (1-5) with a reference for each QuantBlock. For this experiment, channel 131 will serve as the reference, so we set MeasurementName to NA when ReporterName is \"131\". This will make the reference channel absent from the quantitative cross-tab. In cases where reporter ion intensities are not normalized by a reference channel (reference = 1) or they are normalized by the average of select channels, do not set any MeasurementName to NA. # Create samples table samples &lt;- read.delim(&quot;data/MoTrPAC_pilot_TMT_labeling.txt&quot;) %&gt;% dplyr::rename(ReporterName = TMT10_channel, ReporterAlias = sample_ID) %&gt;% mutate(QuantBlock = 1, MeasurementName = ifelse(ReporterAlias == &quot;ref&quot;, NA, ReporterAlias)) Table 1.4: First 10 rows of the samples table. ReporterAlias ReporterName PlexID QuantBlock MeasurementName S_01 129C S1 1 S_01 S_02 129N S1 1 S_02 S_03 130C S1 1 S_03 S_04 130N S1 1 S_04 S_05 126 S2 1 S_05 S_06 127C S2 1 S_06 S_07 127N S2 1 S_07 S_08 128C S2 1 S_08 S_09 128N S2 1 S_09 ref 131 S1 1 NA Table 1.4 shows the first 10 rows of samples. 1.1.13 References Reference can be a certain channel, average of multiple channels, or 1. The general form is an expression with ReporterAlias names as variables. It is evaluated for each PlexID/QuantBlock combination and applied to divide reporter ion intensities within corresponding PlexID/QuantBlock. # Create references table references &lt;- samples %&gt;% # Filter to reference channel (ReporterName == &quot;131&quot;, ReporterAlias == &quot;ref&quot;) filter(ReporterName == &quot;131&quot;) %&gt;% # Select required columns and rename ReporterAlias to Reference select(PlexID, Reference = ReporterAlias, QuantBlock) Table 1.5: References table. PlexID Reference QuantBlock S1 ref 1 S2 ref 1 Table 1.5 shows the first 10 rows of references. The code to use the geometric average instead of a single channel as the reference is shown below. The geometric average is the product of the reporter ion channels to the power of (1/number of channels). For each PlexID group, collapse the vector of reporter ion names with *, surround them in parentheses, and raise to the power of (1/number of channels). # Use geometric average as reference references &lt;- samples %&gt;% group_by(PlexID, QuantBlock) %&gt;% summarise(Reference = sprintf(&quot;(%s)^(1/%d)&quot;, paste(ReporterAlias, collapse = &quot;*&quot;), n())) # Do not normalize by reference channel (use 1 as the reference) references &lt;- samples %&gt;% distinct(PlexID, QuantBlock) %&gt;% mutate(Reference = 1) Now that we have the three study design tables, we should save them. # Save study design tables write.table(fractions, file = &quot;data/fractions.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) write.table(samples, file = &quot;data/samples.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) write.table(references, file = &quot;data/references.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) 1.1.14 Create Quantitative Cross-tab This is the step where MS/MS IDs and reporter ions are linked together and aggregated to the peptide or accession (i.e. protein) level. To retain protein IDs while aggregating to peptide level, set aggregation_level &lt;- c(\"accession\",\"peptide\"). The abundances are converted to relative abundances by dividing by the reference and then \\(log_2\\)-transformed. # Set aggregation level aggregation_level &lt;- c(&quot;accession&quot;) # Create cross-tab crosstab &lt;- create_crosstab(msnid, masic_data, aggregation_level = aggregation_level, fractions, samples, references) Table 1.6: First 6 rows of the global quantitative cross-tab. R_01 R_02 R_03 R_04 R_05 R_06 R_07 R_08 R_09 S_01 S_02 S_03 S_04 S_05 S_06 S_07 S_08 S_09 AP_004893.1 0.1419768 0.7628195 0.1653552 0.8662554 0.9453172 -0.8794712 -0.1912097 0.3964607 -0.2440478 -0.6460065 -1.9294467 -0.4321433 -1.2831873 -1.0271227 -0.9390945 0.4883309 -1.7148628 -0.7029685 AP_004894.1 0.8092676 -0.0976095 -0.3113350 0.3215692 0.2171255 -1.3515366 -0.7462995 -0.8338103 -0.2227493 -0.3678781 -0.1638689 -0.6696829 -1.2039041 -0.5124954 -0.2364175 -0.4428327 -1.3730408 -0.6711809 AP_004895.1 0.2078433 -0.2867209 -0.6089756 -0.1162062 -0.3840271 -0.6780284 -0.6102404 -0.3896190 -0.1548544 -1.1240967 -0.6908468 -0.6652575 -0.7140383 0.2717217 -0.1448289 -0.1200736 -0.6435709 -0.4287771 AP_004896.1 -0.1494849 -0.3664339 -0.7314368 -0.1742391 -0.5352280 -0.6543311 -0.6741064 -0.3994149 -0.0441485 -1.2945071 -1.0372327 -0.7060783 -0.8299749 0.1939540 -0.2274358 -0.1688422 -0.5251264 -0.4222698 AP_004898.1 0.0362964 0.7497227 0.4252227 0.4913660 1.1580326 -1.8439756 -0.1774225 -1.1083199 -0.4175363 0.1211536 -0.3640632 -0.3019505 -0.8291744 -0.8407749 -0.2796091 -0.4130732 -1.5747761 -0.9449498 AP_004899.1 0.7140968 -0.1781542 -0.3732752 0.3494902 -0.0615626 -1.0482424 -0.8052899 -0.6675429 -0.3959923 -2.1679002 -0.8550940 -0.9026145 -1.4519278 -0.3158081 -0.4056811 -0.4644758 -0.2805080 -0.9023044 Now that we have the cross-tab, we should save it. # Save cross-tab write.table(crosstab, file = &quot;data/global_quant_crosstab.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = TRUE) We will also save the proteins (row names) of this cross-tab in order to demonstrate prioritized inference in Section 1.2. # Save global proteins global_proteins &lt;- rownames(crosstab) save(global_proteins, file = &quot;data/3442_global_proteins.RData&quot;) 1.1.15 Create MSnSet Object The final step is to create an MSnSet object, which is necessary for downstream data analysis tools such as the plot_pca_* or limma_* functions in MSnSet.utils. An MSnSet combines three tables into one object: exprs, fData, and pData. exprs is a matrix of protein abundance data with proteins as rows and samples as columns. fData is used to convert between different feature IDs such as RefSeq, UniProt accession, Entrez gene ID, gene symbol, etc. It is optional, but the rownames of fData must be the same as the row names of exprs. Lastly, pData contains the metadata with samples as rows, and the row names must be the same as the column names of exprs (same order as well). For this example, we dont have an actual metadata table. We just know group assignment from the sample names. Samples with an R are part of the exeRcised group, while samples with an S are part of the Sedentary group. We can make a metadata table with a single column called group. metadata &lt;- data.frame(group = gsub(&quot;([RS]).*&quot;, &quot;\\\\1&quot;, colnames(crosstab))) %&gt;% mutate(group = ifelse(group == &quot;R&quot;, &quot;exercised&quot;, &quot;sedentary&quot;)) rownames(metadata) &lt;- colnames(crosstab) Table 1.7: Metadata for MSnSet. group R_01 exercised R_02 exercised R_03 exercised R_04 exercised R_05 exercised R_06 exercised R_07 exercised R_08 exercised R_09 exercised S_01 sedentary S_02 sedentary S_03 sedentary S_04 sedentary S_05 sedentary S_06 sedentary S_07 sedentary S_08 sedentary S_09 sedentary Since we used the sample data to create the metadata, everything is in the right order; however, we usually need to reorder the rows of the metadata. We can do this with # Reorder rows of metadata to match sample order in crosstab # Need to add drop = FALSE if the metadata is a single column metadata &lt;- metadata[colnames(crosstab), , drop = FALSE] We have the metadata and protein abundance data, so we can now create the MSnSet. We will call it m1 and we should save it as an .RData file. # Create MSnSet m1 &lt;- MSnbase::MSnSet(exprs = as.matrix(crosstab), pData = metadata) validObject(m1) ## [1] TRUE If we type the name of the MSnSet in the console, a summary will be displayed. This will show information about each of the tables, and the MSnSet will keep track of all processing done such as filtering at the bottom under Processing information. # Display summary m1 ## MSnSet (storageMode: lockedEnvironment) ## assayData: 5178 features, 18 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: R_01 R_02 ... S_09 (18 total) ## varLabels: group ## varMetadata: labelDescription ## featureData: none ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: ## - - - Processing information - - - ## MSnbase version: 2.18.0 # Save unprocessed MSnSet save(m1, file = &quot;data/global_msnset.RData&quot;) "],["phosphoproteomics-data.html", "1.2 Phosphoproteomics Data", " 1.2 Phosphoproteomics Data This pipeline shows how to process phosphoproteomics data from the DMS. Phosphoproteomics deals with proteins that have been phosphorylated. Phosphorylation is a type of reversible post-translational modification (PTM; a protein modification that occurs after protein synthesis) in which a protein kinase attaches a phosphate group to an amino acid residue. This change in a proteins structure can completely alter aspects such as its biological activity and protein-protein interactions, and abnormal phosphorylation is now recognized as a cause or consequence of many human diseases (Cohen, 2002). The most commonly phosphorylated amino acids are serine (S), threonine (T), and tyrosine (Y). For this section, we will use data package number 3626. We will need the PlexedPiper package for isobaric quantification and PNNL.DMS.utils to interface with the DMS. Also, details will be omitted if they were already provided in Section 1.1. # Setup library(PNNL.DMS.utils) library(PlexedPiper) library(Biostrings) library(dplyr) # %&gt;% library(MSnbase) 1.2.1 Read MS-GF+ Output # Read MS-GF+ data data_package_num &lt;- 3626 msnid &lt;- read_msgf_data_from_DMS(data_package_num) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 612667 at 55 % FDR ## #peptides: 396540 at 75 % FDR ## #accessions: 121521 at 98 % FDR 1.2.2 Correct Isotope Selection Error # Correct for isotope selection error msnid &lt;- correct_peak_selection(msnid) 1.2.3 Remove Non-Phosphorylated Peptides In this case, the phosphorylation of an amino acid is marked by a * inserted into the sequence after said amino acid. We will not consider unmodified peptides, so we can filter out peptides that do not contain this symbol with apply_filter. The * is a special character that must be escaped with backslashes, and the backslashes must also be escaped, since they are enclosed within a nested string (\"''\"). # Remove non-phosphorylated peptides # (peptides that do not contain a *) msnid &lt;- apply_filter(msnid, &quot;grepl(&#39;\\\\\\\\*&#39;, peptide)&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 537749 at 57 % FDR ## #peptides: 353634 at 76 % FDR ## #accessions: 118817 at 98 % FDR 1.2.4 Remove Contaminants # Remove contaminants msnid &lt;- apply_filter(msnid, &quot;!grepl(&#39;Contaminant&#39;, accession)&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 537572 at 57 % FDR ## #peptides: 353489 at 76 % FDR ## #accessions: 118797 at 98 % FDR 1.2.5 Improve Phosphosite Localization Phospho datasets involve AScore jobs for improving phosphosite localization. There should be one AScore job per data package. If the AScore job does not exist, see AScore Job Creation for how to set it up. The fetched object is a data.frame that links datasets, scans and original PTM localization to newly suggested locations. Importantly, it contains AScore column that signifies the confidence of PTM assignment. AScore &gt; 17 is considered confident. # Filter PTMs by Ascore ascore &lt;- get_AScore_results(data_package_num) msnid &lt;- best_PTM_location_by_ascore(msnid, ascore) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 188791 at 30 % FDR ## #peptides: 101873 at 53 % FDR ## #accessions: 90677 at 93 % FDR 1.2.6 MS/MS ID Filter: Peptide Level # 1% FDR filter at the peptide level msnid &lt;- filter_msgf_data(msnid, level = &quot;peptide&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 76103 at 0.49 % FDR ## #peptides: 23378 at 1 % FDR ## #accessions: 16090 at 4.7 % FDR 1.2.7 MS/MS ID Filter: Protein Level # Get path to FASTA file path_to_FASTA &lt;- path_to_FASTA_used_by_DMS(data_package_num) # Compute number of peptides per 1000 amino acids msnid &lt;- compute_num_peptides_per_1000aa(msnid, path_to_FASTA) # 1% FDR filter at the protein level msnid &lt;- filter_msgf_data(msnid, level = &quot;accession&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 72481 at 0.12 % FDR ## #peptides: 21266 at 0.26 % FDR ## #accessions: 9424 at 0.98 % FDR 1.2.8 Inference of Parsimonious Protein Set # Load proteins from global crosstab global_proteins &lt;- readRDS(&quot;data/3442_global_protein_names.rds&quot;) # Inference of parsimonious protein set msnid &lt;- infer_parsimonious_accessions(msnid, unique_only = FALSE, prior = global_proteins) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 72481 at 0.12 % FDR ## #peptides: 21266 at 0.26 % FDR ## #accessions: 2895 at 1.6 % FDR 1.2.9 Remove Decoy PSMs # Remove Decoy PSMs msnid &lt;- apply_filter(msnid, &quot;!isDecoy&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 72391 at 0 % FDR ## #peptides: 21211 at 0 % FDR ## #accessions: 2849 at 0 % FDR 1.2.10 Map Sites to Protein Sequences Prepare FASTA to make sure entry names in FASTA file match MSnID accessions. The plan is to make this conversion automatic. map_mod_sites creates a number of columns describing mapping of the sites onto the protein sequences. The most important for the user is SiteID. # Create AAStringSet fst &lt;- readAAStringSet(path_to_FASTA) # Remove contaminants fst &lt;- fst[!grepl(&quot;Contaminant&quot;, names(fst)), ] # First 6 names head(names(fst)) ## [1] &quot;NP_783171.2 cathepsin R precursor [Rattus norvegicus]&quot; ## [2] &quot;NP_001101862.2 zinc finger protein ZIC 2 [Rattus norvegicus]&quot; ## [3] &quot;NP_113721.4 UDP-glucuronosyltransferase 2B2 precursor [Rattus norvegicus]&quot; ## [4] &quot;NP_714948.1 Ly-49 stimulatory receptor 3 [Rattus norvegicus]&quot; ## [5] &quot;NP_001000704.1 olfactory receptor Olr931 [Rattus norvegicus]&quot; ## [6] &quot;NP_001000638.1 olfactory receptor Olr652 [Rattus norvegicus]&quot; # Modify names to match accessions(msnid) names(fst) &lt;- strsplit(names(fst), split = &quot; &quot;) %&gt;% # Select text before first space lapply(function(x) x[1]) %&gt;% unlist() # First 6 names head(names(fst)) ## [1] &quot;NP_783171.2&quot; &quot;NP_001101862.2&quot; &quot;NP_113721.4&quot; &quot;NP_714948.1&quot; ## [5] &quot;NP_001000704.1&quot; &quot;NP_001000638.1&quot; # Main mapping call msnid &lt;- map_mod_sites(object = msnid, fasta = fst, accession_col = &quot;accession&quot;, peptide_mod_col = &quot;peptide&quot;, mod_char = &quot;*&quot;, site_delimiter = &quot;lower&quot;) Table 1.8: First 6 rows of the processed MS-GF+ results. Dataset ResultID Scan FragMethod SpecIndex Charge PrecursorMZ DelM DelM_PPM MH OriginalPeptide Protein NTT DeNovoScore MSGFScore MSGFDB_SpecEValue Rank_MSGFDB_SpecEValue EValue QValue PepQValue IsotopeError accession calculatedMassToCharge chargeState experimentalMassToCharge isDecoy spectrumFile spectrumID pepSeq peptide maxAScore msmsScore absParentMassErrorPPM peptides_per_1000aa First_AA Last_AA First_AA_First Last_AA_First ProtLen ModShift ModAAs SiteLoc Site SiteCollapsed SiteCollapsedFirst SiteID MoTrPAC_Pilot_TMT_P_S1_06_DIL_28Oct17_Elm_AQ-17-10-03 12697 27321 HCD 2256 3 1045.124 0.003 0.858 3131.346 A.AAAAAGDS*DS*WDADTFSMEDPVRK.V NP_001071138.1 1 146 58 0 1 0 0 0 2 NP_001071138.1 1044.454 3 1044.455 FALSE MoTrPAC_Pilot_TMT_P_S1_06_DIL_28Oct17_Elm_AQ-17-10-03 27321 AAAAAGDSDSWDADTFSMEDPVRK A.AAAAAGDSDS*WDADT*FSMEDPVRK.V 0.000 Inf 1.057 7.722 5 28 5 28 259 9, 14 S, T 14, 19 S14, T19 S14,T19 S14,T19 NP_001071138.1-S14sT19t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 875 23519 HCD 264 3 952.144 0.004 1.538 2854.412 R.AAAASAAEAGIAT*PGTEDSDDALLK.M XP_006232986.1 2 165 129 0 1 0 0 0 0 XP_006232986.1 952.142 3 952.144 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 23519 AAAASAAEAGIATPGTEDSDDALLK R.AAAASAAEAGIAT*PGTEDSDDALLK.M 52.349 Inf 1.625 5.305 238 262 238 262 377 12 T 250 T250 T250 T250 XP_006232986.1-T250t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 12873 23508 HCD 2213 4 714.360 0.007 2.392 2854.412 R.AAAASAAEAGIAT*PGTEDSDDALLK.M XP_006232986.1 2 122 81 0 1 0 0 0 0 XP_006232986.1 714.358 4 714.360 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 23508 AAAASAAEAGIATPGTEDSDDALLK R.AAAASAAEAGIAT*PGTEDSDDALLK.M 17.480 Inf 2.472 5.305 238 262 238 262 377 12 T 250 T250 T250 T250 XP_006232986.1-T250t MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 2731 23697 HCD 502 4 714.610 0.002 0.706 2854.412 R.AAAASAAEAGIAT*PGTEDSDDALLK.M XP_006232986.1 2 135 104 0 1 0 0 0 1 XP_006232986.1 714.358 4 714.359 FALSE MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 23697 AAAASAAEAGIATPGTEDSDDALLK R.AAAASAAEAGIAT*PGTEDSDDALLK.M 26.295 Inf 0.780 5.305 238 262 238 262 377 12 T 250 T250 T250 T250 XP_006232986.1-T250t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 4877 21265 HCD 935 4 800.403 0.006 1.871 3196.577 R.AAAASAAEAGIAT*PGTEGERDSDDALLK.M NP_112621.1 2 194 114 0 1 0 0 0 2 NP_112621.1 799.900 4 799.901 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 21265 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIATPGT*EGERDSDDALLK.M 6.213 Inf 1.902 10.526 238 265 238 265 380 15 T 253 T253 T253 T253 NP_112621.1-T253t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 6826 21280 HCD 1251 3 1066.532 0.000 -0.095 3196.577 R.AAAASAAEAGIATPGT*EGERDSDDALLK.M NP_112621.1 2 200 94 0 1 0 0 0 1 NP_112621.1 1066.197 3 1066.197 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 21280 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIATPGT*EGERDSDDALLK.M 0.000 Inf 0.043 10.526 238 265 238 265 380 15 T 253 T253 T253 T253 NP_112621.1-T253t Table 1.8 shows the first 6 rows of the processed MS-GF+ output. 1.2.11 Read MASIC Output # Read MASIC data masic_data &lt;- read_masic_data_from_DMS(data_package_num, interference_score = TRUE) 1.2.12 Filter MASIC Data # Filter MASIC data masic_data &lt;- filter_masic_data(masic_data, interference_score_threshold = 0.5, s2n_threshold = 0) 1.2.13 Create Study Design Tables If study design tables are on the DMS, they can be accessed in the following way. # Read study design tables from DMS study_design &lt;- read_study_design_from_DMS(data_package_num) fractions &lt;- study_design$fractions samples &lt;- study_design$samples references &lt;- study_design$references While the study design tables are not on the DMS, we already created them in Section 1.1.10. We just need to recreate the fractions table because the dataset names are different. # Read tables from folder samples &lt;- read.delim(&quot;data/samples.txt&quot;) references &lt;- read.delim(&quot;data/references.txt&quot;) fractions &lt;- data.frame(Dataset = unique(masic_data$Dataset)) %&gt;% mutate(PlexID = gsub(&quot;.*_P_(S\\\\d{1})_.*&quot;, &quot;\\\\1&quot;, Dataset)) 1.2.14 Create Quantitative Cross-tab # Set aggregation level aggregation_level &lt;- c(&quot;SiteID&quot;) # Create cross-tab crosstab &lt;- create_crosstab(msnid, masic_data, aggregation_level = aggregation_level, fractions, samples, references) Table 1.9: First 6 rows of the phospho quantitative cross-tab. R_01 R_02 R_03 R_04 R_05 R_06 R_07 R_08 R_09 S_01 S_02 S_03 S_04 S_05 S_06 S_07 S_08 S_09 NP_001000283.1-Y132yS137s NA NA NA NA NA -0.7653521 -0.5428785 -0.2119856 -0.1239261 NA NA NA NA 0.0038421 -0.2425074 -0.7416622 -0.7497171 -0.4879016 NP_001001064.1-Y129y NA NA NA NA NA -1.0408865 -0.2976259 -0.7301538 -0.1385762 NA NA NA NA 0.1594274 -0.6587720 0.1932351 -0.6370354 -0.4461276 NP_001001512.2-S241s -0.5441083 -0.0291611 -0.5540885 -0.1812456 -0.5675833 NA NA NA NA -0.0427948 -0.803056 -0.5236890 -1.0398773 NA NA NA NA NA NP_001001512.2-S242s -0.2806018 -0.2939827 -0.3923442 -0.3242804 -0.6512914 -1.3958746 -0.6640721 -0.7046127 -0.3091972 -0.4914234 -1.210593 -0.6421375 -0.8869142 -0.3079991 -0.8072458 -0.4801256 -0.4458455 -0.7588038 NP_001001512.2-S699s NA NA NA NA NA -0.8584401 -0.4918316 -0.2745069 0.2867235 NA NA NA NA -0.7930334 -1.2173509 -0.4608541 -1.2596689 -0.8004630 NP_001001512.2-S746s NA NA NA NA NA NA -1.5981389 -2.4732843 -0.4736739 NA NA NA NA -1.4611181 -2.2975481 -1.6828088 -2.3039510 -1.8632844 We will save the cross-tab for later sections. # Modify cross-tab for saving crosstab &lt;- crosstab %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(&quot;SiteID&quot;) # Save cross-tab write.table(crosstab, file = &quot;data/phosphosite_quant_crosstab.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) References "],["label-free-quantification.html", "Section 2 Label-Free Quantification", " Section 2 Label-Free Quantification This is a generic spectral counting script for MS-GF+ Human/UniProt searches. Only modify the lines that change the data package number and the name of the final .xlsx file that will be saved, unless you know what you are doing. # Required packages library(PNNL.DMS.utils) library(MSnID) library(PlexedPiper) library(MSnbase) library(writexl) library(dplyr) library(tibble) # Data package number data_package_num &lt;- 3987 # Name of the final file to save file_name &lt;- &quot;data/3987_spectral_counts.xlsx&quot; Do not modify anything below unless you know what you are doing. # Read MS-GF+ results from the DMS m &lt;- read_msgf_data_from_DMS(data_package_num = data_package_num) # Filter to 1% FDR at the peptide level m &lt;- filter_msgf_data(m, level = &quot;peptide&quot;, fdr.max = 0.01) # UniProt to gene symbol conversion table conv_tab &lt;- fetch_conversion_table(organism_name = &quot;Homo sapiens&quot;, from = &quot;UNIPROT&quot;, to = &quot;SYMBOL&quot;) When running fetch_conversion_table, if a prompt appears that requires an answer, type yes and press enter. # Modify accessions column of psms to use gene symbols m &lt;- remap_accessions(m, conv_tab, &quot;\\\\|([^|-]+)(-\\\\d+)?\\\\|&quot;) # Do the same remapping to the FASTA file fst_path &lt;- path_to_FASTA_used_by_DMS(data_package_num = data_package_num) fst_path_2 &lt;- remap_fasta_entry_names( path_to_FASTA = fst_path, conversion_table = conv_tab, extraction_pttrn = &quot;\\\\|([^|-]+)(-\\\\d+)?\\\\|&quot; ) # Compute the number of amino acids per 1000 and use that to filter # to 1% FDR at the protein level m &lt;- compute_num_peptides_per_1000aa(m, fst_path_2) m &lt;- filter_msgf_data(m, &quot;accession&quot;, fdr.max = 0.01) # Parsimonious protein inference m &lt;- infer_parsimonious_accessions(m) show(m) # Assessment of filtering quality ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 8 ## #PSMs: 87392 at 0.044 % FDR ## #peptides: 21634 at 0.12 % FDR ## #accessions: 2421 at 1 % FDR The results look reasonable, so we will continue on to spectral counting. # Remove decoys m &lt;- apply_filter(m, &quot;!isDecoy&quot;) # Convert m to an MSnSet msnset &lt;- as(m, &quot;MSnSet&quot;) # Spectral counting: # Within each accession group, sum the values within columns. msnset &lt;- combineFeatures(msnset, fData(msnset)$accession, redundancy.handler = &quot;multiple&quot;, method = &quot;sum&quot;, cv = FALSE) # Sort features from most to least abundant tot_count &lt;- rowSums(exprs(msnset)) msnset &lt;- msnset[order(-tot_count), ] # Save exprs as an .xlsx file msnset %&gt;% exprs() %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;Gene&quot;) %&gt;% write_xlsx(path = file_name) "],["exploratory-data-analysis.html", "Section 3 Exploratory Data Analysis", " Section 3 Exploratory Data Analysis Exploratory Data Analysis (EDA) is an important step before any sort of statistical analyses. The goal of EDA is to get a big picture view of the data and identify potential outlier samples and batch effects that need to be corrected. For this section, we need to load the MSnSet.utils, dplyr, and car packages. MSnSet.utils contains the cptac_oca data that we will use to illustrate these EDA approaches, as well as the plot_pca function for creating PCA plots of samples. The dplyr package is used for data frame manipulation, though it is only used for the pipe operator (%&gt;%) in this section. The car package is used to create density plots with the plotDensity function, though similar plots can be made by combining stats::density with base::plot. If creating figures for publications or presentations, it is recommended to use the ggplot2 package. For this section, however, I opted to use simpler plotting functions where possible because these initial plots are just to get a first impression of the data. # Packages library(MSnSet.utils) library(dplyr) library(car) # Load the example MSnSet data(cptac_oca) "],["count-features-in-samples.html", "3.1 Count Features in Samples", " 3.1 Count Features in Samples To count the number of features identified in each sample, we use colSums to tally the number of entries that are not NA in each column of exprs(oca.set). # Calculate the number of proteins identified (not NA) in each sample oca.set$num_proteins &lt;- colSums(!is.na(exprs(oca.set))) Now that we have a vector of the number of proteins detected in each sample stored in pData(oca.set), there are a few ways to present it. The first is a simple summary, which is accomplished with the summary function. This outputs the average value, as well as a 5-number summary that includes the minimum, the 1st quartile, the median (2nd quartile), the 3rd quartile, and the maximum value. summary(oca.set$num_proteins) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 6594 6957 7286 7225 7463 7798 The 5-number summary can also be presented as a boxplot, which is typically more useful at a glance. Below is an example of how to create a horizontal boxplot. # Horizontal boxplot boxplot(oca.set$num_proteins, horizontal = TRUE, xlab = &quot;Number of Proteins Detected&quot;) Boxplots are useful, but a lot of the finer details about the distribution are lost when summarizing. To remedy this, we could instead show a scatterplot of the individual values with the base plot function. We will change the point type with pch to plot solid circles and change the axis titles with xlab and ylab. plot(oca.set$num_proteins, pch = 19, xlab = &quot;Sample Index&quot;, ylab = &quot;Number of Proteins Detected&quot;) While harder to interpret at a glance than a boxplot, scatterplots are useful for identifying potential outliers and possible trends in the data. In the plot above, it doesnt appear than there are any samples with significantly fewer identifications. The other plot type we could use balances the summary of the boxplot with the finer detail of the scatterplot: density plots. We will pipe the vector of protein counts to two arguments of the densityPlot function from the car package with the . placeholder. # Density plot - pipe the vector to multiple arguments with . oca.set$num_proteins %&gt;% densityPlot(x = ., xlim = range(.), main = &quot;Density Plot&quot;, xlab = &quot;Number of Proteins Detected&quot;) It looks like there are peaks around 6900-7000 and 7300-7500 proteins. The rug plot (one-dimensional scatterplot) at the bottom of the density estimate shows the counts, so this particular density plot presents much of the same information as the scatterplot. "],["estimate-blood-contamination.html", "3.2 Estimate Blood Contamination", " 3.2 Estimate Blood Contamination Strong contamination of samples with blood may lead to the inability to identify low-abundant proteins, so it is important to estimate the level of blood contamination. We can search for major blood proteins with the grepl function and summarize their abundances within each sample to obtain reasonable estimates. We will need to search for the blood protein identifiers that match the protein identifiers in the MSnSet. Since we are using the cptac_oca data for these examples, we will need to know the NCBI RefSeq protein IDs for the following blood proteins: hemoglobin, fibrinogen, albumin, and spectrin. Unfortunately, this means manually searching for these identifiers, which are provided in the list below. hemoglobin subunit alpha 1: NP_000549.1 subunit alpha 2: NP_000508.1 subunit beta: NP_000509.1 subunit gamma-1: NP_000550.2 subunit gamma-2: NP_000175.1 albumin: NP_000468.1 fibrinogen alpha chain isoform alpha precursor: NP_068657.1 alpha chain isoform alpha-E preprotein: NP_000499.1 spectrin alpha chain, erythrocytic 1: NP_003117.2 beta chain, erythrocytic 1: NP_001342365.1 We need to create a vector of these blood protein IDs. We will use this to check if each feature is a blood protein. Doing so will create a logical vector that we can use to subset the data to the abundance values of those matches. With the subset data, we can then calculate the column (sample) averages with colMeans to get a single vector that estimates the average blood contamination of each sample. # Blood protein IDs blood_prot &lt;- c(&quot;NP_000549.1&quot;, &quot;NP_000508.1&quot;, &quot;NP_000509.1&quot;, &quot;NP_000550.2&quot;, &quot;NP_000175.1&quot;, &quot;NP_000468.1&quot;, &quot;NP_068657.1&quot;, &quot;NP_000499.1&quot;, &quot;NP_003117.2&quot;, &quot;NP_001342365.1&quot;) # Select entries that match one of the blood proteins idx &lt;- featureNames(oca.set) %in% blood_prot # indexing matches blood_contam &lt;- colMeans(exprs(oca.set)[idx, ], na.rm = TRUE) We can visualize the blood contamination with any of the previously shown methods for visualizing number of protein identifications. We will use a density plot. # Pipe vector to densityPlot blood_contam %&gt;% densityPlot(x = ., xlim = range(.), main = &quot;Blood Contamination&quot;, xlab = &quot;Average Protein Abundance&quot;) "],["pca.html", "3.3 PCA", " 3.3 PCA Principal Component Analysis (PCA) is an unsupervised dimensionality reduction technique. It is useful for visualizing high-dimensional data in a lower-dimensional (usually 2D) space while retaining as much information from the original data as possible. It does this by creating linear combinations of features called principal components in such a way that that the first principal component (PC1) explains the most variation in the original data, PC2 explains the second most, and so on. Typically, we create scatterplots of PC1 vs PC2 to visualize relationships between samples with the plot_pca function from the MSnSet.utils package. PCA plots are used to check for batch effects and sample differences due to variables of interest. If samples appear to separate by group or according to a continuous variable and the first two principal components explain a decent percentage of the variance in the original data, then we are fairly confident that the predictor affected the data in some way or is at least correlated to something that did. Note that while there are PCA methods that allow some degree of missing data (see pcaMethods::pca for details), plot_pca makes use of the prcomp function, which does not. We do not need to filter data prior to running plot_pca, as it handles that and prints a message to tell us how many complete rows remained. If there are very few complete features, PCA will still work, but the results may not be very meaningful. In this case, it may be a good idea to impute missing values. We will begin with the base plot. The axis titles show how much variance in the original data is explained by each component. This is built with the ggplot2 package, so it can be customized with other functions in the package. # Default plot plot_pca(oca.set) Of the total 8103 features, 4738 were present in all 73 samples and used for PCA. Also notice that PC1 and PC2 explain less than 1/5 of the variance in the original data. Now, we will color points according to their SUBTYPE group label and add a 50% Normal confidence ellipse for each group. We could remove the ellipse by setting show_ellipse to FALSE. We will also change the legend title to Subtype. # Points colored by SUBTYPE plot_pca(oca.set, phenotype = &quot;SUBTYPE&quot;, legend_title = &quot;Subtype&quot;) It looks like samples slightly separate by SUBTYPE, and there may be features that are statistically different between the Proliferative and Mesenchymal groups. Something to keep in mind when performing differential analysis. Now, we will check for potential batch effects by coloring points by their Batch group. # Points colored by Batch plot_pca(oca.set, phenotype = &quot;Batch&quot;) For the most part, it seems like all of the batches overlap and are somewhat centered on the origin (aside from batch X17). It is difficult to determine if there is a batch effect, so it may be a good idea to correct for it anyway. This is covered in a different section. We can also use this function to identify the most influential features in PCA space with the biplot argument. plot_pca(oca.set, phenotype = &quot;SUBTYPE&quot;, biplot = TRUE, label_args = list(color = &quot;black&quot;)) From the biplot, we can see that proteins that begin with NP_9976 are major drivers in the separation of the Mesenchymal and Proliferative samples. Similarly, we can see that there are a few blood proteins (hemoglobin subunits: NP000549.1 and NP_000550.2) that are major drivers of separation along PC2, though PC2 only explains about 6% of the variance in the original data. See ?plot_pca for more customization options. "],["heatmaps.html", "Section 4 Heatmaps", " Section 4 Heatmaps Heatmaps are graphical representations of matrices that use color to show differences in values. They are useful for detecting overall patterns in data, as they can show how features and samples relate to each other or how features change according to some phenotype of interest. In this section, we will explore how to create expression and correlation heatmaps from MSnSet objects, as well as how to improve the appearance of these heatmaps. We will need the following packages and MSnSet. library(MSnSet.utils) # complex_heatmap library(circlize) # colorRamp2 library(ComplexHeatmap) # additional modifications library(dplyr) # %&gt;% # Data data(&quot;longitudinal_biomarker_study&quot;) # Shorten name m &lt;- longitudinal_biomarker_study "],["expression-heatmaps.html", "4.1 Expression Heatmaps", " 4.1 Expression Heatmaps A heatmap of the expression matrix of an MSnSet with features as rows and samples as columns. The data is assumed to be zero-centered. By default, row and column names are not shown. See ?complex_heatmap for how to change this. # Base expression heatmap complex_heatmap(m) # Change color range to better detect patterns complex_heatmap(m, color_range = c(-1.5, 1.5)) # Change heatmap title and legend title complex_heatmap(m, heatmap_title = &quot;This is the heatmap title&quot;, heatmap_legend_title = &quot;Legend\\nTitle&quot;) "],["correlation-heatmaps.html", "4.2 Correlation Heatmaps", " 4.2 Correlation Heatmaps When the heatmap_type argument is (an abbreviation of) \"sample_correlation\" or \"feature_correlation\", complex_heatmap constructs the matrix of correlations (default cor_method = \"pearson\") between samples or features and generates a heatmap. Correlation heatmaps become even more useful when annotated (Section 4.3). 4.2.1 Sample Correlation # Sample correlation heatmap complex_heatmap(m, heatmap_type = &quot;sample&quot;) 4.2.2 Feature Correlation # Feature correlation heatmap complex_heatmap(m, heatmap_type = &quot;feature&quot;) "],["heatmap-annotation.html", "4.3 Heatmap Annotation", " 4.3 Heatmap Annotation To annotate columns and rows of the heatmap, we use the anno_column and anno_row arguments, respectively. anno_column takes a vector of one or more strings that correspond to the names of columns in pData, and anno_row takes a vector of one or more strings that correspond to the names of column in fData. By default, MSnSet.utils::jet2.colors is used for character, factor, and logical values, and circlize::colorRamp2 with a viridis color palette is used for numeric values. When annotating sample correlation heatmaps, only anno_column may be specified. Similarly, when annotating feature correlation heatmaps, only anno_row may be specified. Row or column annotations will be included along the other axis. We will annotate the rows using values in the \"isSpike\" (logical) column of fData(m) and annotate rows using the values in the \"Type\" (factor) and \"Age\" (numeric) columns of pData(m). # Expression heatmap with row and column annotation complex_heatmap(m, anno_row = &quot;isSpike&quot;, anno_column = c(&quot;Type&quot;, &quot;Age&quot;)) 4.3.1 Modifying Default Colors We can change the colors of row and column annotations by passing lists to anno_row_colors and anno_column_colors, respectively. For example, we will change the colors of \"Type\" so that Control is a different shade of blue (#414DBE) and Case is a dark yellow (#BEB241). We will also change the colors of \"Age\" so that the minimum value is white and the maximum value is dark red. Since age is a numeric column, we must use circlize:colorRamp2. Tip: Use palettes from the RColorBrewer package, an interactive color wheel (like this one from canva), or a color palette generator (like this one also from canva) to find colors. # Modify colors for Type and Age complex_heatmap(m, anno_column = c(&quot;Type&quot;, &quot;Age&quot;), anno_column_colors = list( Type = c(&quot;#414DBE&quot;, &quot;#BEB241&quot;), Age = circlize::colorRamp2( breaks = range(m$Age, na.rm = TRUE), colors = c(&quot;white&quot;, &quot;darkred&quot;)) )) "],["additional-modifications.html", "4.4 Additional Modifications", " 4.4 Additional Modifications heatmap_args and anno_args are used to modify the heatmaps: changing the row and column labels, labeling specific features, changing the colors of labels, changing font size, adding different types of annotations, splitting rows or columns into groups, etc. The ComplexHeatmap Complete Reference goes more into detail about each of these modifications, but we will cover a few of them in this section in the context of MSnSets. We will use a random subset of the MSnSet to explore some of these modifications. This is just so we can see the row and column names more easily. set.seed(99) # subset to 25 features and 40 samples m_sub &lt;- m[sample(1:nrow(m), size = 25), sample(1:ncol(m), size = 40)] 4.4.1 Change row or column labels By default, the row and column labels are the row and column names of the matrix passed to Heatmap. In the case of the default expression heatmap, the row names are the featureNames of the MSnSet and the column names are the sampleNames. We can instead use any column in fData and any column in pData to label the rows and columns, respectively. Duplicate labels are also allowed, which is especially useful if there are multiple peptides that map to the same protein, multiple proteins that map to the same gene, etc. # Default row labels - peptides complex_heatmap(m_sub, show_row_names = TRUE, heatmap_title = &quot;Default Row Labels&quot;) Suppose, for example, we want to label the rows by the Protein column of fData(m_sub). We can do this by modifying the row_labels argument of ComplexHeatmap::Heatmap with the heatmap_args list. We will also reduce the font size of the labels so that they do not overlap. # Label rows with proteins and change font size complex_heatmap(m_sub, show_row_names = TRUE, heatmap_title = &quot;New Row Labels&quot;, heatmap_args = list(row_labels = fData(m_sub)[[&quot;Protein&quot;]], # Change font size of row labels row_names_gp = gpar(fontsize = 10))) 4.4.2 Change label colors # One color complex_heatmap(m_sub, show_row_names = TRUE, heatmap_args = list(row_names_gp = gpar(col = &quot;orange&quot;))) # Multiple colors # If peptide begins with &quot;A&quot;, color it red # If peptide begins with &quot;G&quot;, color it blue # Otherwise, color it black row_colors &lt;- featureNames(m_sub) %&gt;% {case_when(grepl(&quot;^A&quot;, .) ~ &quot;red&quot;, grepl(&quot;^G&quot;, .) ~ &quot;blue&quot;, TRUE ~ &quot;black&quot;)} complex_heatmap(m_sub, show_row_names = TRUE, heatmap_args = list( row_names_gp = gpar(col = row_colors))) 4.4.3 Label specific features We can use mark annotation to label specific features or samples. For this example, we will label all non-human proteins. We need the indices of the proteins to label and the column in fData used to select these labels. # Indices of non-human proteins idx &lt;- which(!grepl(&quot;HUMAN&quot;, fData(m)[[&quot;Protein&quot;]])) # Row annotation object. The name can be anything, so we just use anno ra &lt;- rowAnnotation(anno = anno_mark(at = idx, labels = fData(m)[[&quot;Protein&quot;]][idx])) # Heatmap with labels for select features complex_heatmap(m, heatmap_args = list(row_labels = fData(m)[[&quot;Protein&quot;]], right_annotation = ra)) 4.4.4 Change heatmap body color complex_heatmap(m, heatmap_args = list(col = circlize::colorRamp2( breaks = c(min(exprs(m), na.rm = TRUE), 0, max(exprs(m), na.rm = TRUE)), colors = c(&quot;purple&quot;, &quot;white&quot;, &quot;orange&quot;) )) ) If changing the colors of the heatmap body, color_range will not work. Instead, the breaks and colors need to be modified so that the minimum value and the lower limit are the same color and the maximum value and the upper limit are the same color. complex_heatmap(m, heatmap_args = list(col = circlize::colorRamp2( breaks = c(min(exprs(m), na.rm = TRUE), -1.5, 0, 1.5, # add color limits max(exprs(m), na.rm = TRUE)), colors = c(&quot;purple&quot;, &quot;purple&quot;, &quot;white&quot;, &quot;orange&quot;, &quot;orange&quot;) )) ) "],["DEA.html", "Section 5 Differential Analysis", " Section 5 Differential Analysis The overview goes here. library(MSnSet.utils) library(dplyr) library(ggplot2) # MSnSet data(&quot;cptac_oca&quot;) "],["linear-regression.html", "5.1 Linear Regression", " 5.1 Linear Regression res1 &lt;- limma_a_b(oca.set, model.str = &quot;~ AGE&quot;, coef.str = &quot;AGE&quot;) head(res1) ## logFC AveExpr t P.Value adj.P.Val B ## NP_000005.2 0.003758619 -1.672939e-17 0.4965363 0.6209622 0.9788087 -7.666191 ## NP_000007.1 -0.005272805 -1.611154e-17 -0.9293255 0.3556895 0.9498588 -7.356355 ## NP_000008.1 0.002761104 1.482832e-17 0.5570923 0.5791162 0.9762348 -7.634039 ## NP_000009.1 0.005113709 6.653734e-18 1.1437048 0.2563683 0.9242520 -7.134774 ## NP_000010.1 0.003634240 -4.752667e-18 0.5782844 0.5647973 0.9762348 -7.621921 ## NP_000012.1 -0.001469325 -5.880419e-18 -0.3930499 0.6956459 0.9866972 -7.634142 "],["one-way-anova.html", "5.2 One-Way ANOVA", " 5.2 One-Way ANOVA res2 &lt;- limma_gen(oca.set, model.str = &quot;~ SUBTYPE&quot;, coef.str = &quot;SUBTYPE&quot;) head(res2) ## SUBTYPEProliferative SUBTYPEMesenchymal SUBTYPEDifferentiated ## NP_000005.2 -0.15149043 0.05641954 -0.15057866 ## NP_000007.1 -0.24732121 -0.15789692 0.08496949 ## NP_000008.1 -0.15921805 -0.08113290 -0.20215369 ## NP_000009.1 0.05017789 0.03855355 0.06446570 ## NP_000010.1 -0.13569585 -0.47163526 0.22698229 ## NP_000012.1 0.05628690 0.15846512 0.05044680 ## AveExpr F P.Value adj.P.Val ## NP_000005.2 -1.672939e-17 0.38687311 0.762774864 0.85488216 ## NP_000007.1 -1.611154e-17 1.47040585 0.229634248 0.43978604 ## NP_000008.1 1.482832e-17 0.66869230 0.573961618 0.72866828 ## NP_000009.1 6.653734e-18 0.07665979 0.972406121 0.98383381 ## NP_000010.1 -4.752667e-18 4.90988300 0.003650144 0.03431203 ## NP_000012.1 -5.880419e-18 0.56550327 0.639900892 0.77495047 "],["t-tests.html", "5.3 t-tests", " 5.3 t-tests 5.3.1 One Comparison limma_a_b is used when there are exactly two levels that are being compared. If the coef.str column of the phenotype data is a factor, the first level will be used as the reference. If the coef.str column is a character vector, the first unique category will be used as the reference. # Only two-groups res3 &lt;- limma_a_b(oca.set, model.str = &quot;~ PLATINUM.STATUS&quot;, coef.str = &quot;PLATINUM.STATUS&quot;) head(res3) ## logFC AveExpr t P.Value adj.P.Val ## NP_000005.2 -0.107374921 -0.01665020 -0.43146914 0.667868628 0.9869175 ## NP_000007.1 0.492463553 0.05029281 2.74657864 0.008196829 0.9569777 ## NP_000008.1 0.137635365 0.03187806 0.85183002 0.398122076 0.9780748 ## NP_000009.1 0.085879347 0.03595808 0.56710194 0.573027180 0.9780748 ## NP_000010.1 0.116989322 -0.04849702 0.56970627 0.571271928 0.9780748 ## NP_000012.1 -0.009030939 -0.01768271 -0.07885814 0.937500866 0.9960390 ## B ## NP_000005.2 -4.774314 ## NP_000007.1 -3.618784 ## NP_000008.1 -4.680735 ## NP_000009.1 -4.750673 ## NP_000010.1 -4.750157 ## NP_000012.1 -4.771268 To count the number of significant features after adjustment, we can use table or sum. table(res3$adj.P.Val &lt; 0.05) ## ## FALSE ## 8101 No features are significantly different between the RESISTANT and SENSITIVE PLATINUM.STATUS levels after adjustment. 5.3.2 Multiple Comparisons limma_contrasts is used to perform multiple t-tests at the same time. We can use the paircomp function to generate contrasts to be used with paircomp. # Pairwise contrasts contrasts &lt;- paircomp(oca.set$SUBTYPE, name = &quot;SUBTYPE&quot;) contrasts ## [1] &quot;SUBTYPEProliferative-SUBTYPEImmunoreactive&quot; ## [2] &quot;SUBTYPEMesenchymal-SUBTYPEImmunoreactive&quot; ## [3] &quot;SUBTYPEDifferentiated-SUBTYPEImmunoreactive&quot; By default, limma_contrasts will generate diagnostic plots. We can prevent this by setting plot to FALSE. res4 &lt;- limma_contrasts(oca.set, model.str = &quot;~ 0 + SUBTYPE&quot;, coef.str = &quot;SUBTYPE&quot;, contrasts = contrasts, plot = FALSE) head(arrange(res4, feature)) ## feature contrast RefSeq logFC ## 1: NP_000005.2 Proliferative-Immunoreactive NP_000005.2 -0.15149043 ## 2: NP_000005.2 Mesenchymal-Immunoreactive NP_000005.2 0.05641954 ## 3: NP_000005.2 Differentiated-Immunoreactive NP_000005.2 -0.15057866 ## 4: NP_000007.1 Proliferative-Immunoreactive NP_000007.1 -0.24732121 ## 5: NP_000007.1 Mesenchymal-Immunoreactive NP_000007.1 -0.15789692 ## 6: NP_000007.1 Differentiated-Immunoreactive NP_000007.1 0.08496949 ## AveExpr t P.Value adj.P.Val B ## 1: -1.672939e-17 -0.6468898 0.5197231 0.8364999 -6.021610 ## 2: -1.672939e-17 0.2341331 0.8155341 0.9517088 -6.086486 ## 3: -1.672939e-17 -0.6342478 0.5278928 0.8414233 -5.607632 ## 4: -1.611154e-17 -1.4339934 0.1558248 0.5663793 -5.237105 ## 5: -1.611154e-17 -0.8897083 0.3765321 0.7594979 -5.733156 ## 6: -1.611154e-17 0.4859585 0.6284456 0.8846421 -5.683780 "],["p-value-histograms.html", "5.4 p-value Histograms", " 5.4 p-value Histograms hist(res3$P.Value, breaks = seq(0, 1, 0.05), main = &quot;Histogram of PLATINUM.STATUS ANOVA Results&quot;, xlab = &quot;p-value&quot;) The histogram is uniform, which means it is unlikely that any features will be significantly different between any two PLATINUM.STATUS groups after adjustment for multiple comparisons. Indeed, when we check with table(res3$adj.P.Val &lt; 0.05), none of the features pass the significance threshold after Benjamini-Hochberg (BH) adjustment. # Histogram faceted by contrast ggplot(res4) + geom_histogram(aes(x = P.Value), breaks = seq(0, 1, 0.05), color = &quot;black&quot;, fill = &quot;grey&quot;) + facet_wrap(vars(contrast)) + theme_bw() Based on the unadjusted p-values, it appears that there are more features that are significantly different between the Proliferative vs. Immunoreactive comparison than the other two comparisons. We can create a table of the number of features with adjusted p-values less than 0.05 in each comparison with the table function. table(res4$contrast, res4$adj.P.Val &lt; 0.05) ## ## FALSE TRUE ## Differentiated-Immunoreactive 8056 47 ## Mesenchymal-Immunoreactive 7912 191 ## Proliferative-Immunoreactive 7855 248 "],["volcano-plots.html", "5.5 Volcano Plots", " 5.5 Volcano Plots # Basic volcano plot plot_volcano(df = res4, logFC = &quot;logFC&quot;, pvals = &quot;adj.P.Val&quot;, sig_threshold = 0.05) + facet_wrap(vars(contrast)) + labs(y = &quot;BH-adjusted p-value&quot;) It looks like there are more features that are significantly lower in the Proliferative group compared to the Immunoreactive group than there are features that are significantly higher. The Differentiated group appears to behave similarly, though with fewer features passing the significance cutoff of 0.05. Below is an example of how to color points based on sign of the fold-change and whether they are significant. # Top 4 most significant features in each contrast feature_labels &lt;- res4 %&gt;% group_by(contrast) %&gt;% slice_min(order_by = adj.P.Val, n = 4, with_ties = FALSE) %&gt;% mutate(feature_label = feature) res4 &lt;- res4 %&gt;% # Label 5 most significant features in each comparison group left_join(feature_labels) %&gt;% # Determine point colors based on significance and sign(logFC) mutate(point_color = case_when( adj.P.Val &lt; 0.05 &amp; logFC &lt; 0 ~ &quot;down&quot;, adj.P.Val &lt; 0.05 &amp; logFC &gt; 0 ~ &quot;up&quot;, TRUE ~ &quot;NS&quot;), point_color_sub = ifelse(!is.na(feature_label), point_color, NA)) # Color points v1 &lt;- plot_volcano(df = res4, logFC = &quot;logFC&quot;, pvals = &quot;adj.P.Val&quot;, sig_threshold = 0.05, point_args = list(mapping = aes(color = point_color))) + facet_wrap(vars(contrast)) v1 # Change colors - do not include &quot;NS&quot; v1 + scale_color_manual(values = c(&quot;#5555ff&quot;, &quot;red3&quot;, NA), breaks = c(&quot;down&quot;, &quot;up&quot;, &quot;NS&quot;), limits = c(&quot;down&quot;, &quot;up&quot;), na.value = &quot;lightgrey&quot;) + theme(legend.position = &quot;none&quot;) # do not show legend # Label top 4 significant features in each contrast plot_volcano(df = res4, logFC = &quot;logFC&quot;, pvals = &quot;adj.P.Val&quot;, sig_threshold = 0.05, label = &quot;feature_label&quot;, num_features = nrow(res4), # Change point and label color label_args = list(mapping = aes(color = point_color), size = 2.5, box.padding = 0.75, force_pull = 0, seed = 99), point_args = list(mapping = aes(color = point_color), alpha = 0.5)) + facet_wrap(vars(contrast)) + # Point colors scale_color_manual(values = c(&quot;#5555ff&quot;, &quot;red3&quot;, NA), breaks = c(&quot;down&quot;, &quot;up&quot;, &quot;NS&quot;), limits = c(&quot;down&quot;, &quot;up&quot;), na.value = &quot;lightgrey&quot;) + theme_bw() + theme(legend.position = &quot;none&quot;) # do not show legend "],["pathway-analysis.html", "Section 6 Pathway Analysis", " Section 6 Pathway Analysis In Section 5, we covered analysis at the individual feature level (protein, peptide, phosphoprotein, etc.). While DEA is useful, it is not without its own set of shortcomings. For instance, there may be no features that pass the significance threshold after correcting for multiple hypothesis testing. Alternatively, there may be many features that are statistically significant, and interpreting this list can be tedious and prone to investigator bias toward a hypothesis of interest (Maleki et al., 2020). Another issue is that single-feature analysis fails to detect subtle, yet coordinated changes in groups of related features (Subramanian et al., 2005). In order to address these, and other, issues, pathway analysis instead examines a priori defined gene setsgroups of genes that participate in the same biological pathway, share the same cellular location, etc. In this section, we will explore some common annotation databases, as well as two pathway analysis methods: Over-Representation Analysis (ORA) and Gene Set Enrichment Analysis (GSEA). References "],["annotation-databases.html", "6.1 Annotation Databases", " 6.1 Annotation Databases In this section, we will explore some of the common annotation databases used for pathway analysis. 6.1.1 Gene Ontology The Gene Ontology (GO) database is divided into three separate domains: Biological Process, Cellular Component, and Molecular Function (see the Gene Ontology overview for more details regarding each domain). Each domain is structured as a directed acyclic graph (DAG) where nodes are terms and edges are the relations between the terms (part of, is a, has part, regulates). Nodes can be connected to multiple child and parent nodes, where the group of genes annotated to a child node is a subset of those that are annotated to its parent node(s) (2021; Goeman et al., 2008). 6.1.1.1 Semantic Similarity Due to the DAG structure of each domain, there is often redundancy in pathway analysis results. For example, suppose terms GO:0006119, GO:0009060, and GO:0046034 are significantly over-represented biological processes. GO:0009060 and GO:0046034 are the parent terms of GO:0006119. Due to this relationship, the terms likely provide much of the same information, so the inclusion of all three terms in the output is unnecessary. In order to resolve this redundancy, we can calculate the semantic similarity between pairs of GO terms, which assesses the likeness in meaning of two concepts (Pesquita, 2017). Basically, if two terms are highly related, we can use some other criteria (such as adjusted p-value or level in the DAG) to retain only one of the terms. Below, we use the GOSemSim package to calculate the semantic similarity between the terms. ## Calculate semantic similarity between GO terms library(GOSemSim) library(org.Hs.eg.db) # GO DATA for measuring semantic similarity. # keytype is &quot;ENTREZID&quot; by default and # information content is calculated (computeIC = TRUE) semData &lt;- godata(OrgDb = &quot;org.Hs.eg.db&quot;, ont = &quot;BP&quot;) terms &lt;- c(&quot;GO:0006119&quot;, &quot;GO:0009060&quot;, &quot;GO:0046034&quot;) # measure = &quot;Rel&quot; is the default for clusterProfiler::simplify # See code for clusterProfiler:::simplify_internal sim &lt;- mgoSim(GO1 = terms, GO2 = terms, semData = semData, measure = &quot;Rel&quot;, combine = NULL) Table 6.1: Semantic Similarity of select GO terms GO:0006119 GO:0009060 GO:0046034 GO:0006119 0.998 0.754 0.936 GO:0009060 0.754 0.999 0.128 GO:0046034 0.936 0.128 0.997 If measure is \"Lin\", \"Jiang\", or \"Wang\", the semantic similarity of a term with itself will be 1. This is not true for the other methods. We can see from Table 6.1 that GO:0009060 and GO:0046034 have low semantic similarity, while GO:0006119 is highly similar to its parent terms. This makes sense because the parent terms are not related/connected in the DAG. Now that we have the semantic similarities, we can remove redundant terms. clusterProfiler has a function called simplify that will calculate semantic similarity and remove terms. By default, if there are two terms with a semantic similarity greater than 0.7, simplify retains the term with the lowest adjusted p-value. See this post by Guangchuang Yu for more details on clusterProfiler::simplify. 6.1.1.2 GO Subsets/Slims Another way to handle the redundancy of GO terms is to use a GO slim, which is a subset of more general or research-relevant terms from the GO. GO slims can be downloaded or the biomaRt package can be used to access GO slim accessions. ## Create human GO slim library(biomaRt) library(clusterProfiler) # gcSample data library(dplyr) mart &lt;- useMart(biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) # Uncomment to determine which attributes to select in getBM() # View(listAttributes(mart)) # The GO slim columns are goslim_goa_accession and goslim_goa_description. # We will map from the Entrez IDs in gcSample to these attributes. data(gcSample) universe &lt;- unique(unlist(gcSample)) GO_slim &lt;- getBM(filters = &quot;entrezgene_id&quot;, attributes = c(&quot;entrezgene_id&quot;, &quot;goslim_goa_accession&quot;, &quot;goslim_goa_description&quot;), values = universe, # Subset to these Entrez IDs mart = mart) %&gt;% # Convert entrezgene_id from integer to character mutate_all(as.character) entrezgene_id goslim_goa_accession goslim_goa_description 100 GO:0003674 molecular_function 100 GO:0016810 hydrolase activity, acting on carbon-nitrogen (but not peptide) bonds 100 GO:0008150 biological_process 100 GO:0009058 biosynthetic process 100 GO:0044281 small molecule metabolic process 100 GO:0034641 cellular nitrogen compound metabolic process Unfortunately, not every GO accession maps to a domain when we use biomaRt (unsure why this is the case), so we wont be able to separate the terms. However, there are two ways that we can still use these GO slim accessions. Either follow the steps for using clusterProfiler::enricher (shown in the Pfam subsection of Section 6.2.2) with conversion tables created from org.Hs.eg.db that have been subset to the GO slim accessions, or remove any non GO slim accessions from the final results and readjust the remaining p-values (the easier approach). 6.1.2 Reactome Home - Reactome Pathway Database 6.1.3 KEGG KEGG: Kyoto Encyclopedia of Genes and Genomes 6.1.4 Pfam Pfam: Home page Pfam Documentation profile Hidden Markov Models References "],["ora.html", "6.2 Over-Representation Analysis", " 6.2 Over-Representation Analysis 6.2.1 Overview Over-Representation Analysis (ORA) is used to determine which a priori defined gene sets are more present (over-represented) in a subset of interesting genes than what would be expected by chance (Huang et al., 2009). Essentially, it identifies the gene setsrather than the individual genesthat are significantly different between two conditions. For each gene set, an enrichment p-value is calculated using the Binomial distribution, Hypergeometric distribution, the Fisher exact test, or the Chi-square test. Although this list is not all-encompassing, these are the most popular statistical methods (Huang et al., 2009). Below is the formula for calculating the enrichment p-value for a particular gene set using the Hypergeometric distribution. \\[ P(X\\geq x) = 1 - P(X \\leq x-1) = 1 - \\sum\\limits_{i=0}^{x-1}\\frac{\\hphantom{}{M \\choose i }{N - M \\choose n-i}}{N \\choose n} \\] In this equation, \\(N\\) is the number of background genes, \\(n\\) is the number of interesting (i.e. statistically-significant) genes, \\(M\\) is the number of genes that are annotated to a particular gene set \\(S\\), and \\(x\\) is the number of interesting genes that are annotated to \\(S\\). The numerator of the sum is the number of samples of \\(n\\) genes that can be taken from a population of \\(N\\) genes where exactly \\(i\\) of the genes are annotated to \\(S\\) and \\(n-i\\) are not annotated to \\(S\\). The denominator of the sum is the total number of samples of size \\(n\\) that can be taken from a population of size \\(N\\). For example, suppose we have a list of 8000 genes, of which 400 are differentially expressed. Also suppose that 100 of the 8000 genes are annotated to a particular gene set \\(S\\). Of these 100 genes, 20 are differentially expressed. The probability that 20 or more (up to 100) genes annotated to \\(S\\) are differentially expressed by chance is given by \\[ P(X\\geq 20) = 1 - P(X \\leq 19) = 1-\\sum \\limits_{i=0}^{19}\\frac{\\hphantom{}{100 \\choose i}{8000 - 100 \\choose 400-i}}{8000 \\choose 400} = 7.88 \\times 10^{-8} \\] That is, it is extremely unlikely that 20 of the 100 genes from this set are significantly differentially expressed by chance (at least, prior to adjustment for multiple comparisons). The code to calculate this p-value is phyper(q = 20 - 1, m = 400, n = 8000 - 400, k = 100, lower.tail = FALSE) After a p-value has been calculated for each of the applicable gene sets, a multiple comparison adjustment should be performed. Important Considerations The choice of the threshold for statistical significance and the multiple comparison adjustment method can greatly impact the analysis (Huang et al., 2009). ORA fails to incorporate direction of gene regulation. (Are the genes in a given set mainly up or down-regulated?). It is not a good idea to split DEA results by the sign of the logFC and apply ORA to the two sets. Use GSEA instead. If few genes are differentially expressed, ORA may not yield useful or reliable results. For example, suppose 30 out of 8000 genes are significant. 100 of the genes are annotated to a particular gene set, of which 3 are significant. The associated Hypergeometric p-value is 0.006, and this set would be considered significantly over-represented at the 0.01 level (at least, prior to adjustment for multiple comparisons); however, if only 2 of the genes in this set are significant, this p-value increases 10-fold to 0.0536 and is no longer significant even at the 0.05 level. If the DEA results are not gene-centric (i.e. DEA was performed at the protein or phosphosite level), then there may be cases where two proteins are associated with the same gene, but only one is significantly differentially abundant. In this case, there is no way to categorize the gene as significant or not, so ORA should not be used. The other problem that could arise if the DEA results are not gene-centric is that the same gene may be counted as significant multiple times, which leads to artificial over-representation. In these cases, GSEA may be a good alternative. 6.2.2 Examples For these examples, we will show how to perform ORA with the GOstats, clusterProfiler, and ReactomePA packages. The databases that we will cover are Gene Ontology, Reactome, and Pfam. For details on these different annotation databases, please see Section 6.1. ## Setup # Required packages library(clusterProfiler) # GO, KEGG, and custom ORA library(ReactomePA) # Reactome ORA library(GOstats) # GO, KEGG, and Pfam ORA library(PFAM.db) # Map Pfam IDs to descriptions library(org.Hs.eg.db) # Human annotation database library(kableExtra) library(dplyr) Normally, we would use a DEA table to create two character vectors: one for the significantly expressed genes and the other for all genes that were tested (referred to as the background or universe); instead, we will use the gcSample data that comes with clusterProfiler and treat the eighth cluster as our vector of significant genes and the entire list as the gene universe. Each gene is represented by a human Entrez gene ID, which is the default keytype used by the clusterProfiler functions (and the only keytype compatible with ReactomePA::enrichPathway). data(&quot;gcSample&quot;) # Data for examples sig_genes &lt;- gcSample[[8]] # significant genes universe &lt;- unique(unlist(gcSample)) # universe It is important to note that the genes should be unique from the start. The terms between any two clusters of gcSample may overlap, so we must use unique for the sake of these examples. If your DEA results are not gene-centric, do NOT use ORA. Instead, switch to GSEA and summarize the ranking metric in some way to make it gene-centric (i.e. take the average, min, max, etc. of the metrics for each gene group). 6.2.2.1 Gene Ontology We will first use the clusterProfiler package to test which biological processes are over-represented in the set of interesting genes. For this example, we will only consider gene sets of size 20 to 500. In order to test either molecular functions, cellular components, or all three ontologies at once, set ont to \"MF\", \"CC\", or \"ALL\", respectively. ## GO BP ORA with clusterProfiler # This takes a while cp_ora_go &lt;- enrichGO( gene = sig_genes, OrgDb = &quot;org.Hs.eg.db&quot;, keyType = &quot;ENTREZID&quot;, ont = &quot;BP&quot;, # BP, CC, MF, or ALL for all ontologies pvalueCutoff = 0.05, qvalueCutoff = 1, # Do not filter by q-value pAdjustMethod = &quot;BH&quot;, universe = universe, minGSSize = 20, maxGSSize = 500, readable = TRUE # Convert Entrez ID to gene symbol ) Table 6.2: Top significantly over-represented biological processes from enrichGO output. ID Description GeneRatio BgRatio pvalue p.adjust geneID GO:0046034 ATP metabolic process 24/232 96/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0006119 oxidative phosphorylation 16/232 49/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0006402 mRNA catabolic process 22/232 93/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:1902600 proton transmembrane transport 12/232 28/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0016071 mRNA metabolic process 35/232 208/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:0006091 generation of precursor metabolites and energy 29/232 159/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0009060 aerobic respiration 12/232 32/3652 0 1e-04 COX4I1/MDH1/HIF1A GO:0006401 RNA catabolic process 22/232 104/3652 0 1e-04 HNRNPU/YWHAZ/RPL13A GO:0010608 posttranscriptional regulation of gene expression 28/232 168/3652 0 3e-04 HNRNPU/MATR3/YWHAZ GO:0042773 ATP synthesis coupled electron transport 11/232 31/3652 0 3e-04 COX4I1/COX8A/COX7C There were 4436 biological processes that were tested. Of these, 2049 passed the size filter, and only 182 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 6.2. Remove Redundant GO Terms By default, if two terms have a semantic similarity above 0.7, clusterProfiler::simplify retains the more significantly over-represented term. # Remove redundant GO terms with simplify cp_ora_go_sim &lt;- simplify(cp_ora_go) Table 6.3: Simplified top significantly over-represented biological processes from enrichGO output. ID Description GeneRatio BgRatio pvalue p.adjust geneID GO:0046034 ATP metabolic process 24/232 96/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0006119 oxidative phosphorylation 16/232 49/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0006402 mRNA catabolic process 22/232 93/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:1902600 proton transmembrane transport 12/232 28/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0016071 mRNA metabolic process 35/232 208/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:0006091 generation of precursor metabolites and energy 29/232 159/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0010608 posttranscriptional regulation of gene expression 28/232 168/3652 0 3e-04 HNRNPU/MATR3/YWHAZ GO:0009205 purine ribonucleoside triphosphate metabolic process 9/232 21/3652 0 4e-04 RAN/ENO1/ATP5F1B GO:0034097 response to cytokine 45/232 357/3652 0 4e-04 HNRNPU/YWHAZ/SLC25A5 GO:0071345 cellular response to cytokine stimulus 42/232 325/3652 0 4e-04 HNRNPU/YWHAZ/SLC25A5 Notice that GO:0009060 is not present in Table 6.3 anymore, since it was highly similar to GO:0006119, and the latter was more significant. After removing redundant GO terms, 95 pass the significance threshold. Instead of retaining terms based on adjusted p-value, we could ignore significance and instead retain either parent or child terms (select_fun = min and select_fun = max, respectively). The code to do so is provided here. Another alternative would be to use a gene ID to GO slim ID conversion table. See the Semantic Similarity subsection of Section 6.1 for more details. Now, we will perform GO ORA with the GOstats package. We begin by creating an object of class GOHyperGParams and passing it to hyperGTest for calculation of Hypergeometric p-values. We do not filter by p-value, since adjusted p-values are not provided and we must calculate them ourselves. ## GO BP ORA with GOstats hyperg_ora_go &lt;- new( Class = &quot;GOHyperGParams&quot;, ontology = &quot;BP&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, # Do not filter by p-value testDirection = &quot;over&quot;, conditional = FALSE ) %&gt;% hyperGTest() # Hypergeometric testing Now, we need to filter by gene set size (limit 20 to 500), adjust the p-values, and filter based on the adjusted p-values. res_go_ora &lt;- summary(hyperg_ora_go) %&gt;% # Filter by size filter(Size &gt;= 20, Size &lt;= 500) %&gt;% # Adjust p-values mutate(p.adjust = p.adjust(Pvalue, method = &quot;BH&quot;)) %&gt;% # Filter and sort by adjusted p-values arrange(p.adjust) %&gt;% filter(p.adjust &lt; 0.05) Table 6.4: Over-represented biological processes obtained using the GOstats package. GOBPID Term OddsRatio ExpCount Count Size Pvalue p.adjust GO:0046034 ATP metabolic process 5.3654 6.0986 24 96 0 0e+00 GO:0006119 oxidative phosphorylation 7.6027 3.1128 16 49 0 0e+00 GO:0006402 mRNA catabolic process 4.9415 5.9080 22 93 0 0e+00 GO:1902600 proton transmembrane transport 11.6045 1.7788 12 28 0 0e+00 GO:0016071 mRNA metabolic process 3.3346 13.2136 35 208 0 0e+00 GO:0006091 generation of precursor metabolites and energy 3.6154 10.1008 29 159 0 0e+00 GO:0009060 aerobic respiration 9.2727 2.0329 12 32 0 1e-04 GO:0006401 RNA catabolic process 4.2646 6.6068 22 104 0 1e-04 GO:0010608 posttranscriptional regulation of gene expression 3.2157 10.6725 28 168 0 3e-04 GO:0042773 ATP synthesis coupled electron transport 8.4615 1.9693 11 31 0 3e-04 There were 4435 biological processes that were tested. Of these, 2049 passed the size filter, and only 182 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 6.4. The total number of biological processes that were tested is 1 less than the number reported from the enrichGO results. This is because enrichGO includes the biological_process root GO:0008150. Remove Redundant GO Terms While there is no function akin to clusterProfiler::simplify to process results, there is an argument called conditional. Setting conditional to TRUE tells hyperGTest to use the term-term relationships when calculating p-values (Falcon et al., 2021). This approach is actually more akin to Modular Enrichment Analysis (MEA) than Over-Representation Analysis (also called Singular Enrichment Analysis; Huang et al. (2009)). ## Conditional GO BP ORA with GOstats hyperg_ora_go_sim &lt;- new( Class = &quot;GOHyperGParams&quot;, ontology = &quot;BP&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, # Do not filter by p-value testDirection = &quot;over&quot;, conditional = TRUE # Use structure of GO graph ) %&gt;% hyperGTest() # Hypergeometric testing We will process the results the same as before and compare. Table 6.5: Simplified over-represented biological processes obtained using the GOstats package. GOBPID Term OddsRatio ExpCount Count Size Pvalue p.adjust GO:0046034 ATP metabolic process 7.4290 2.3261 12 38 0e+00 0.0011 GO:0042773 ATP synthesis coupled electron transport 8.4615 1.9693 11 31 0e+00 0.0011 GO:0043043 peptide biosynthetic process 3.2288 9.0208 24 142 0e+00 0.0028 GO:0046364 monosaccharide biosynthetic process 6.7593 2.2870 11 36 0e+00 0.0028 GO:0009145 purine nucleoside triphosphate biosynthetic process 10.1429 1.2705 8 20 0e+00 0.0044 GO:0009201 ribonucleoside triphosphate biosynthetic process 8.6888 1.3976 8 22 0e+00 0.0083 GO:0006094 gluconeogenesis 6.5618 1.8981 9 30 1e-04 0.0127 GO:0009141 nucleoside triphosphate metabolic process 6.2336 1.9693 9 31 1e-04 0.0130 GO:0034655 nucleobase-containing compound catabolic process 2.8081 9.2114 22 145 1e-04 0.0130 GO:0048002 antigen processing and presentation of peptide antigen 3.8578 4.4469 14 70 1e-04 0.0130 Now, only 2953 terms showed up in the summary. Of these, 1445 passed the size filter, and 31 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 6.5. The major difference between these results and the ones from enrichGO after using simplify is that p-value adjustment is not affected by simplify, as redundant GO terms are removed after. The conditional method is actually more akin to performing modular enrichment analysis (MEA) than ORA (also called singular enrichment analysis) 6.2.2.2 Reactome GOstats does not have a dedicated class to test for Reactome pathway over-representation, but we can use ReactomePA. For this example, we will only consider pathways of size 20 to 500. enrichPathway only accepts Entrez gene IDs as input. In cases where the Entrez ID is not readily available, we must convert to them. Alternatively, we could use the custom ORA function enricher, which allows us to use any ID type (use demonstrated in Pfam example). ## Reactome ORA with ReactomePA cp_ora_reactome &lt;- enrichPathway( gene = sig_genes, organism = &quot;human&quot;, pvalueCutoff = 0.05, pAdjustMethod = &quot;BH&quot;, qvalueCutoff = 1, # Do not filter by q-value universe = universe, minGSSize = 20, maxGSSize = 500, readable = TRUE # Convert Entrez ID to gene symbol ) Table 6.6: Top significantly over-represented Reactome pathways from enrichPathway output. ID Description GeneRatio BgRatio pvalue p.adjust geneID R-HSA-8953897 Cellular responses to external stimuli 39/193 185/2548 0 0e+00 COX4I1/RPL13A/SKP1 R-HSA-2262752 Cellular responses to stress 37/193 181/2548 0 0e+00 COX4I1/RPL13A/SKP1 R-HSA-163200 Respiratory electron transport, ATP synthesis by chemiosmotic coupling, and heat production by uncoupling proteins. 15/193 37/2548 0 0e+00 COX4I1/COX8A/COX7C R-HSA-5663205 Infectious disease 38/193 212/2548 0 0e+00 PRKAR1A/SLC25A5/RPL13A R-HSA-9711123 Cellular response to chemical stress 18/193 61/2548 0 0e+00 COX4I1/SKP1/PSMB7 R-HSA-9707564 Cytoprotection by HMOX1 16/193 50/2548 0 0e+00 COX4I1/SKP1/PSMB7 R-HSA-1428517 The citric acid (TCA) cycle and respiratory electron transport 17/193 57/2548 0 0e+00 COX4I1/LDHB/COX8A R-HSA-72766 Translation 17/193 58/2548 0 0e+00 RPL13A/RPL29/KARS1 R-HSA-5628897 TP53 Regulates Metabolic Genes 12/193 34/2548 0 1e-04 COX4I1/YWHAZ/YWHAQ R-HSA-8953854 Metabolism of RNA 31/193 181/2548 0 3e-04 HNRNPU/YWHAZ/RPL13A There were 919 Reactome pathways that were tested. Of these, 388 passed the size filter, and 155 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 6.6. 6.2.2.3 Pfam Now, we will perform Pfam ORA with the GOstats package. We begin by constructing a new object of class PFAMHyperGParams and then passing it to hyperGTest for calculation of Hypergeometric p-values. We do not filter by p-value, since adjusted p-values are not provided and we must calculate them ourselves. ## Pfam ORA with GOstats hyperg_pfam_ora &lt;- new( Class = &quot;PFAMHyperGParams&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, testDirection = &quot;over&quot; ) %&gt;% hyperGTest() # Hypergeometric testing Now, we need to filter by gene set size (limit 15 to 500) and adjust the p-values. Normally, we would also filter based on the adjusted p-values, but we will skip this step so that we can compare the output with that of clusterProfiler::enricher. res_pfam_ora &lt;- summary(hyperg_pfam_ora) %&gt;% # Filter by Pfam entry size filter(Size &gt;= 15, Size &lt;= 500) %&gt;% # Adjust p-values mutate(p.adjust = p.adjust(Pvalue, method = &quot;BH&quot;)) %&gt;% # Sort by adjusted p-values arrange(p.adjust) Table 6.7: Top Pfam entries obtained using the GOstats package. PFAMID OddsRatio ExpCount Count Size Pvalue p.adjust PF01391 4.5163 1.9368 7 30 0.0024 0.0530 PF00076 2.1478 3.5509 7 55 0.0613 0.4980 PF00092 3.6568 0.9684 3 15 0.0679 0.4980 PF00071 2.1888 1.4849 3 23 0.1824 0.8976 PF07679 1.9016 1.6786 3 26 0.2338 0.8976 PF13499 1.8182 1.1621 2 18 0.3256 0.8976 PF00271 1.3200 1.5495 2 24 0.4652 0.8976 PF00412 1.3200 1.5495 2 24 0.4652 0.8976 PF13855 1.1458 2.6470 3 41 0.4995 0.8976 PF00595 1.2092 1.6786 2 26 0.5079 0.8976 260 Pfam entries were tested. Of these, 16 passed the size filter, and none were significantly over-represented after multiple testing correction. The top 10 are shown in Table 6.7. 6.2.2.4 Other Databases For databases without a dedicated ORA function, we use clusterProfiler::enricher, which is a general ORA function that can be used with any term to gene conversion table. This function is also much faster than the dedicated enrichGO and enrichPathway functions (since the conversion table does not need to be fetched), so it may be preferred if running many separate over-representation analyses. NOTE: The term to gene conversion table must have exactly two columns: term and gene. They must also be in that exact order! For this example, we will perform Pfam ORA. The conversion table can be generated with the biomaRt package as follows. library(biomaRt) mart &lt;- useMart(biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) View(listAttributes(mart)) # Determine which columns to return TERM2GENE &lt;- getBM(filters = &quot;entrezgene_id&quot;, attributes = c(&quot;entrezgene_id&quot;, &quot;pfam&quot;), values = universe, mart = mart) %&gt;% mutate_all(as.character) %&gt;% # !!! These specific column names must be in this exact order dplyr::select(term = pfam, gene = entrezgene_id) %&gt;% dplyr::filter(term != &quot;&quot;) # remove empty terms In addition to the required term to gene conversion table, we can supply an optional term to name table that maps Pfam IDs to human-readable descriptions. While org.Hs.eg.db does not provide Pfam descriptions, the PFAM.db annotation data package has a Bimap with this information. Like the TERM2GENE table, name and order of columns matters. library(PFAM.db) # Pfam IDs to descriptions TERM2NAME &lt;- as.data.frame.Bimap(PFAMDE) %&gt;% # !!! These specific column names must be used in this exact order setNames(c(&quot;term&quot;, &quot;name&quot;)) Now that we have the two conversion tables, we will perform ORA and limit the output to Pfam entries of size 15 to 500. # Pfam ORA with clusterProfiler cp_ora_pfam &lt;- enricher( gene = sig_genes, pvalueCutoff = 0.05, pAdjustMethod = &quot;BH&quot;, universe = universe, minGSSize = 15, maxGSSize = 500, qvalueCutoff = 1, TERM2GENE = TERM2GENE, TERM2NAME = TERM2NAME ) Table 6.8: Top Pfam entries from enricher output. ID Description GeneRatio BgRatio pvalue p.adjust geneID PF01391 Collagen triple helix repeat (20 copies) 7/236 31/3676 0.0029 0.0686 1293/1281/1277 PF00076 RNA recognition motif. (a.k.a. RRM, RBD, or RNP domain) 7/236 55/3676 0.0598 0.5360 1153/3182/5042 PF00092 von Willebrand factor type A domain 3/236 15/3676 0.0670 0.5360 1293/1292/1291 PF00071 Ras family 3/236 23/3676 0.1803 0.9021 5901/6009/388 PF07679 Immunoglobulin I-set domain 3/236 27/3676 0.2488 0.9021 23022/3490/25878 PF13499 EF-hand domain pair 2/236 20/3676 0.3710 0.9021 6717/80303 PF00271 Helicase conserved C-terminal domain 2/236 24/3676 0.4622 0.9021 1973/10521 PF00412 LIM domain 2/236 24/3676 0.4622 0.9021 1396/9124 PF13855 Leucine rich repeat 3/236 42/3676 0.5121 0.9021 4060/1634/25878 PF00046 Homeodomain 2/236 27/3676 0.5253 0.9021 5087/29956 There were 275 Pfam entries that were tested. Of these, 24 passed the size filter, and 0 were significantly over-represented after multiple testing correction. While none were significant, the top 10 are shown in Table 6.8. Notice that this table and Table 6.7 are different. For one, the sizes of the entries are not always the same. For example, PF01391 has size 31 according to the mapping file created from the biomaRt package, but only size 30 according to org.Hs.eg.db (used by GOstats). This has to do with how up-to-date the information is and leads to differences in the number of total Pfam entries that remain after filtering by size and, subsequently, differences in the adjusted p-values. References "],["gsea.html", "6.3 Gene Set Enrichment Analysis", " 6.3 Gene Set Enrichment Analysis 6.3.1 Overview Gene Set Enrichment Analysis (GSEA) employs a no-cutoff strategy that utilizes some experimental value (such as fold change, the moderated t-statistic, or Z-Score) to rank a list of \\(N\\) genes in descending order. Using this ranked list \\(L\\), the values of the ranking metric, and an a priori defined gene set \\(S\\), we can calculate an enrichment score. This is done by walking down the list \\(L\\), increasing a running-sum statistic when we encounter a gene in \\(S\\) and decreasing it when we encounter genes not in \\(S\\). The maximum deviation from zero of this running-sum statistic is the enrichment score for \\(S\\), denoted by \\(ES(S)\\). If the genes in \\(S\\) are randomly distributed throughout \\(L\\), \\(ES(S)\\) will be relatively small; however, if they are not randomly distributed (i.e. primarily located near either end of \\(L\\)), then \\(ES(S)\\) will be relatively large (Mootha et al., 2003; Subramanian et al., 2005). To assess the statistical significance of each \\(ES(S)\\), we permute the phenotype labels in the expression data and recalculate the ranking metric and subsequent enrichment score \\(ES_{\\text{NULL}}\\). Alternatively, we could permute the genes: for a given \\(S\\) of size \\(k\\), we randomly select \\(k\\) genes from the list \\(L\\) and calculate an enrichment score \\(ES_{\\text{NULL}}\\). This is the method implemented by fgsea and, consequently, clusterProfiler, though it is not strictly accurate because it does not preserve the correlations between genes (Subramanian et al., 2005). Regardless of the permutation approach, it is repeated one thousand to tens of thousands of times to produce an empirical null distribution. Then, we define the nominal p-value as the proportion of \\(ES_{\\text{NULL}}\\) that are more extreme than \\(ES(S)\\). Once a p-value has been obtained for every gene set, we apply an appropriate adjustment for multiple hypothesis testing. The phenotype randomization approach is summarized in Figure 1: Schematic overview of GSEA in the paper by Mootha et al. (2003). The mathematical details of GSEA are provided below. Let \\(x = \\{x_1, ..., x_N : x_i &gt; x_j \\ \\forall i &lt; j\\}\\) be the vector of ranking metric values. Also let \\(S\\) be a particular gene set of size \\(k\\) and \\(NS = \\sum\\limits_{i \\in S}|x_i|\\). We define the value of the running sum at gene \\(i\\) as \\[ r_i = \\begin{cases} 0 &amp; \\text{if } i = 0, \\\\ r_{i-1} + \\frac{1}{NS}|x_i| &amp; \\text{if } 1 \\leq i \\leq N \\text{ and } i \\in S, \\\\ r_{i-1} - \\frac{1}{N-k} &amp; \\text{if } 1 \\leq i \\leq N \\text{ and } i \\not\\in S \\end{cases} \\] \\(ES(S)\\) is the largest (in terms of absolute value) element of \\(r_N\\). This notation is a slightly modified version of what is presented in the paper by Korotkevich et al. (2016). Important Considerations GSEA is not influenced by an arbitrary cutoff for statistical significance. This is especially useful when only a few features pass this threshold after adjustment for multiple testing, and it also means that it does not depend on the choice of p-value adjustment. All genes in an experiment are allowed to contribute to the enrichment analysis in differing degrees (Huang et al., 2009). This addresses the point brought up at the beginning of Section 6 that biological changes may be the result of small changes in many related genes. GSEA allows for the detection of such changes. The sign of the enrichment score tell us in which category a set of genes is primarily up- or down-regulated. For example, suppose we test the difference between the means of two groups for each gene using the limma package. Since ranking metrics incorporate the direction of change, a positive enrichment score would mean that the majority of genes in that particular set are up-regulated in A relative to B/down-regulated in B relative to A. The choice of ranking metric is important: -log10(p-value) * sign(logFC), -log10(p-value) * logFC, t-statistics, and Z-Scores are just a few possible choices. 6.3.2 Examples library(MSnID) # fetch_conversion_table library(MSnSet.utils) # oca.set data library(org.Hs.eg.db) # Human database package library(clusterProfiler) # GO and custom GSEA library(ReactomePA) # Reactome GSEA library(dplyr) data(cptac_oca) # data m &lt;- oca.set The input for the GSEA functions is a named vector of ranking metric values (t-statistics, F-statistics, -log10(p-value) * sign(logFC), etc.) where the names are typically unique Entrez gene IDs. We need to go from an MSnSet to differential analysis results to this named vector. First, we will get the Entrez IDs for each RefSeq and add this as a column in fData. # Get RefSeq to Entrez ID conversion table conv_tbl &lt;- fetch_conversion_table(organism_name = &quot;Homo sapiens&quot;, from = &quot;REFSEQ&quot;, to = &quot;ENTREZID&quot;) %&gt;% setNames(c(&quot;RefSeq_no_iso&quot;, &quot;entrez_gene&quot;)) # rename columns head(conv_tbl) ## RefSeq_no_iso entrez_gene ## 1 NP_570602 1 ## 2 NP_000005 2 ## 3 NP_001334352 2 ## 4 NP_001334353 2 ## 5 NP_001334354 2 ## 6 XP_006719119 2 # Add RefSeq_no_iso and entrez_gene columns to fData(m) fData(m) &lt;- mutate(fData(m), # Remove isoform number from RefSeq RefSeq_no_iso = gsub(&quot;(.*)\\\\.\\\\d{+}&quot;, &quot;\\\\1&quot;, RefSeq)) %&gt;% # Add entrez_gene column left_join(conv_tbl, by = &quot;RefSeq_no_iso&quot;) %&gt;% # Set rownames to RefSeq column {rownames(.) &lt;- .[[&quot;RefSeq&quot;]]; .} head(fData(m)) ## RefSeq RefSeq_no_iso entrez_gene ## NP_000005.2 NP_000005.2 NP_000005 2 ## NP_000007.1 NP_000007.1 NP_000007 34 ## NP_000008.1 NP_000008.1 NP_000008 35 ## NP_000009.1 NP_000009.1 NP_000009 37 ## NP_000010.1 NP_000010.1 NP_000010 38 ## NP_000012.1 NP_000012.1 NP_000012 5663 Not every RefSeq mapped to an Entrez gene. We will not be able to use these features, and the code below shows how many were mapped/not mapped. table(!is.na(fData(m)$entrez_gene)) ## ## FALSE TRUE ## 110 7993 110 proteins (~1.4% in table below) were not mapped to any gene. We will remove those rows. 100 * prop.table(table(!is.na(fData(m)$entrez_gene))) ## ## FALSE TRUE ## 1.357522 98.642478 Now that we have an Entrez ID column in the fData, we can move on to the next steps. I have combined all steps below so that the code is easier to copy. First, we need a table of differential analysis results. We combine it with the fData in order to include the Entrez gene column. From there, we subset to rows without any missing values. This removes proteins that did not map to a gene, as well as proteins with no test statistics or p-values. Then, we create a column for the ranking metric. We will use \\(-log10(\\text{p-value}) \\cdot sign(\\text{log}_2 \\text{ fold-change})\\). We could have also used the moderated t-statistic, which is similar (see Figure 6.1). Now, we need to make sure that there is only one value per gene. We do so by calculating the average ranking metric for each gene. The last step is to sort from high to low by ranking metric and convert to a named vector. We can see the first and last 6 entries of this named vector below. # Named vector for GSEA # Start with differential analysis results gsea_input &lt;- limma_gen(m, model.str = &quot;~ PLATINUM.STATUS&quot;, coef.str = &quot;PLATINUM.STATUS&quot;) %&gt;% mutate(RefSeq = rownames(.)) %&gt;% # Create RefSeq column left_join(fData(m), by = &quot;RefSeq&quot;) %&gt;% # Add columns from fData .[complete.cases(.), ] %&gt;% # Remove rows with any missing values # Create GSEA ranking metric column: signed -log10 p-value mutate(ranking_metric = -log10(P.Value) * sign(logFC)) %&gt;% # Average ranking metric for each gene group_by(entrez_gene) %&gt;% summarise(ranking_metric = mean(ranking_metric)) %&gt;% # Sort from high to low by ranking metric arrange(-ranking_metric) %&gt;% # Convert to named vector tibble::deframe() head(gsea_input) ## 1729 3696 10313 1738 23277 178 ## 3.714891 3.327848 3.303450 3.208326 2.908294 2.772761 tail(gsea_input) ## 79969 79977 4925 2953 10970 3486 ## -2.578652 -2.621050 -2.713811 -2.899121 -2.984474 -3.284757 Figure 6.1: Comparison of two common GSEA ranking metrics. Now that we have the input vector, we can move on to the examples. 6.3.2.1 Gene Ontology # Biological Process GSEA go_gsea &lt;- gseGO(geneList = gsea_input, ont = &quot;BP&quot;, eps = 0, OrgDb = org.Hs.eg.db, nPermSimple = 1000) # may need to increase nPermSimple Table 6.9: ID Description setSize enrichmentScore NES pvalue p.adjust qvalues rank leading_edge core_enrichment GO:0031424 keratinization 54 0.7794 2.7035 0 0 0 990 tags=61%, list=13%, signal=54% 3855/3860/121391 GO:0070268 cornification 50 0.7820 2.6888 0 0 0 990 tags=64%, list=13%, signal=56% 3855/3860/121391 GO:0046034 ATP metabolic process 234 0.5070 2.2250 0 0 0 1753 tags=41%, list=23%, signal=33% 1738/64802/11315 GO:0007005 mitochondrion organization 370 0.4318 1.9836 0 0 0 1530 tags=35%, list=20%, signal=30% 23277/54927/9141 GO:0006119 oxidative phosphorylation 112 0.6049 2.4078 0 0 0 1916 tags=54%, list=25%, signal=41% 1738/11315/1340 GO:0045229 external encapsulating structure organization 225 -0.4919 -2.1088 0 0 0 1624 tags=46%, list=21%, signal=37% 780/9510/3687 GO:0007007 inner mitochondrial membrane organization 47 0.7458 2.5613 0 0 0 1450 tags=72%, list=19%, signal=59% 54927/10989/55735 GO:0030198 extracellular matrix organization 224 -0.4933 -2.1138 0 0 0 1624 tags=46%, list=21%, signal=37% 780/9510/3687 GO:0043062 extracellular structure organization 224 -0.4933 -2.1138 0 0 0 1624 tags=46%, list=21%, signal=37% 780/9510/3687 GO:0045333 cellular respiration 146 0.5398 2.2240 0 0 0 916 tags=32%, list=12%, signal=28% 1738/1743/11315 6.3.2.2 Reactome # Reactome GSEA react_gsea &lt;- gsePathway(geneList = gsea_input, organism = &quot;human&quot;, eps = 0, nPermSimple = 1000) 6.3.2.3 Pfam 6.3.2.4 Other Databases References "],["references-1.html", "References", " References "]]
