[["index.html", "A Tutorial for Proteomics Data Analysis with R/Bioconductor Section 1 Welcome!", " A Tutorial for Proteomics Data Analysis with R/Bioconductor Tyler Sagendorf October 12, 2021 Section 1 Welcome! This tutorial is very much a work-in progress. Even sections that appear finished are likely to be changed. I will update this when significant progress is made. Thank you for your patience. "],["exploratory-data-analysis.html", "Section 2 Exploratory Data Analysis", " Section 2 Exploratory Data Analysis What is exploratory data analysis? Explain. library(MSnSet.utils) library(ggplot2) library(dplyr) library(scales) # Set the theme for all plots. Base text size is set to 14 pts. theme_set(theme_bw(base_size = 14)) # Load the MSnSet data(cptac_oca) "],["number-of-features-identified-in-each-sample.html", "2.1 Number of Features Identified in Each Sample", " 2.1 Number of Features Identified in Each Sample To count the number of features identified in each sample, we use colSums to tally the number of entries that are not NA. # Calculate the number of proteins # identified (not NA) in each sample plot_data &lt;- pData(oca.set) %&gt;% mutate(num_proteins = colSums(!is.na(exprs(oca.set)))) %&gt;% # For the lollipop plot, it is best to sort num_peptides # and preserve the ordering by converting the sample names # to a factor. This is how we can specify the order of categorical # variables in plots. arrange(num_proteins) %&gt;% mutate(sample_name = rownames(.), sample_name = factor(sample_name, levels = sample_name)) # Could also be accomplished with # oca.set$num_proteins = colSums(!is.na(exprs(oca.set))) # but we need to change the ordering for the lollipop plot Three methods of visualizing this information are presented below. We begin with the lollipop plot. 2.1.1 Lollipop Plot Lollipop plots are similar to bar graphs, but they are composed of line segments terminating in points. They are a good alternative to bar graphs because they better minimize the amount of non-data ink. This doesnt matter too much when figures are only made for digital media, but it still reduces the visual clutter that comes with bars; however, it is not a good alternative to stacked bar graphs. In ggplot, we can construct lollipop plots by combining a geom_segment() and a geom_point() layer. # Lollipop plot ggplot(plot_data) + geom_segment(aes(x = 0, xend = num_proteins, y = sample_name, yend = sample_name)) + geom_point(aes(x = num_proteins, y = sample_name)) + scale_x_continuous(name = &quot;Number of Proteins Detected&quot;, # Remove space between data and y axis # (start lines at x = 0) expand = expansion(mult = c(0, 0.05))) + # Remove unnecessary y-axis title and the major y-axis grid lines theme(axis.title.y = element_blank(), panel.grid.major.y = element_blank()) In this case, using a lollipop plot is not a very good use of space. Notice that the plot is lengthened so that all of the sample names are readable, and the number of proteins detected in each is about the same; a lot of the space is just taken up by lines. In this case, it would be better to use a table or another plot type like a boxplot. 2.1.2 Boxplot A boxplot is good for identifying and labeling potential outliers, but it is limited to displaying a summary of the data. We will be using graphics::boxplot() for this example, rather than the ggplot2 equivalent, because it is easier and the y-axis is uncluttered. # Boxplot boxplot(plot_data$num_proteins, horizontal = TRUE, xlab = &quot;Number of Proteins Detected&quot;, col = NA) Notice that the boxplot takes up a lot less space, but it is less informative because we can not directly compare samples. Also, we lose a lot of the fine details of the shape of the distribution. To address the latter point, we can instead use a density plot. 2.1.3 Density Plot A density plot is like a smoothed histogram. In fact, one of the benefits over the histogram is that we dont have to deal with bins, as the choice of the number of bins can drastically change the overall shape of a histogram. ggplot(plot_data) + geom_density(aes(x = num_proteins), # Change fill color, make it translucent, remove outline fill = &quot;lightblue&quot;, alpha = 0.5, color = NA) + scale_x_continuous(name = &quot;Number of Proteins Detected&quot;, # Remove space between data and y axis expand = expansion(mult = 0), limits = c(NA, 7800), breaks = seq(6600, 7800, 200)) + scale_y_continuous(name = &quot;Density&quot;, # Remove space between data and x axis (start y axis at 0) expand = expansion(mult = c(0, 0.05)), # Use scientific notation for labels labels = label_scientific()) + theme_bw(base_size = 14) + # Adjust plot margin so that the 7800 label is not cut off theme(plot.margin = unit(c(6, 16, 6, 6), units = &quot;pt&quot;)) While outliers in a boxplot appear as points beyond the whiskers, outliers in density plots will appear as small bumps in the tails of the distribution. While there are no outliers, in this case, we can see that there are two peaks where the number of identified proteins are concentrated. This is not something that could be captured with a boxplot, so it is useful to try different plot types. "],["estimate-blood-contamination.html", "2.2 Estimate Blood Contamination", " 2.2 Estimate Blood Contamination What are the major blood proteins? Hemoglobin alpha, beta, delta, gamma 1; fibrinogen alpha, beta, gamma; albumin, spectrin, # NOTE: eval set to FALSE blood_proteins &lt;- &quot;HBA_HUMAN HBB_HUMAN HBD_HUMAN HBG1_HUMAN FIBA_HUMAN FIBB_HUMAN FIBG_HUMAN SPTB1_HUMAN THRB_HUMAN ALBU_HUMAN A1AG1_HUMAN A1AG2_HUMAN CAH1_HUMAN GLPA_HUMAN GLPB_HUMAN GLPC_HUMAN&quot; blood_proteins &lt;- gsub(&quot;\\\\s|\\\\n&quot;, &quot;\\\\|&quot;, blood_proteins) m1$blood_contamination &lt;- apply(exprs(m1)[grepl(blood_proteins, featureNames(m1)), ], 2, mean, na.rm = TRUE) "],["pca.html", "2.3 PCA", " 2.3 PCA 2.3.1 Overview This is the overview for PCA. 2.3.2 PCA Plots # Default plot plot_pca_v3(oca.set, phenotype = &quot;SUBTYPE&quot;) # New legend title legend.title &lt;- &quot;Subtype&quot; plot_pca_v3(oca.set, phenotype = &quot;SUBTYPE&quot;) + # Change the titles of the point color and ellipse fill legends guides(color = guide_legend(title = legend.title), # Do not include this line if show.ellipse = FALSE fill = guide_legend(title = legend.title)) + # Change base text size. theme_set() does not work here theme_bw(base_size = 14) Figure 2.1: This is the figure caption I am referencing Figure 2.1. 2.3.3 List Top-Contributing Features In MSnSet.utils, there is a function that allows us to determine which features contribute the most to each principal component. This is the main part of the code to do this. # V is the matrix of eigenvectors that have been scaled to unit vectors. cutoff &lt;- sqrt(1 / nrow(V)) res &lt;- apply(V, 2, function(w) { # Subset to values at least equal to the cutoff in magnitude x &lt;- w[which(abs(w) &gt;= cutoff)] # Order this subset by magnitude x[order(abs(x), decreasing = TRUE)] }) "],["DEA.html", "Section 3 Differential Expression Analysis", " Section 3 Differential Expression Analysis The overview goes here. For this chapter, we will need the following packages. library(MSnSet.utils) library(ggplot2) library(dplyr) library(tibble) library(scales) # Load the MSnSet data(&quot;longitudinal_biomarker_study&quot;) "],["dea-with-limma.html", "3.1 DEA with limma", " 3.1 DEA with limma This section covers differential expression analysis with the limma package. The basic workflow for DEA with limma is to fit a linear model to each feature, then, empirical Bayesian methods are used to moderate the test statistics The limma users guide is an invaluable resource. 3.1.1 Dichotomous Predictors res1 &lt;- limma_a_b(longitudinal_biomarker_study, model.str = &quot;~ Type&quot;, coef.str = &quot;Type&quot;) 3.1.2 Continuous Predictors 3.1.3 Reference Level Comparisons 3.1.4 Custom Contrasts "],["p-value-histograms.html", "3.2 p-value Histograms", " 3.2 p-value Histograms hist(res1$P.Value, breaks = seq(0, 1, 0.05), main = &quot;Histogram of Case vs Control p-values&quot;, xlab = &quot;p-value&quot;) The histogram is fairly uniform, which means that only a few of the features are likely to be significant after adjustment. hist(res1$adj.P.Val, breaks = seq(0, 1, 0.05), main = &quot;Histogram of Case vs Control Adjusted p-values&quot;, xlab = &quot;BH-adjusted p-value&quot;) After adjustment, only 2 proteins are significantly-different between the case and control groups. "],["volcano-plots.html", "3.3 Volcano Plots", " 3.3 Volcano Plots # Base volcano plot plot_volcano(logFC = res1$logFC, significance = res1$P.Value) plot_data &lt;- res1 %&gt;% rownames_to_column(&quot;feature&quot;) %&gt;% mutate(point_color = case_when( logFC &gt;= 0 &amp; P.Value &lt; 0.05 ~ &quot;Up&quot;, logFC &lt; 0 &amp; P.Value &lt; 0.05 ~ &quot;Down&quot;)) features_to_label &lt;- plot_data %&gt;% # Select top 3 most significant proteins in each group filter(point_color != &quot;NS&quot;) %&gt;% group_by(point_color) %&gt;% slice_min(order_by = P.Value, n = 3) %&gt;% mutate(feature_label = feature) plot_data &lt;- left_join(plot_data, features_to_label) # Add significance cutoff line, color points based on significance # and logFC, label the 3 most significant points for both positive # and negative logFC. plot_volcano(logFC = plot_data$logFC, significance = plot_data$P.Value, sig_threshold = 0.05, threshold_line_color = &quot;black&quot;, point_color = plot_data$point_color, feature_labels = plot_data$feature_label, plot_theme = theme_bw(base_size = 14)) + # Modify point colors scale_color_manual(values = c(&quot;red3&quot;, &quot;#5555ff&quot;), breaks = c(&quot;Up&quot;, &quot;Down&quot;), na.value = &quot;grey70&quot;) + # Remove legend theme(legend.position = &quot;none&quot;) + # Modify plot labels labs(x = expression(paste(&quot;log&quot;[2],&quot;(fold-change)&quot;)), y = &quot;Unadjusted p-value&quot;) "],["patha.html", "Section 4 Pathway Analysis", " Section 4 Pathway Analysis In the previous section (Section 3), we covered analysis at the individual feature level (protein, peptide, phosphoprotein, etc.). While DEA is useful, it is not without its own set of shortcomings. For instance, there may be no features that pass the significance threshold after correcting for multiple hypothesis testing. Alternatively, there may be many features that are statistically significant, and interpreting this list can be tedious and prone to investigator bias toward a hypothesis of interest (Maleki et al., 2020). Another issue is that single-feature analysis fails to detect subtle, yet coordinated changes in groups of related features (Subramanian et al., 2005). In order to address these, and other, issues, pathway analysis instead examines a priori defined gene setsgroups of genes that participate in the same biological pathway, share the same cellular location, etc. In this section, we will explore some common annotation databases, as well as two pathway analysis methods: Over-Representation Analysis (ORA) and Gene Set Enrichment Analysis (GSEA). References "],["enrichdb.html", "4.1 Annotation Databases", " 4.1 Annotation Databases In this section, we will explore some of the common annotation databases used for pathway analysis. 4.1.1 Gene Ontology The Gene Ontology (GO) database is divided into three separate domains: Biological Process, Cellular Component, and Molecular Function (see the Gene Ontology overview for more details regarding each domain). Each domain is structured as a directed acyclic graph (DAG) where nodes are terms and edges are the relations between the terms (part of, is a, has part, regulates). Nodes can be connected to multiple child and parent nodes, where the group of genes annotated to a child node is a subset of those that are annotated to its parent node(s) (2021; Goeman et al., 2008). Semantic Similarity Due to the DAG structure of each domain, there is often redundancy in pathway analysis results. For example, suppose terms GO:0006119, GO:0009060, and GO:0046034 are significantly over-represented biological processes. GO:0009060 and GO:0046034 are the parent terms of GO:0006119. Due to this relationship, the terms likely provide much of the same information, so the inclusion of all three terms in the output is unnecessary. In order to resolve this redundancy, we can calculate the semantic similarity between pairs of GO terms, which assesses the likeness in meaning of two concepts (Pesquita, 2017). Basically, if two terms are highly related, we can use some other criteria (such as adjusted p-value or level in the DAG) to retain only one of the terms. Below, we use the GOSemSim package to calculate the semantic similarity between the terms. ## Calculate semantic similarity between GO terms library(GOSemSim) library(org.Hs.eg.db) # GO DATA for measuring semantic similarity. # keytype is &quot;ENTREZID&quot; by default and # information criteria is calculated (computeIC = TRUE) semData &lt;- godata(OrgDb = &quot;org.Hs.eg.db&quot;, ont = &quot;BP&quot;) terms &lt;- c(&quot;GO:0006119&quot;, &quot;GO:0009060&quot;, &quot;GO:0046034&quot;) # measure = &quot;Rel&quot; is the default for clusterProfiler::simplify # See code for clusterProfiler:::simplify_internal sim &lt;- mgoSim(GO1 = terms, GO2 = terms, semData = semData, measure = &quot;Rel&quot;, combine = NULL) Table 4.1: Semantic Similarity of select GO terms GO:0006119 GO:0009060 GO:0046034 GO:0006119 0.998 0.754 0.936 GO:0009060 0.754 0.999 0.128 GO:0046034 0.936 0.128 0.997 If measure is \"Lin\", \"Jiang\", or \"Wang\", the semantic similarity of a term with itself will be 1. This is not true for the other methods. We can see from Table 4.1 that GO:0009060 and GO:0046034 have low semantic similarity, while GO:0006119 is highly similar to its parent terms. This makes sense because the parent terms are not related/connected in the DAG. Now that we have the semantic similarities, we can remove redundant terms. clusterProfiler has a function called simplify that will calculate semantic similarity and remove terms. By default, if there are two terms with a semantic similarity greater than 0.7, simplify retains the term with the lowest adjusted p-value. See this post by Guangchuang Yu for more details on clusterProfiler::simplify. GO Subsets/Slims Another way to handle the redundancy of GO terms is to use a GO slim, which is a subset of more generic or research-relevant terms from the GO. GO slims can be downloaded or accessed with the biomaRt package as shown below. ## Create human GO slim library(biomaRt) library(clusterProfiler) # gcSample data library(dplyr) mart &lt;- useMart(biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) # Uncomment to determine which attributes to select in getBM() # View(listAttributes(mart)) # The GO slim columns are goslim_goa_accession and goslim_goa_description. # We will map from the Entrez IDs in gcSample to these attributes. data(gcSample) universe &lt;- unique(unlist(gcSample)) GO_slim &lt;- getBM(filters = &quot;entrezgene_id&quot;, attributes = c(&quot;entrezgene_id&quot;, &quot;goslim_goa_accession&quot;, &quot;goslim_goa_description&quot;), values = universe, # Subset to these Entrez IDs mart = mart) %&gt;% # Convert entrezgene_id from integer to character mutate_all(as.character) entrezgene_id goslim_goa_accession goslim_goa_description 100 GO:0003674 molecular_function 100 GO:0016810 hydrolase activity, acting on carbon-nitrogen (but not peptide) bonds 100 GO:0008150 biological_process 100 GO:0009058 biosynthetic process 100 GO:0044281 small molecule metabolic process 100 GO:0034641 cellular nitrogen compound metabolic process Unfortunately, not every GO accession maps to a domain when we use biomaRt (unsure why this is the case), so we wont be able to separate the terms. However, there are two ways that we can still use these GO slim accessions. Either follow the steps for using clusterProfiler::enricher (shown in the Pfam subsection of Section 4.2.2) with conversion tables created from org.Hs.eg.db that have been subset to the GO slim accessions, or remove any non GO slim accessions from the final results and readjust the remaining p-values (the easier approach). 4.1.2 Reactome Home - Reactome Pathway Database 4.1.3 KEGG KEGG: Kyoto Encyclopedia of Genes and Genomes 4.1.4 Pfam Pfam: Home page Pfam Documentation profile Hidden Markov Models References "],["ora.html", "4.2 Over-Representation Analysis", " 4.2 Over-Representation Analysis 4.2.1 Overview Over-Representation Analysis (ORA) is used to determine which a priori defined gene sets are more present (over-represented) in a subset of interesting genes than what would be expected by chance (Huang et al., 2009). Essentially, it identifies the gene setsrather than the individual genesthat are significantly different between two conditions. For each gene set, an enrichment p-value is calculated using the Binomial distribution, Hypergeometric distribution, the Fisher exact test, or the Chi-square test. Although this list is not all-encompassing, these are the most popular statistical methods (Huang et al., 2009). Below is the formula for calculating the enrichment p-value for a particular gene set using the Hypergeometric distribution. \\[ P(X\\geq x) = 1 - P(X \\leq x-1) = 1 - \\sum\\limits_{i=0}^{x-1}\\frac{\\hphantom{}{M \\choose i }{N - M \\choose n-i}}{N \\choose n} \\] In this equation, \\(N\\) is the number of background genes, \\(n\\) is the number of interesting (i.e. statistically-significant) genes, \\(M\\) is the number of genes that are annotated to a particular gene set \\(S\\), and \\(x\\) is the number of interesting genes that are annotated to \\(S\\). The numerator of the sum is the number of samples of \\(n\\) genes that can be taken from a population of \\(N\\) genes where exactly \\(i\\) of the genes are annotated to \\(S\\) and \\(n-i\\) are not annotated to \\(S\\). The denominator of the sum is the total number of samples of size \\(n\\) that can be taken from a population of size \\(N\\). For example, suppose we have a list of 8000 genes, of which 400 are differentially expressed. Also suppose that 100 of the 8000 genes are annotated to a particular gene set \\(S\\). Of these 100 genes, 20 are differentially expressed. The probability that 20 or more (up to 100) genes annotated to \\(S\\) are differentially expressed by chance is given by \\[ P(X\\geq 20) = 1 - P(X \\leq 19) = 1-\\sum \\limits_{i=0}^{19}\\frac{\\hphantom{}{100 \\choose i}{8000 - 100 \\choose 400-i}}{8000 \\choose 400} = 7.88 \\times 10^{-8} \\] That is, it is extremely unlikely that 20 of the 100 genes from this set are significantly differentially expressed by chance (at least, prior to adjustment for multiple comparisons). The code to calculate this p-value is phyper(q = 20 - 1, m = 400, n = 8000 - 400, k = 100, lower.tail = FALSE) After a p-value has been calculated for each of the applicable gene sets, a multiple comparison adjustment should be performed. 4.2.2 Examples For these examples, we will show how to perform ORA with the GOstats, clusterProfiler, and ReactomePA packages. The databases that we will cover are Gene Ontology, Reactome, and Pfam. For details on these different annotation databases, please see Section 4.1. ## Setup # Required packages library(clusterProfiler) # GO, KEGG, and custom ORA library(ReactomePA) # Reactome ORA library(GOstats) # GO, KEGG, and Pfam ORA library(PFAM.db) # Map Pfam IDs to descriptions library(org.Hs.eg.db) # Human annotation database library(kableExtra) library(dplyr) Normally, we would use a DEA table to create two character vectors: one for the significantly expressed genes and the other for all genes that were tested (referred to as the background or universe); instead, we will use the gcSample data that comes with clusterProfiler and treat the eighth cluster as our vector of significant genes and the entire list as the gene universe. Each gene is represented by a human Entrez gene ID, which is the default keytype used by the clusterProfiler functions and the only keytype compatible with ReactomePA::enrichPathway. data(&quot;gcSample&quot;) # Data for examples sig_genes &lt;- gcSample[[8]] # significant genes universe &lt;- unique(unlist(gcSample)) # universe It is important to note that the genes should be unique from the start. The terms between any two clusters of gcSample may overlap, so we must use unique for the sake of these examples. If your DEA results are not gene-centric, do NOT use ORA. Instead, switch to GSEA and summarize the ranking metric in some way to make it gene-centric (i.e. take the average, min, max, etc. of the metrics for each gene group). Gene Ontology We will first use the clusterProfiler package to test which biological processes are over-represented in the set of interesting genes. For this example, we will only consider gene sets of size 20 to 500. In order to test either molecular functions, cellular components, or all three ontologies at once, set ont to \"MF\", \"CC\", or \"ALL\", respectively. ## GO BP ORA with clusterProfiler # This takes a while cp_ora_go &lt;- enrichGO( gene = sig_genes, OrgDb = &quot;org.Hs.eg.db&quot;, keyType = &quot;ENTREZID&quot;, ont = &quot;BP&quot;, # BP, CC, MF, or ALL for all ontologies pvalueCutoff = 0.05, qvalueCutoff = 1, # Do not filter by q-value pAdjustMethod = &quot;BH&quot;, universe = universe, minGSSize = 20, maxGSSize = 500, readable = TRUE # Convert Entrez ID to gene symbol ) Table 4.2: Top significantly over-represented biological processes from enrichGO output. ID Description GeneRatio BgRatio pvalue p.adjust geneID GO:0046034 ATP metabolic process 24/232 96/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0006119 oxidative phosphorylation 16/232 49/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0006402 mRNA catabolic process 22/232 93/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:1902600 proton transmembrane transport 12/232 28/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0016071 mRNA metabolic process 35/232 208/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:0006091 generation of precursor metabolites and energy 29/232 159/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0009060 aerobic respiration 12/232 32/3652 0 1e-04 COX4I1/MDH1/HIF1A GO:0006401 RNA catabolic process 22/232 104/3652 0 1e-04 HNRNPU/YWHAZ/RPL13A GO:0010608 posttranscriptional regulation of gene expression 28/232 168/3652 0 3e-04 HNRNPU/MATR3/YWHAZ GO:0042773 ATP synthesis coupled electron transport 11/232 31/3652 0 3e-04 COX4I1/COX8A/COX7C There were 4436 biological processes that were tested. Of these, 2049 passed the size filter, and only 182 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 4.2. Remove Redundant GO Terms By default, if two terms have a semantic similarity above 0.7, clusterProfiler::simplify retains the more significantly over-represented term. # Remove redundant GO terms with simplify cp_ora_go_sim &lt;- simplify(cp_ora_go) Table 4.3: Simplified top significantly over-represented biological processes from enrichGO output. ID Description GeneRatio BgRatio pvalue p.adjust geneID GO:0046034 ATP metabolic process 24/232 96/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0006119 oxidative phosphorylation 16/232 49/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0006402 mRNA catabolic process 22/232 93/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:1902600 proton transmembrane transport 12/232 28/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0016071 mRNA metabolic process 35/232 208/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:0006091 generation of precursor metabolites and energy 29/232 159/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0010608 posttranscriptional regulation of gene expression 28/232 168/3652 0 3e-04 HNRNPU/MATR3/YWHAZ GO:0009205 purine ribonucleoside triphosphate metabolic process 9/232 21/3652 0 4e-04 RAN/ENO1/ATP5F1B GO:0034097 response to cytokine 45/232 357/3652 0 4e-04 HNRNPU/YWHAZ/SLC25A5 GO:0071345 cellular response to cytokine stimulus 42/232 325/3652 0 4e-04 HNRNPU/YWHAZ/SLC25A5 Notice that GO:0009060 is not present in Table 4.3 anymore, since it was highly similar to GO:0006119, and the latter was more significant. After removing redundant GO terms, 96 pass the significance threshold. Instead of retaining terms based on adjusted p-value, we could ignore significance and instead retain either parent or child terms (select_fun = min and select_fun = max, respectively). The code to do so is provided here. Another alternative would be to use a gene ID to GO slim ID conversion table. See the Semantic Similarity subsection of Section 4.1 for more details. Now, we will perform GO ORA with the GOstats package. We begin by creating an object of class GOHyperGParams and passing it to hyperGTest for calculation of Hypergeometric p-values. We do not filter by p-value, since adjusted p-values are not provided and we must calculate them ourselves. ## GO BP ORA with GOstats hyperg_ora_go &lt;- new( Class = &quot;GOHyperGParams&quot;, ontology = &quot;BP&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, # Do not filter by p-value testDirection = &quot;over&quot;, conditional = FALSE ) %&gt;% hyperGTest() # Hypergeometric testing Now, we need to filter by gene set size (limit 20 to 500), adjust the p-values, and filter based on the adjusted p-values. res_go_ora &lt;- summary(hyperg_ora_go) %&gt;% # Filter by size filter(Size &gt;= 20, Size &lt;= 500) %&gt;% # Adjust p-values mutate(p.adjust = p.adjust(Pvalue, method = &quot;BH&quot;)) %&gt;% # Filter and sort by adjusted p-values arrange(p.adjust) %&gt;% filter(p.adjust &lt; 0.05) Table 4.4: Over-represented biological processes obtained using the GOstats package. GOBPID Term OddsRatio ExpCount Count Size Pvalue p.adjust GO:0046034 ATP metabolic process 5.3654 6.0986 24 96 0 0e+00 GO:0006119 oxidative phosphorylation 7.6027 3.1128 16 49 0 0e+00 GO:0006402 mRNA catabolic process 4.9415 5.9080 22 93 0 0e+00 GO:1902600 proton transmembrane transport 11.6045 1.7788 12 28 0 0e+00 GO:0016071 mRNA metabolic process 3.3346 13.2136 35 208 0 0e+00 GO:0006091 generation of precursor metabolites and energy 3.6154 10.1008 29 159 0 0e+00 GO:0009060 aerobic respiration 9.2727 2.0329 12 32 0 1e-04 GO:0006401 RNA catabolic process 4.2646 6.6068 22 104 0 1e-04 GO:0010608 posttranscriptional regulation of gene expression 3.2157 10.6725 28 168 0 3e-04 GO:0042773 ATP synthesis coupled electron transport 8.4615 1.9693 11 31 0 3e-04 There were 4435 biological processes that were tested. Of these, 2049 passed the size filter, and only 182 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 4.4. The total number of biological processes that were tested is 1 less than the number reported from the enrichGO results. This is because enrichGO includes the biological_process root GO:0008150. Remove Redundant GO Terms While there is no function akin to clusterProfiler::simplify to process results, there is an argument called conditional. Setting conditional to TRUE tells hyperGTest to use the term-term relationships when calculating p-values (Falcon et al., 2021). This approach is actually more akin to Modular Enrichment Analysis (MEA) than Over-Representation Analysis (also called Singular Enrichment Analysis; Huang et al. (2009)). ## Conditional GO BP ORA with GOstats hyperg_ora_go_sim &lt;- new( Class = &quot;GOHyperGParams&quot;, ontology = &quot;BP&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, # Do not filter by p-value testDirection = &quot;over&quot;, conditional = TRUE # Use structure of GO graph ) %&gt;% hyperGTest() # Hypergeometric testing We will process the results the same as before and compare. Table 4.5: Simplified over-represented biological processes obtained using the GOstats package. GOBPID Term OddsRatio ExpCount Count Size Pvalue p.adjust GO:0046034 ATP metabolic process 7.4290 2.3261 12 38 0e+00 0.0011 GO:0042773 ATP synthesis coupled electron transport 8.4615 1.9693 11 31 0e+00 0.0011 GO:0043043 peptide biosynthetic process 3.2288 9.0208 24 142 0e+00 0.0028 GO:0046364 monosaccharide biosynthetic process 6.7593 2.2870 11 36 0e+00 0.0028 GO:0009145 purine nucleoside triphosphate biosynthetic process 10.1429 1.2705 8 20 0e+00 0.0044 GO:0009201 ribonucleoside triphosphate biosynthetic process 8.6888 1.3976 8 22 0e+00 0.0083 GO:0006094 gluconeogenesis 6.5618 1.8981 9 30 1e-04 0.0127 GO:0009141 nucleoside triphosphate metabolic process 6.2336 1.9693 9 31 1e-04 0.0130 GO:0034655 nucleobase-containing compound catabolic process 2.8081 9.2114 22 145 1e-04 0.0130 GO:0048002 antigen processing and presentation of peptide antigen 3.8578 4.4469 14 70 1e-04 0.0130 Now, only 2953 terms showed up in the summary. Of these, 1445 passed the size filter, and 31 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 4.5. The major difference between these results and the ones from enrichGO after using simplify is that p-value adjustment is not affected by simplify, as redundant GO terms are removed after. The conditional method is actually more akin to performing modular enrichment analysis (MEA) than ORA (also called singular enrichment analysis) Reactome GOstats does not have a dedicated class to test for Reactome pathway over-representation, but we can use ReactomePA. For this example, we will only consider pathways of size 20 to 500. enrichPathway only accepts Entrez gene IDs as input. In cases where the Entrez ID is not readily available, we must convert to them. Alternatively, we could use the custom ORA function enricher, which allows us to use any ID type (use demonstrated in Pfam example). ## Reactome ORA with ReactomePA cp_ora_reactome &lt;- enrichPathway( gene = sig_genes, organism = &quot;human&quot;, pvalueCutoff = 0.05, pAdjustMethod = &quot;BH&quot;, qvalueCutoff = 1, # Do not filter by q-value universe = universe, minGSSize = 20, maxGSSize = 500, readable = TRUE # Convert Entrez ID to gene symbol ) Table 4.6: Top significantly over-represented Reactome pathways from enrichPathway output. ID Description GeneRatio BgRatio pvalue p.adjust geneID R-HSA-8953897 Cellular responses to external stimuli 39/193 185/2548 0 0e+00 COX4I1/RPL13A/SKP1 R-HSA-2262752 Cellular responses to stress 37/193 181/2548 0 0e+00 COX4I1/RPL13A/SKP1 R-HSA-163200 Respiratory electron transport, ATP synthesis by chemiosmotic coupling, and heat production by uncoupling proteins. 15/193 37/2548 0 0e+00 COX4I1/COX8A/COX7C R-HSA-5663205 Infectious disease 38/193 212/2548 0 0e+00 PRKAR1A/SLC25A5/RPL13A R-HSA-9711123 Cellular response to chemical stress 18/193 61/2548 0 0e+00 COX4I1/SKP1/PSMB7 R-HSA-9707564 Cytoprotection by HMOX1 16/193 50/2548 0 0e+00 COX4I1/SKP1/PSMB7 R-HSA-1428517 The citric acid (TCA) cycle and respiratory electron transport 17/193 57/2548 0 0e+00 COX4I1/LDHB/COX8A R-HSA-72766 Translation 17/193 58/2548 0 0e+00 RPL13A/RPL29/KARS1 R-HSA-5628897 TP53 Regulates Metabolic Genes 12/193 34/2548 0 1e-04 COX4I1/YWHAZ/YWHAQ R-HSA-8953854 Metabolism of RNA 31/193 181/2548 0 3e-04 HNRNPU/YWHAZ/RPL13A There were 919 Reactome pathways that were tested. Of these, 388 passed the size filter, and 155 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 4.6. Pfam While there is no dedicated ORA function for Pfam entries in clusterProfiler, there is a general ORA function called enricher that can be used with any term to gene conversion table. This function is also much faster than the dedicated enrichGO and enrichPathway functions, so it may be preferred if running many separate over-representation analyses. The conversion table is generated with the biomaRt package as follows. # NOT RUN --- library(biomaRt) mart &lt;- useMart(biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) View(listAttributes(mart)) # Determine which columns to return conv_tbl &lt;- getBM(filters = &quot;entrezgene_id&quot;, attributes = c(&quot;entrezgene_id&quot;, &quot;pfam&quot;), values = universe, mart = mart) %&gt;% mutate_all(as.character) saveRDS(conv_tbl, file = &quot;data/pfam_conv_tbl.rds&quot;) In addition to the term to gene conversion table, we can supply a term to name table that maps Pfam IDs to human-readable descriptions. While org.Hs.eg.db does not provide Pfam descriptions, the PFAM.db annotation data package has a Bimap with this information. Now that we have the two conversion tables, we will perform ORA and limit the output to Pfam entries of size 15 to 500. # Entrez to Pfam ID mapping file created with biomaRt package TERM2GENE &lt;- readRDS(&quot;data/pfam_conv_tbl.rds&quot;) %&gt;% # Remove blank terms filter(pfam != &quot;&quot;) %&gt;% # Reorder and rename columns. # ! These specific column names must be used in this exact order dplyr::select(term = pfam, gene = entrezgene_id) # Pfam IDs to descriptions library(PFAM.db) TERM2NAME &lt;- as.data.frame.Bimap(PFAMDE) # ! These specific column names must be used in this exact order colnames(TERM2NAME) &lt;- c(&quot;term&quot;, &quot;name&quot;) ## Pfam ORA with clusterProfiler cp_ora_pfam &lt;- enricher( gene = sig_genes, pvalueCutoff = 0.05, pAdjustMethod = &quot;BH&quot;, universe = universe, minGSSize = 15, maxGSSize = 500, qvalueCutoff = 1, TERM2GENE = TERM2GENE, TERM2NAME = TERM2NAME ) Table 4.7: Top Pfam entries from enricher output. ID Description GeneRatio BgRatio pvalue p.adjust geneID PF01391 Collagen triple helix repeat (20 copies) 7/236 31/3675 0.0029 0.0687 1293/1281/1277 PF00076 RNA recognition motif. (a.k.a. RRM, RBD, or RNP domain) 7/236 55/3675 0.0599 0.5363 1153/3182/5042 PF00092 von Willebrand factor type A domain 3/236 15/3675 0.0670 0.5363 1293/1292/1291 PF00071 Ras family 3/236 23/3675 0.1804 0.9022 5901/6009/388 PF07679 Immunoglobulin I-set domain 3/236 27/3675 0.2489 0.9022 23022/3490/25878 PF13499 EF-hand domain pair 2/236 20/3675 0.3711 0.9022 6717/80303 PF00271 Helicase conserved C-terminal domain 2/236 24/3675 0.4623 0.9022 1973/10521 PF00412 LIM domain 2/236 24/3675 0.4623 0.9022 1396/9124 PF13855 Leucine rich repeat 3/236 42/3675 0.5123 0.9022 4060/1634/25878 PF00046 Homeodomain 2/236 27/3675 0.5254 0.9022 5087/29956 There were 275 Pfam entries that were tested. Of these, 24 passed the size filter, and 0 were significantly over-represented after multiple testing correction. While none were significant, the top 10 are shown in Table 4.7 so that we can compare it to the results from hyperGTest. Now, we will perform Pfam ORA with the GOstats package. We begin by constructing a new object of class PFAMHyperGParams and then passing it to hyperGTest for calculation of Hypergeometric p-values. We do not filter by p-value, since adjusted p-values are not provided and we must calculate them ourselves. ## Pfam ORA with GOstats hyperg_pfam_ora &lt;- new( Class = &quot;PFAMHyperGParams&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, testDirection = &quot;over&quot; ) %&gt;% hyperGTest() # Hypergeometric testing Now, we need to filter by gene set size (limit 15 to 500) and adjust the p-values. Normally, we would also filter based on the adjusted p-values, but we will skip this step so that we can compare the output with that of clusterProfiler::enricher. res_pfam_ora &lt;- summary(hyperg_pfam_ora) %&gt;% # Filter by Pfam entry size filter(Size &gt;= 15, Size &lt;= 500) %&gt;% # Adjust p-values mutate(p.adjust = p.adjust(Pvalue, method = &quot;BH&quot;)) %&gt;% # Sort by adjusted p-values arrange(p.adjust) The last step is to add the human-readable Pfam descriptions. We will use the TERM2NAME data frame from before and just change the column names for easy joining. # Pfam entries to descriptions colnames(TERM2NAME) &lt;- c(&quot;PFAMID&quot;, &quot;Description&quot;) res_pfam_ora &lt;- left_join(res_pfam_ora, TERM2NAME) Table 4.8: Top Pfam entries obtained using the GOstats package. PFAMID Description OddsRatio ExpCount Count Size Pvalue p.adjust PF01391 Collagen triple helix repeat (20 copies) 4.5163 1.9368 7 30 0.0024 0.0530 PF00076 RNA recognition motif. (a.k.a. RRM, RBD, or RNP domain) 2.1478 3.5509 7 55 0.0613 0.4980 PF00092 von Willebrand factor type A domain 3.6568 0.9684 3 15 0.0679 0.4980 PF00071 Ras family 2.1888 1.4849 3 23 0.1824 0.8976 PF07679 Immunoglobulin I-set domain 1.9016 1.6786 3 26 0.2338 0.8976 PF13499 EF-hand domain pair 1.8182 1.1621 2 18 0.3256 0.8976 PF00271 Helicase conserved C-terminal domain 1.3200 1.5495 2 24 0.4652 0.8976 PF00412 LIM domain 1.3200 1.5495 2 24 0.4652 0.8976 PF13855 Leucine rich repeat 1.1458 2.6470 3 41 0.4995 0.8976 PF00595 PDZ domain 1.2092 1.6786 2 26 0.5079 0.8976 260 Pfam entries were tested. Of these, 16 passed the size filter, and none were significantly over-represented after multiple testing correction. The top 10 are shown in Table 4.8. Notice that this table and Table 4.7 are different. For one, the sizes of the entries are not always the same. For example, PF01391 has size 31 according to the mapping file created from the biomaRt package, but only size 30 according to org.Hs.eg.db. This leads to differences in the number of total Pfam entries that remain after filtering by size and, subsequently, differences in the adjusted p-values. 4.2.3 Considerations The choice of the threshold for statistical significance and the multiple comparison adjustment method can greatly impact the analysis (Huang et al., 2009). ORA fails to incorporate direction of gene regulation. (Are the genes in a given set mainly up or down-regulated?). It is not a good idea to split DEA results by the sign of the logFC and apply ORA to the two sets. Use GSEA instead. If few genes are differentially expressed, ORA is unlikely to yield useful or reliable results. For example, suppose 30 out of 8000 genes are significant. 100 of the genes are annotated to a particular gene set, of which 3 are significant. The associated Hypergeometric p-value is 0.006, and this set would be considered significantly over-represented at the 0.01 level (at least, prior to adjustment for multiple comparisons); however, if only 2 of the genes in this set are significant, this p-value increases 10-fold to 0.0536 and is no longer significant even at the 0.05 level. If the DEA results are not gene-centric (i.e. DEA was performed at the protein or phosphosite level), then there may be cases where two proteins are associated with the same gene, but only one is significantly differentially abundant. In this case, there is no way to categorize the gene as significant or not, so ORA should not be used. The other problem that could arise if the DEA results are not gene-centric is that the same gene may be counted as significant multiple times, which leads to artificial over-representation. References "],["gsea.html", "4.3 Gene Set Enrichment Analysis", " 4.3 Gene Set Enrichment Analysis 4.3.1 Overview Gene Set Enrichment Analysis (GSEA) employs a no-cutoff strategy that utilizes some experimental value (such as fold change, the moderated t-statistic, or Z-Score) to rank a list of \\(N\\) genes in descending order. Using this ranked list \\(L\\), the values of the ranking metric, and an a priori defined gene set \\(S\\), we can calculate an enrichment score. This is done by walking down the list \\(L\\), increasing a running-sum statistic when we encounter a gene in \\(S\\) and decreasing it when we encounter genes not in \\(S\\). The maximum deviation from zero of this running-sum statistic is the enrichment score for \\(S\\), denoted by \\(ES(S)\\). If the genes in \\(S\\) are randomly distributed throughout \\(L\\), \\(ES(S)\\) will be relatively small; however, if they are not randomly distributed (i.e. primarily located near either end of \\(L\\)), then \\(ES(S)\\) will be relatively large (Mootha et al., 2003; Subramanian et al., 2005). To assess the statistical significance of each \\(ES(S)\\), we permute the phenotype labels in the expression data and recalculate the ranking metric and subsequent enrichment score \\(ES_{\\text{NULL}}\\). Alternatively, we could permute the genes: for a given \\(S\\) of size \\(k\\), we randomly select \\(k\\) genes from the list \\(L\\) and calculate an enrichment score \\(ES_{\\text{NULL}}\\). This is the method implemented by fgsea and, consequently, clusterProfiler, though it is not strictly accurate because it does not preserve the correlations between genes (Subramanian et al., 2005). Regardless of the permutation approach, it is repeated one thousand to tens of thousands of times to produce an empirical null distribution. Then, we define the nominal p-value as the proportion of \\(ES_{\\text{NULL}}\\) that are more extreme than \\(ES(S)\\). Once a p-value has been obtained for every gene set, we apply an appropriate adjustment for multiple hypothesis testing. The phenotype randomization approach is summarized in Figure 1: Schematic overview of GSEA in the paper by Mootha et al. (2003). The mathematical details of GSEA are provided below. Let \\(x = \\{x_1, ..., x_N : x_i &gt; x_j \\ \\forall i &lt; j\\}\\) be the vector of ranking metric values. Also let \\(S\\) be a particular gene set of size \\(k\\) and \\(NS = \\sum\\limits_{i \\in S}|x_i|\\). We define the value of the running sum at gene \\(i\\) as \\[ r_i = \\begin{cases} 0 &amp; \\text{if } i = 0, \\\\ r_{i-1} + \\frac{1}{NS}|x_i| &amp; \\text{if } 1 \\leq i \\leq N \\text{ and } i \\in S, \\\\ r_{i-1} - \\frac{1}{N-k} &amp; \\text{if } 1 \\leq i \\leq N \\text{ and } i \\not\\in S \\end{cases} \\] \\(ES(S)\\) is the largest (in terms of absolute value) element of \\(r_N\\). This notation is a slightly modified version of what is presented in the paper by Korotkevich et al. (2016). 4.3.2 Examples 4.3.2.1 Gene Ontology 4.3.2.2 Reactome 4.3.2.3 Pfam 4.3.3 Considerations GSEA is not influenced by an arbitrary cutoff for statistical significance. This is especially useful when only a few features pass this threshold after adjustment for multiple testing, and it also means that it does not depend on the choice of p-value adjustment. All genes in an experiment are allowed to contribute to the enrichment analysis in differing degrees (Huang et al., 2009). This addresses the point brought up at the beginning of Section 4 that biological changes may be the result of small changes in many related genes. GSEA allows for the detection of such changes. The sign of the enrichment score tell us in which category a set of genes is primarily up- or down-regulated. For example, suppose we test the difference between the means of two groups for each gene using the limma package. Since ranking metrics incorporate the direction of change, a positive enrichment score would mean that the majority of genes in that particular set are up-regulated in A relative to B/down-regulated in B relative to A. The choice of ranking metric is important. References "],["references.html", "References", " References "]]
