[["index.html", "Proteomics Data Analysis in R/Bioconductor Welcome!", " Proteomics Data Analysis in R/Bioconductor Tyler Sagendorf October 17, 2021 Welcome! This tutorial is very much a work-in progress. Even sections that appear finished are likely to be changed. I will update this when significant progress is made. Thank you for your patience. "],["miscellaneous-resources.html", "Section 1 Miscellaneous Resources", " Section 1 Miscellaneous Resources It is highly recommended to review the resources presented in this section before continuing with the rest of the book. Proteomics Overview Protein Analysis by Shotgun/Bottom-up Proteomics Modern Proteomics  Sample Preparation, Analysis and Practical Applications Liquid Chromatography Mass Spectrometry-Based Proteomics: Biological and Technological Aspects Mass Spectrometry Warwick School of Life Sciences Teaching Animations Tandem Mass Spectrometry for Peptide and Protein Sequence Analysis Maestro: Comprehensive, Multi-Stage Spectrum Identification in Protein Mass Spectrometry Searching databases for protein identification - part 1 (YouTube video) Mass spectrometry for proteomics - part one (YouTube video) Electrospray Ionisation Mass Spectrometry: Principles and Clinical Applications PNNLs Data Management System (DMS) Integrative Omics PRISMWiki Universal Protein Resource (UniProt): protein sequence and annotation data False Discovery Rate (FDR) How to talk about proteinlevel false discovery rates in shotgun proteomics Posterior Error Probabilities and False Discovery Rates: Two Sides of the Same Coin False Discovery Rate: PEAKS FDR Estimation False discovery rates in spectral identification RStudio Cheatsheets Pattern matching with regular expressions R for Data Science: Strings "],["isobaric-quantification-pipelines.html", "Section 2 Isobaric Quantification Pipelines", " Section 2 Isobaric Quantification Pipelines Section summary to be added later. Please continue to subsections. "],["global-proteomics-data.html", "2.1 Global Proteomics Data", " 2.1 Global Proteomics Data This pipeline shows how to process TMT data that is processed outside of PNNLs DMS. Section 2.2 shows how to process data from the DMS. For convenience, the results of MS-GF+ and MASIC processing are provided in a companion PlexedPiperTestData package. For this section, we need three packages: PlexedPiper for isobaric quantification, PlexedPiperTestData, and dplyr to manipulate data frames. # Setup library(PlexedPiper) library(PlexedPiperTestData) library(dplyr) 2.1.1 Prepare MS/MS Identifications Read MS-GF+ Data # Get file path path_to_MSGF_results &lt;- system.file(&quot;extdata/global/msgf_output&quot;, package = &quot;PlexedPiperTestData&quot;) # Read MS-GF+ data from path msnid &lt;- read_msgf_data(path_to_MSGF_results) Normally, this would display a progress bar in the console as the data is being fetched. However, the output was suppressed to save space. We can view a summary of the MSnID object with the show() function. show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 1156754 at 31 % FDR ## #peptides: 511617 at 61 % FDR ## #accessions: 128378 at 98 % FDR msnid consists of 4 spectrum files (datasets), and contains a total of 1,156,754 peptide-spectrum-matches (PSMs), 511,617 total peptides, and 128,378 total accessions (proteins). The reported FDR is the empirical false-discovery rate, which is calculated as the ratio of the number of false (decoy) PSMs, peptides, or accessions to their true (non-decoy) counterparts. Calculation of these counts and their FDRs is shown below. # Calculating the counts and FDRs from the show() output --- # Spectrum Files: # Count psms(msnid) %&gt;% distinct(Dataset) %&gt;% nrow() # 48 # PSMs: # Count psms(msnid) %&gt;% distinct(Dataset, Scan, peptide, isDecoy) %&gt;% # Assign intermediate to variable assign(&quot;x_psm&quot;, ., envir = globalenv()) %&gt;% nrow() # 1156754 # FDR nrow(x_psm[x_psm$isDecoy == TRUE, ]) / nrow(x_psm[x_psm$isDecoy == FALSE, ]) # 0.3127463 = 31% # peptides: # Count psms(msnid) %&gt;% distinct(peptide, isDecoy) %&gt;% assign(&quot;x_peptide&quot;, ., envir = globalenv()) %&gt;% nrow() # 511617 # FDR nrow(x_peptide[x_peptide$isDecoy == TRUE, ]) / nrow(x_peptide[x_peptide$isDecoy == FALSE, ]) # 0.611245 = 61% # Accessions: # Count length(accessions(msnid)) # or psms(msnid) %&gt;% distinct(accession, isDecoy) %&gt;% assign(&quot;x_acc&quot;, ., envir = globalenv()) %&gt;% nrow() # 128378 # FDR nrow(x_acc[x_acc$isDecoy == TRUE, ]) / nrow(x_acc[x_acc$isDecoy == FALSE, ]) # 0.9827024 = 98% Now that we have an MSnID object, we need to process it. Correct Isotope Selection Error Occasionally, the instrument selects a peak with +1 or more C13 atoms, rather than the monoisotopic (lowest mass) peak. While MS-FG+ is still capable of correctly identifying those, the downstream calculations of mass measurement error need to be fixed. The correct_peak_selection method corrects for these mass measurement errors. # Correct for isotope selection error msnid &lt;- correct_peak_selection(msnid) Remove Contaminants Now, we will remove contaminants such as the pig trypsin that was used for protein digestion. We can use grepl to search for all accessions that contain Contaminant. # All unique contaminants unique(msnid$accession[grepl(&quot;Contaminant&quot;, msnid$accession)]) ## [1] &quot;Contaminant_K2C1_HUMAN&quot; &quot;Contaminant_K1C9_HUMAN&quot; ## [3] &quot;Contaminant_ALBU_HUMAN&quot; &quot;Contaminant_ALBU_BOVIN&quot; ## [5] &quot;Contaminant_TRYP_PIG&quot; &quot;Contaminant_K1C10_HUMAN&quot; ## [7] &quot;XXX_Contaminant_K1C9_HUMAN&quot; &quot;Contaminant_K22E_HUMAN&quot; ## [9] &quot;Contaminant_Trypa3&quot; &quot;Contaminant_Trypa5&quot; ## [11] &quot;XXX_Contaminant_K1C10_HUMAN&quot; &quot;XXX_Contaminant_K22E_HUMAN&quot; ## [13] &quot;XXX_Contaminant_K2C1_HUMAN&quot; &quot;Contaminant_TRYP_BOVIN&quot; ## [15] &quot;XXX_Contaminant_ALBU_HUMAN&quot; &quot;XXX_Contaminant_ALBU_BOVIN&quot; ## [17] &quot;XXX_Contaminant_TRYP_BOVIN&quot; &quot;Contaminant_CTRB_BOVIN&quot; ## [19] &quot;Contaminant_Trypa1&quot; &quot;Contaminant_Trypa6&quot; ## [21] &quot;Contaminant_CTRA_BOVIN&quot; &quot;XXX_Contaminant_TRYP_PIG&quot; ## [23] &quot;XXX_Contaminant_CTRB_BOVIN&quot; &quot;XXX_Contaminant_CTRA_BOVIN&quot; ## [25] &quot;Contaminant_Trypa2&quot; To remove contaminants, we use apply_filter with an appropriate character string that tells the function what rows to keep. In this case, we keep rows where the accession does not contain Contaminant. We will use show to see how the counts change. # Remove contaminants msnid &lt;- apply_filter(msnid, &quot;!grepl(&#39;Contaminant&#39;, accession)&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 1155442 at 31 % FDR ## #peptides: 511196 at 61 % FDR ## #accessions: 128353 at 98 % FDR MS/MS ID Filter: Peptide Level The next step is to use the PepQValue column from the MSnID object and the absolute deviation of the mass measurement error of parent ions (in ppm) to maximize the number of PSMs while ensuring that the empirical peptide-level FDR is at most 1%. # 1% FDR filter at the peptide level msnid &lt;- filter_msgf_data(msnid, level = &quot;peptide&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 464542 at 0.45 % FDR ## #peptides: 96493 at 1 % FDR ## #accessions: 27120 at 9.2 % FDR We can see that filtering drastically reduces the number of PSMs, and the empirical peptide-level FDR is now 1%. However, notice that the empirical protein-level FDR is still fairly high. MS/MS ID Filter: Protein Level A while ago, the proteomics field established the hard-and-fast two-peptides-per-protein rule. That is, we can not be confident if a protein is identified by the detection of only one peptide. This rule penalizes short proteins and doesnt consider that there are some very long proteins (e.g. Titin 3.8 MDa) that easily have more then two matching peptides even in reversed sequence. Thus, we propose to normalize the number of peptides per protein length and use that as a filtering criterion. We need the FASTA (pronounced FAST-AYE) file to get the length of each protein, which we can then use to calculate the associated number of peptides per 1000 amino acids. This new peptides_per_1000aa column is used to filter the MSnID object so that the empirical accession-level FDR is at most 1%. # Get path to FASTA file path_to_FASTA &lt;- system.file( &quot;extdata/Rattus_norvegicus_NCBI_RefSeq_2018-04-10.fasta.gz&quot;, package = &quot;PlexedPiperTestData&quot; ) # Compute number of peptides per 1000 amino acids msnid &lt;- compute_num_peptides_per_1000aa(msnid, path_to_FASTA) # 1% FDR filter at the protein level msnid &lt;- filter_msgf_data(msnid, level = &quot;accession&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 458097 at 0.16 % FDR ## #peptides: 92024 at 0.32 % FDR ## #accessions: 15620 at 0.98 % FDR Inference of Parsimonious Protein Set The situation when a certain peptide sequence matches multiple proteins adds complication to the downstream quantitative analysis, as it is not clear which protein this peptide is originating from. There are common ways for dealing with this. One is to simply retain uniquely matching peptides and discard shared peptides (unique_only = TRUE). Alternatively (in case of unique_only = FALSE) assign the shared peptides to the proteins with the larger number of uniquely mapping peptides. If there is a choice between multiple proteins with equal numbers of uniquely mapping peptides, the shared peptides are assigned to the first protein according to alphanumeric order. This step could be done prior to filtering at the accession level, but the removal of an accession will completely remove its associated peptides. # Inference of parsimonious protein set msnid &lt;- infer_parsimonious_accessions(msnid, unique_only = FALSE) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 445003 at 0.15 % FDR ## #peptides: 90466 at 0.27 % FDR ## #accessions: 5246 at 1.1 % FDR Notice that the protein-level FDR increased above the acceptable threshold, so we need to reapply the filter. # 1% FDR filter at the protein level msnid &lt;- filter_msgf_data(msnid, level = &quot;accession&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 444857 at 0.14 % FDR ## #peptides: 90357 at 0.26 % FDR ## #accessions: 5211 at 0.99 % FDR Once all filtering is done, we can remove the decoy accessions. We use the apply_filter function again and only keep entries where isDecoy is FALSE. # Remove Decoy Accessions msnid &lt;- apply_filter(msnid, &quot;!isDecoy&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 48 ## #PSMs: 444216 at 0 % FDR ## #peptides: 90126 at 0 % FDR ## #accessions: 5160 at 0 % FDR After processing, we are left with 318,448 PSMs, 81,048 peptides, and 5,143 proteins. The empirical FDRs are the same as before, but can not be calculated because we removed the decoys. Table 2.1: First 10 rows of the processed MS-GF+ results. Dataset ResultID Scan FragMethod SpecIndex Charge PrecursorMZ DelM DelM_PPM MH peptide Protein NTT DeNovoScore MSGFScore MSGFDB_SpecEValue Rank_MSGFDB_SpecEValue EValue QValue PepQValue IsotopeError accession calculatedMassToCharge chargeState experimentalMassToCharge isDecoy spectrumFile spectrumID pepSeq msmsScore absParentMassErrorPPM peptides_per_1000aa MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 1862 27707 HCD 324 2 928.541 -0.001 -0.526 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 285 282 0 1 0 0.000 0.000 0 NP_113986.1 928.541 2 928.541 FALSE MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 27707 AAAAAAAAAAAAAAGAAGK Inf 0.589 25.769 MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 4192 27684 HCD 906 3 619.363 -0.002 -0.887 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 156 144 0 1 0 0.000 0.000 0 NP_113986.1 619.363 3 619.363 FALSE MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 27684 AAAAAAAAAAAAAAGAAGK Inf 0.991 25.769 MoTrPAC_Pilot_TMT_W_S2_06_12Oct17_Elm_AQ-17-09-02 26263 27336 HCD 5187 3 619.363 0.000 0.197 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 118 85 0 1 0 0.000 0.000 0 NP_113986.1 619.363 3 619.363 FALSE MoTrPAC_Pilot_TMT_W_S2_06_12Oct17_Elm_AQ-17-09-02 27336 AAAAAAAAAAAAAAGAAGK Inf 0.091 25.769 MoTrPAC_Pilot_TMT_W_S2_07_12Oct17_Elm_AQ-17-09-02 1471 27096 HCD 415 3 619.363 -0.001 -0.591 1856.075 R.AAAAAAAAAAAAAAGAAGK.E NP_113986.1 2 157 156 0 1 0 0.000 0.000 0 NP_113986.1 619.363 3 619.363 FALSE MoTrPAC_Pilot_TMT_W_S2_07_12Oct17_Elm_AQ-17-09-02 27096 AAAAAAAAAAAAAAGAAGK Inf 0.684 25.769 MoTrPAC_Pilot_TMT_W_S2_05_12Oct17_Elm_AQ-17-09-02 28664 10441 HCD 4849 2 586.832 -0.001 -0.728 1172.659 R.AAAAADLANR.S NP_001007804.1 2 124 124 0 1 0 0.002 0.003 0 NP_001007804.1 586.833 2 586.832 FALSE MoTrPAC_Pilot_TMT_W_S2_05_12Oct17_Elm_AQ-17-09-02 10441 AAAAADLANR 2.480 0.746 34.755 MoTrPAC_Pilot_TMT_W_S1_24_12Oct17_Elm_AQ-17-09-02 41775 8033 HCD 7889 2 831.447 0.000 0.000 1661.886 G.AAAAAEAESGGGGGK.K NP_001128630.1 1 176 76 0 1 0 0.001 0.003 0 NP_001128630.1 831.447 2 831.447 FALSE MoTrPAC_Pilot_TMT_W_S1_24_12Oct17_Elm_AQ-17-09-02 8033 AAAAAEAESGGGGGK 2.583 0.106 580.844 MoTrPAC_Pilot_TMT_W_S2_08_12Oct17_Elm_AQ-17-09-02 18244 10302 HCD 3724 3 653.695 -0.003 -1.649 1958.071 A.AAAAATEQQGSNGPVK.K NP_001177997.1 1 106 85 0 1 0 0.000 0.000 1 NP_001177997.1 653.362 3 653.361 FALSE MoTrPAC_Pilot_TMT_W_S2_08_12Oct17_Elm_AQ-17-09-02 10302 AAAAATEQQGSNGPVK 3.432 1.685 62.500 MoTrPAC_Pilot_TMT_W_S1_16_12Oct17_Elm_AQ-17-09-02 13019 8116 HCD 3103 3 613.301 0.000 0.100 1837.888 R.AAAADGEPLHNEEER.T NP_001099982.1 2 112 108 0 1 0 0.000 0.000 0 NP_001099982.1 613.301 3 613.301 FALSE MoTrPAC_Pilot_TMT_W_S1_16_12Oct17_Elm_AQ-17-09-02 8116 AAAADGEPLHNEEER Inf 0.105 14.749 MoTrPAC_Pilot_TMT_W_S2_16_12Oct17_Elm_AQ-17-09-02 18313 8217 HCD 3907 3 613.302 0.003 1.692 1837.888 R.AAAADGEPLHNEEER.T NP_001099982.1 2 90 68 0 1 0 0.000 0.001 0 NP_001099982.1 613.301 3 613.302 FALSE MoTrPAC_Pilot_TMT_W_S2_16_12Oct17_Elm_AQ-17-09-02 8217 AAAADGEPLHNEEER 3.000 1.703 14.749 MoTrPAC_Pilot_TMT_W_S1_24_12Oct17_Elm_AQ-17-09-02 16441 6833 HCD 3438 2 795.928 0.000 0.000 1590.849 A.AAAAEAESGGGGGK.K NP_001128630.1 1 230 192 0 1 0 0.000 0.000 0 NP_001128630.1 795.928 2 795.928 FALSE MoTrPAC_Pilot_TMT_W_S1_24_12Oct17_Elm_AQ-17-09-02 6833 AAAAEAESGGGGGK Inf 0.104 580.844 Table 2.1 shows the first 10 rows of the processed MS-GF+ output. 2.1.2 Prepare Reporter Ion Intensities Read MASIC Output MASIC is a tool for extracting ion intensities. With proper parameter settings, it can be used for extracting TMT (or iTRAQ) reporter ion intensities. In addition, it reports a number of other helpful metrics. Notably, the interference score at the parent ion level and the signal-to-noise ratio (S/N) at the reporter ion level (computed by Thermo software). The interference score reflects the proportion of the ion population that was isolated for fragmentation that is due to the targeted ion. In other words, 1 - InterferenceScore is due to co-isolated species that have similar elution time and parent ion m/z. # Path to MASIC data path_to_MASIC_results &lt;- system.file(&quot;extdata/global/masic_output&quot;, package = &quot;PlexedPiperTestData&quot;) # Read MASIC data masic_data &lt;- read_masic_data(path_to_MASIC_results, interference_score = TRUE) Normally, this would display two progress bars in the console as the data is being fetched. However, the output was suppressed to save space. Table 2.2: First 10 rows of the MASIC data. Dataset ScanNumber Collision.Mode ParentIonMZ BasePeakIntensity BasePeakMZ ReporterIonIntensityMax Ion_126.128 Ion_127.125 Ion_127.131 Ion_128.128 Ion_128.134 Ion_129.131 Ion_129.138 Ion_130.135 Ion_130.141 Ion_131.138 Weighted.Avg.Pct.Intensity.Correction Ion_126.128_SignalToNoise Ion_127.125_SignalToNoise Ion_127.131_SignalToNoise Ion_128.128_SignalToNoise Ion_128.134_SignalToNoise Ion_129.131_SignalToNoise Ion_129.138_SignalToNoise Ion_130.135_SignalToNoise Ion_130.141_SignalToNoise Ion_131.138_SignalToNoise Ion_126.128_Resolution Ion_127.125_Resolution Ion_127.131_Resolution Ion_128.128_Resolution Ion_128.134_Resolution Ion_129.131_Resolution Ion_129.138_Resolution Ion_130.135_Resolution Ion_130.141_Resolution Ion_131.138_Resolution ParentIonIndex MZ SurveyScanNumber OptimalPeakApexScanNumber PeakApexOverrideParentIonIndex CustomSICPeak PeakScanStart PeakScanEnd PeakScanMaxIntensity PeakMaxIntensity PeakSignalToNoiseRatio FWHMInScans PeakArea ParentIonIntensity PeakBaselineNoiseLevel PeakBaselineNoiseStDev PeakBaselinePointsUsed StatMomentsArea CenterOfMassScan PeakStDev PeakSkew PeakKSStat StatMomentsDataCountUsed InterferenceScore MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 2 hcd 407.74 227695.44 407.741 92236.87 70562.39 24864.62 17165.80 35625.00 92236.87 9640.23 8578.05 6996.69 11833.07 32281.34 0 71.47 25.17 17.38 36.04 93.32 9.75 8.67 7.07 11.96 32.71 44102 42700 42100 41800 44404 40500 39500 36800 41100 42302 0 407.742 1 12 -1 0 1 19 12 2901600 211.000 5 50422000 2579600 13750 97562 10113 47031000 11 5.68 -0.189 0.353 10 0.996 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 3 hcd 396.72 59127.97 529.294 34294.90 23706.89 13559.32 5856.83 16322.71 34294.90 4853.11 7938.24 0.00 1465.03 18182.27 0 26.12 14.94 6.45 17.97 37.77 5.34 8.74 NA 1.61 19.93 42702 41100 37000 40400 43404 36400 39700 NA 29800 41802 1 396.718 1 12 -1 0 1 19 12 2181900 19.690 5 34508000 1690600 110841 1120000 10166 31578000 11 5.59 -0.217 0.347 10 0.993 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 4 hcd 438.23 110444.82 362.224 14053.40 12459.86 11785.91 10932.51 10653.32 12328.62 5959.86 9905.82 8387.04 11166.70 14053.40 0 12.40 11.75 10.90 10.64 12.31 5.96 9.91 8.40 11.18 14.13 42006 40702 41402 40700 40400 38800 40200 38900 40400 41002 2 438.227 1 131 18 0 1 114 107 8255600 9.465 44 444610000 658727 872195 2620000 10129 343470000 82 22.80 -0.626 1.099 89 1.000 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 5 hcd 481.50 37082.72 206.466 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 3 481.505 1 23 -1 0 1 52 23 401824 27.990 23 16244000 344491 14356 65777 10109 14899000 26 14.10 0.054 0.504 39 1.000 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 6 hcd 549.28 21077.05 128.129 21077.05 0.00 10998.67 0.00 21077.05 2725.50 0.00 0.00 0.00 0.00 6800.70 0 NA 9.19 NA 17.57 2.27 NA NA NA NA 5.66 NA 40302 NA 42102 46600 NA NA NA NA 40300 4 549.279 1 15 -1 0 1 16 15 363656 0.700 5 5941200 347071 519640 1990000 10109 2528900 15 2.49 -0.583 0.430 5 1.000 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 8 hcd 388.72 40605.85 356.719 8087.76 6166.82 1371.27 2418.35 8087.76 5485.35 0.00 0.00 1543.48 1943.96 7436.60 0 6.92 1.54 2.71 9.04 6.13 NA NA 1.72 2.16 8.26 40000 26400 30400 40400 44300 NA NA 28800 28500 38700 5 388.720 7 12 -1 0 1 30 12 478135 28.710 19 10718000 291189 16653 142562 10142 9961100 16 8.60 -0.051 0.283 18 0.969 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 9 hcd 403.21 40667.64 403.251 5860.96 4991.79 1274.12 5860.96 4699.99 4906.33 1782.18 4580.83 0.00 0.00 0.00 0 5.29 1.35 6.21 4.98 5.19 1.89 4.85 NA NA NA 41600 21900 38604 39000 36800 26700 39200 NA NA NA 6 403.214 7 12 -1 0 1 54 12 309628 18.930 25 13671000 232858 16353 50315 3379 12441000 27 14.90 0.086 0.489 41 0.618 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 10 hcd 476.26 14753.41 577.352 6170.43 2622.09 1825.23 2987.08 1852.17 2309.64 1348.42 6170.43 0.00 1735.76 5115.81 0 2.61 1.80 2.95 1.81 2.26 1.31 5.99 NA 1.67 4.93 30500 28200 29400 28800 29800 23300 39004 NA 31200 39200 7 476.262 7 12 -1 0 1 18 12 276349 3.873 4 4751000 277210 71355 309842 3361 3027500 11 5.27 -0.363 0.376 9 0.616 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 13 hcd 455.24 22331.15 207.407 1521.09 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1521.09 0 NA NA NA NA NA NA NA NA NA 1.54 NA NA NA NA NA NA NA NA NA 31600 8 455.243 12 12 -1 0 1 19 12 330250 0.043 5 4566900 330250 7747800 56200000 10118 2203700 12 2.99 -0.545 0.373 5 0.948 MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 14 hcd 411.72 15172.97 126.128 15172.97 15172.97 7654.57 10487.60 9163.71 9064.43 5550.98 6100.78 6920.02 5498.97 9974.23 0 16.25 8.21 11.25 9.85 9.75 5.98 6.57 7.47 5.93 10.83 41906 38300 41200 39900 40500 38800 39600 38600 41800 39002 9 411.719 12 34 -1 0 1 39 34 344633 0.004 15 10577000 257141 86211000 507000000 9997 1705500 34 1.93 -0.722 0.397 5 1.000 Table 2.2 shows the first 10 rows of masic_data. Filter MASIC Data Currently, we recommend keeping entries where at least 50% of the ion population is due to the targeted ion (interference score \\(\\geq\\) 0.5) and not filtering by S/N. # Filter MASIC data masic_data &lt;- filter_masic_data(masic_data, interference_score_threshold = 0.5, s2n_threshold = 0) 2.1.3 Create Study Design Tables To convert from PSMs and reporter ion intensities to meaningful quantitative data, it is necessary to know what are the samples in the reporter channels and what is the intended reference channel (or combination of channels). The entire study design is captured by three tables - fractions, samples, references. With newly processed data, these typically do not exist, and must be created. If the tables already exist, the code to access them is as follows. # Read tables from folder: fractions &lt;- read_tsv(system.file(&quot;extdata/study_design/fractions.txt&quot;, package = &quot;PlexedPiperTestData&quot;)) samples &lt;- read_tsv(system.file(&quot;extdata/study_design/samples.txt&quot;, package = &quot;PlexedPiperTestData&quot;)) references &lt;- read_tsv(system.file(&quot;extdata/study_design/references.txt&quot;, package = &quot;PlexedPiperTestData&quot;)) # If using a data package from the DMS: study_design &lt;- read_study_design_from_DMS(data_package_num) fractions &lt;- study_design$fractions samples &lt;- study_design$samples references &lt;- study_design$references Fractions The fractions table consists of two columns: Dataset and PlexID. The Dataset column contains all of the unique datasets from msnid$Dataset or masic_data$Dataset. The PlexID column contains the plex ID associated with each dataset, and is typically an S followed by a number (S1, S2, etc.). We can extract the plex ID from the datasets. In this case, the plex ID always comes after W, so we can use a regular expression (regex) to capture it (the first argument of gsub). The regex below says to capture an S followed by a single digit that appears after W and before an underscore. # Create fractions table fractions &lt;- data.frame(Dataset = unique(masic_data$Dataset)) %&gt;% mutate(PlexID = gsub(&quot;.*_W_(S\\\\d{1})_.*&quot;, &quot;\\\\1&quot;, Dataset)) Table 2.3: First 10 rows of the fractions table. Dataset PlexID MoTrPAC_Pilot_TMT_W_S1_01_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_02_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_03_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_04_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_05_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_06_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_07_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_08_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_09_12Oct17_Elm_AQ-17-09-02 S1 MoTrPAC_Pilot_TMT_W_S1_10_12Oct17_Elm_AQ-17-09-02 S1 Table 2.3 shows the first 10 rows of fractions. Samples The samples table contains columns PlexID, QuantBlock, ReporterName, ReporterAlias, and MeasurementName. The plex ID must be the same as the plex ID in the fractions table. ReporterName is the reporter ion name (126, 127N, 127C, etc.). ReporterAlias is the intermediate between ReporterName and MeasurementName and is used for defining the reference. MeasurementName determines the column names for the final cross-tab, and must be unique and begin with a letter. MeasurementName is easily constructed by prepending PlexID to the ReporterName. Finally, QuantBlock can be thought of as a way of defining sub-plex. In a typical TMT experiment, QuantBlock is always 1. In case of 5 pairwise comparisons within TMT10, there will be 5 QuantBlocks (1-5) with a reference for each QuantBlock. For this experiment, channel 131 will serve as the reference, so we set MeasurementName to NA when ReporterName is \"131\". This will make the reference channel absent from the quantitative cross-tab. In cases where reporter ion intensities are not normalized by a reference channel (reference = 1) or they are normalized by the average of select channels, do not set any MeasurementName to NA. # TMT10 Reporter Converter table from MSnID package conv &lt;- reporter_converter$tmt10 plexes &lt;- unique(fractions$PlexID) # Reference channel ref_channel &lt;- &quot;131&quot; # Create samples table samples &lt;- data.frame(PlexID = rep(plexes, each = nrow(conv)), ReporterName = rep(conv$ReporterName, length(plexes))) %&gt;% mutate(ReporterAlias = sprintf(&quot;%s_%s&quot;, PlexID, ReporterName), MeasurementName = ReporterAlias, QuantBlock = 1, # Comment out this next part if the reference # is not one of the reporter ion channels. MeasurementName = ifelse(ReporterName == ref_channel, NA, MeasurementName) ) Table 2.4: First 10 rows of the samples table. PlexID ReporterName ReporterAlias MeasurementName QuantBlock S1 126 S1_126 S1_126 1 S1 127N S1_127N S1_127N 1 S1 127C S1_127C S1_127C 1 S1 128N S1_128N S1_128N 1 S1 128C S1_128C S1_128C 1 S1 129N S1_129N S1_129N 1 S1 129C S1_129C S1_129C 1 S1 130N S1_130N S1_130N 1 S1 130C S1_130C S1_130C 1 S1 131 S1_131 NA 1 Table 2.4 shows the first 10 rows of samples. References Reference can be a certain channel, average of multiple channels, or 1. The general form is an expression with ReporterAlias names as variables. It is evaluated for each PlexID/QuantBlock combination and applied to divide reporter ion intensities within corresponding PlexID/QuantBlock. # Create references table references &lt;- samples %&gt;% # Filter to reference channel filter(ReporterName == ref_channel) %&gt;% # Select required columns and rename ReporterAlias to Reference select(PlexID, Reference = ReporterAlias, QuantBlock) Table 2.5: References table. PlexID Reference QuantBlock S1 S1_131 1 S2 S2_131 1 Table 2.5 shows the first 10 rows of references. The code to use the geometric average instead of a single channel as the reference is shown below. The geometric average is the product of the reporter ion channels to the power of (1/number of channels). For each PlexID group, collapse the vector of reporter ion names with *, surround them in parentheses, and raise to the power of (1/number of channels). # Use geometric average as reference references &lt;- samples %&gt;% group_by(PlexID, QuantBlock) %&gt;% summarise(Reference = sprintf(&quot;(%s)^(1/%d)&quot;, paste(ReporterAlias, collapse = &quot;*&quot;), n())) # Do not normalize by reference channel (use 1 as the reference) references &lt;- samples %&gt;% distinct(PlexID, QuantBlock) %&gt;% mutate(Reference = 1) Now that we have the three study design tables, we should save them. # Save study design tables write.table(fractions, file = &quot;fractions.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) write.table(samples, file = &quot;samples.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) write.table(references, file = &quot;references.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) 2.1.4 Create Quantitative Cross-tab This is the final step where MS/MS IDs and reporter ions are linked together and aggregated to the peptide or accession (i.e. protein) level. To retain protein IDs while aggregating to peptide level, set aggregation_level &lt;- c(\"accession\",\"peptide\"). The entries are \\(log_2\\)-transformed after being normalized by the reference. # Set aggregation level aggregation_level &lt;- c(&quot;accession&quot;) # Create cross-tab crosstab &lt;- create_crosstab(msnid, masic_data, aggregation_level = aggregation_level, fractions, samples, references) Table 2.6: First 10 rows of the global quantitative cross-tab. S1_126 S1_127C S1_127N S1_128C S1_128N S1_129C S1_129N S1_130C S1_130N S2_126 S2_127C S2_127N S2_128C S2_128N S2_129C S2_129N S2_130C S2_130N AP_004893.1 0.1419768 0.7628195 0.1653552 0.8662554 0.9453172 -0.6460065 -1.9294467 -0.4321433 -1.2831873 -1.0271227 -0.9390945 0.4883309 -1.7148628 -0.7029685 -0.8794712 -0.1912097 0.3964607 -0.2440478 AP_004894.1 0.8092676 -0.0976095 -0.3113350 0.3215692 0.2171255 -0.3678781 -0.1638689 -0.6696829 -1.2039041 -0.5124954 -0.2364175 -0.4428327 -1.3730408 -0.6711809 -1.3515366 -0.7462995 -0.8338103 -0.2227493 AP_004895.1 0.2078433 -0.2867209 -0.6089756 -0.1162062 -0.3840271 -1.1240967 -0.6908468 -0.6652575 -0.7140383 0.2717217 -0.1448289 -0.1200736 -0.6435709 -0.4287771 -0.6780284 -0.6102404 -0.3896190 -0.1548544 AP_004896.1 -0.1494849 -0.3664339 -0.7314368 -0.1742391 -0.5352280 -1.2945071 -1.0372327 -0.7060783 -0.8299749 0.1939540 -0.2274358 -0.1688422 -0.5251264 -0.4222698 -0.6543311 -0.6741064 -0.3994149 -0.0441485 AP_004898.1 0.0362964 0.7497227 0.4252227 0.4913660 1.1580326 0.1211536 -0.3640632 -0.3019505 -0.8291744 -0.8407749 -0.2796091 -0.4130732 -1.5747761 -0.9449498 -1.8439756 -0.1774225 -1.1083199 -0.4175363 AP_004899.1 0.7140968 -0.1781542 -0.3732752 0.3494902 -0.0615626 -2.1679002 -0.8550940 -0.9026145 -1.4519278 -0.3158081 -0.4056811 -0.4644758 -0.2805080 -0.9023044 -1.0482424 -0.8052899 -0.6675429 -0.3959923 AP_004900.1 -0.3806966 -0.3441177 -0.5883203 -0.0902205 -0.8263700 -0.7060111 -1.0978191 -0.8570849 -1.0769673 -0.1566909 -0.2565750 -0.5707603 -0.5960161 -0.6380722 -0.5524057 -0.6422737 -0.5140577 -0.1386396 AP_004901.1 -0.2839471 -0.5758177 -0.0216835 -0.2468966 0.3802436 -0.7852805 -1.2036962 -1.0623455 -1.3738888 0.0884387 -0.5271134 -0.3024421 -0.8704195 -0.5130666 -0.8245858 -0.3465590 -0.3041638 -0.0778906 NP_001000613.1 0.0642942 -0.2044263 -0.4935404 0.1065480 -0.3240158 0.0233030 -0.7883731 -0.5831656 -1.1649507 -0.0969739 -0.2298260 -0.5051282 -0.9489927 -0.7860575 -0.4803511 -0.4824157 -0.8430505 -0.4220978 NP_001001512.2 -0.2155278 -0.1288367 -0.4900798 -0.2239173 -0.4303687 -0.2496957 -0.9165473 -0.4952781 -1.0160964 -0.1256882 -0.2742136 -0.2713873 -0.5914317 -0.4021118 -0.8604247 -0.6648978 -0.6082902 -0.1742713 In order to demonstrate prioritized inference in Section 2.2, we need to save the row names of this cross-tab. # Save protein names saveRDS(rownames(crosstab), file = &quot;data/3442_global_protein_names.rds&quot;) We should save the cross-tab as well. To do so, we need to convert the row names to a column called protein. # Modify cross-tab for saving crosstab &lt;- crosstab %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(&quot;protein&quot;) # Save cross-tab write.table(crosstab, file = &quot;data/global_quant_crosstab.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) "],["phosphoproteomics-data.html", "2.2 Phosphoproteomics Data", " 2.2 Phosphoproteomics Data This pipeline shows how to process data from the DMS. The number of the data package is 3626. For this section, we need the PlexedPiper package for isobaric quantification and PNNL.DMS.utils to interface with the DMS. Also, some details will be omitted if they were already provided in Section 2.1. # Setup library(PNNL.DMS.utils) library(PlexedPiper) library(Biostrings) library(dplyr) # %&gt;% 2.2.1 Prepare MS/MS Identifications Read MS-GF+ Output # Read MS-GF+ data data_package_num &lt;- 3626 msnid &lt;- read_msgf_data_from_DMS(data_package_num) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 612667 at 55 % FDR ## #peptides: 396540 at 75 % FDR ## #accessions: 121521 at 98 % FDR Remove Non-Phosphorylated Peptides In this case, the phosphorylation of an amino acid is marked by a * appearing after the amino acid. We will not consider unmodified peptides, so we can filter them out. The * is a special character that must be escaped with backslashes, and the backslashes must also be escaped. # Remove non-phosphorylated peptides # (peptides that do not contain a *) msnid &lt;- apply_filter(msnid, &quot;grepl(&#39;\\\\\\\\*&#39;, peptide)&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 537749 at 57 % FDR ## #peptides: 353634 at 76 % FDR ## #accessions: 118817 at 98 % FDR Correct Isotope Selection Error # Correct for isotope selection error msnid &lt;- correct_peak_selection(msnid) Remove Contaminants # Remove contaminants msnid &lt;- apply_filter(msnid, &quot;!grepl(&#39;Contaminant&#39;, accession)&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 537572 at 57 % FDR ## #peptides: 353489 at 76 % FDR ## #accessions: 118797 at 98 % FDR AScore Phospho datasets involve AScore jobs for improving phosphosite localization. There should be one AScore job per data package. The fetched object is a data.frame that links datasets, scans and original PTM localization to newly suggested locations. Importantly, it contains AScore column that signifies the confidence of PTM assignment. AScore &gt; 17 is considered confident. # Filter PTMs by AScore ascore &lt;- get_AScore_results(data_package_num) msnid &lt;- best_PTM_location_by_ascore(msnid, ascore) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 188791 at 30 % FDR ## #peptides: 101873 at 53 % FDR ## #accessions: 90677 at 93 % FDR MS/MS ID Filter: Peptide Level # 1% FDR filter at the peptide level msnid &lt;- filter_msgf_data(msnid, level = &quot;peptide&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 76103 at 0.49 % FDR ## #peptides: 23378 at 1 % FDR ## #accessions: 16090 at 4.7 % FDR MS/MS ID Filter: Protein Level # Get path to FASTA file path_to_FASTA &lt;- path_to_FASTA_used_by_DMS(data_package_num) # Compute number of peptides per 1000 amino acids msnid &lt;- compute_num_peptides_per_1000aa(msnid, path_to_FASTA) # 1% FDR filter at the protein level msnid &lt;- filter_msgf_data(msnid, level = &quot;accession&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 72471 at 0.12 % FDR ## #peptides: 21261 at 0.25 % FDR ## #accessions: 9413 at 0.95 % FDR Inference of Parsimonious Protein Set # Load proteins from global crosstab global_proteins &lt;- readRDS(&quot;data/3442_global_protein_names.rds&quot;) # Inference of parsimonious protein set msnid &lt;- infer_parsimonious_accessions(msnid, unique_only = FALSE, prior = global_proteins) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 72471 at 0.12 % FDR ## #peptides: 21261 at 0.25 % FDR ## #accessions: 2890 at 1.6 % FDR Notice that the protein-level FDR increased above the acceptable threshold, so we need to reapply the filter. # 1% FDR filter at the protein level msnid &lt;- filter_msgf_data(msnid, level = &quot;accession&quot;, fdr.max = 0.01) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 70359 at 0.075 % FDR ## #peptides: 20127 at 0.15 % FDR ## #accessions: 2356 at 0.99 % FDR # Remove Decoy Accessions msnid &lt;- apply_filter(msnid, &quot;!isDecoy&quot;) show(msnid) ## MSnID object ## Working directory: &quot;.&quot; ## #Spectrum Files: 23 ## #PSMs: 70306 at 0 % FDR ## #peptides: 20096 at 0 % FDR ## #accessions: 2333 at 0 % FDR Map Sites to Protein Sequences Prepare FASTA to make sure entry names in FASTA file match MSnID accessions. The plan is to make this conversion automatic. map_mod_sites creates number of columns describing mapping of the site/s onto the protein sequences. The most important for the user is SiteID. # Create AAStringSet fst &lt;- readAAStringSet(path_to_FASTA) # Remove contaminants fst &lt;- fst[!grepl(&quot;Contaminant&quot;, names(fst)), ] # First 6 names head(names(fst)) ## [1] &quot;NP_783171.2 cathepsin R precursor [Rattus norvegicus]&quot; ## [2] &quot;NP_001101862.2 zinc finger protein ZIC 2 [Rattus norvegicus]&quot; ## [3] &quot;NP_113721.4 UDP-glucuronosyltransferase 2B2 precursor [Rattus norvegicus]&quot; ## [4] &quot;NP_714948.1 Ly-49 stimulatory receptor 3 [Rattus norvegicus]&quot; ## [5] &quot;NP_001000704.1 olfactory receptor Olr931 [Rattus norvegicus]&quot; ## [6] &quot;NP_001000638.1 olfactory receptor Olr652 [Rattus norvegicus]&quot; # Modify names to match accessions(msnid) names(fst) &lt;- strsplit(names(fst), split = &quot; &quot;) %&gt;% # Select text before first space lapply(function(x) x[1]) %&gt;% unlist() # First 6 names head(names(fst)) ## [1] &quot;NP_783171.2&quot; &quot;NP_001101862.2&quot; &quot;NP_113721.4&quot; &quot;NP_714948.1&quot; ## [5] &quot;NP_001000704.1&quot; &quot;NP_001000638.1&quot; # Main mapping call msnid &lt;- map_mod_sites(object = msnid, fasta = fst, accession_col = &quot;accession&quot;, peptide_mod_col = &quot;peptide&quot;, mod_char = &quot;*&quot;, site_delimiter = &quot;lower&quot;) Table 2.7: First 10 rows of the processed MS-GF+ results. Dataset ResultID Scan FragMethod SpecIndex Charge PrecursorMZ DelM DelM_PPM MH OriginalPeptide Protein NTT DeNovoScore MSGFScore MSGFDB_SpecEValue Rank_MSGFDB_SpecEValue EValue QValue PepQValue IsotopeError accession calculatedMassToCharge chargeState experimentalMassToCharge isDecoy spectrumFile spectrumID pepSeq peptide maxAScore msmsScore absParentMassErrorPPM peptides_per_1000aa First_AA Last_AA First_AA_First Last_AA_First ProtLen ModShift ModAAs SiteLoc Site SiteCollapsed SiteCollapsedFirst SiteID MoTrPAC_Pilot_TMT_P_S1_06_DIL_28Oct17_Elm_AQ-17-10-03 12697 27321 HCD 2256 3 1045.124 0.003 0.858 3131.346 A.AAAAAGDS*DS*WDADTFSMEDPVRK.V NP_001071138.1 1 146 58 0 1 0.00 0.000 0.000 2 NP_001071138.1 1044.454 3 1044.455 FALSE MoTrPAC_Pilot_TMT_P_S1_06_DIL_28Oct17_Elm_AQ-17-10-03 27321 AAAAAGDSDSWDADTFSMEDPVRK A.AAAAAGDSDS*WDADT*FSMEDPVRK.V 0.000 Inf 1.057 7.722 5 28 5 28 259 9, 14 S, T 14, 19 S14, T19 S14,T19 S14,T19 NP_001071138.1-S14sT19t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 875 23519 HCD 264 3 952.144 0.004 1.538 2854.412 R.AAAASAAEAGIAT*PGTEDSDDALLK.M XP_006232986.1 2 165 129 0 1 0.00 0.000 0.000 0 XP_006232986.1 952.142 3 952.144 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 23519 AAAASAAEAGIATPGTEDSDDALLK R.AAAASAAEAGIAT*PGTEDSDDALLK.M 52.349 Inf 1.625 5.305 238 262 238 262 377 12 T 250 T250 T250 T250 XP_006232986.1-T250t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 12873 23508 HCD 2213 4 714.360 0.007 2.392 2854.412 R.AAAASAAEAGIAT*PGTEDSDDALLK.M XP_006232986.1 2 122 81 0 1 0.00 0.000 0.000 0 XP_006232986.1 714.358 4 714.360 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 23508 AAAASAAEAGIATPGTEDSDDALLK R.AAAASAAEAGIAT*PGTEDSDDALLK.M 17.480 Inf 2.472 5.305 238 262 238 262 377 12 T 250 T250 T250 T250 XP_006232986.1-T250t MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 2731 23697 HCD 502 4 714.610 0.002 0.706 2854.412 R.AAAASAAEAGIAT*PGTEDSDDALLK.M XP_006232986.1 2 135 104 0 1 0.00 0.000 0.000 1 XP_006232986.1 714.358 4 714.359 FALSE MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 23697 AAAASAAEAGIATPGTEDSDDALLK R.AAAASAAEAGIAT*PGTEDSDDALLK.M 26.295 Inf 0.780 5.305 238 262 238 262 377 12 T 250 T250 T250 T250 XP_006232986.1-T250t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 4877 21265 HCD 935 4 800.403 0.006 1.871 3196.577 R.AAAASAAEAGIAT*PGTEGERDSDDALLK.M NP_112621.1 2 194 114 0 1 0.00 0.000 0.000 2 NP_112621.1 799.900 4 799.901 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 21265 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIATPGT*EGERDSDDALLK.M 6.213 Inf 1.902 10.526 238 265 238 265 380 15 T 253 T253 T253 T253 NP_112621.1-T253t MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 6826 21280 HCD 1251 3 1066.532 0.000 -0.095 3196.577 R.AAAASAAEAGIATPGT*EGERDSDDALLK.M NP_112621.1 2 200 94 0 1 0.00 0.000 0.000 1 NP_112621.1 1066.197 3 1066.197 FALSE MoTrPAC_Pilot_TMT_P_S1_07_DIL_28Oct17_Elm_AQ-17-10-03 21280 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIATPGT*EGERDSDDALLK.M 0.000 Inf 0.043 10.526 238 265 238 265 380 15 T 253 T253 T253 T253 NP_112621.1-T253t MoTrPAC_Pilot_TMT_P_S1_09_DIL_28Oct17_Elm_AQ-17-10-03 4625 20810 HCD 736 4 800.150 -0.002 -0.743 3196.577 R.AAAASAAEAGIATPGT*EGERDSDDALLK.M NP_112621.1 2 156 93 0 1 0.00 0.000 0.000 1 NP_112621.1 799.900 4 799.899 FALSE MoTrPAC_Pilot_TMT_P_S1_09_DIL_28Oct17_Elm_AQ-17-10-03 20810 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIATPGTEGERDS*DDALLK.M 5.771 Inf 0.712 10.526 238 265 238 265 380 21 S 259 S259 S259 S259 NP_112621.1-S259s MoTrPAC_Pilot_TMT_P_S1_09_DIL_28Oct17_Elm_AQ-17-10-03 16605 20839 HCD 2489 3 1066.530 -0.006 -1.812 3196.577 R.AAAASAAEAGIATPGTEGERDS*DDALLK.M NP_112621.1 2 159 48 0 1 0.01 0.005 0.007 1 NP_112621.1 1066.197 3 1066.195 FALSE MoTrPAC_Pilot_TMT_P_S1_09_DIL_28Oct17_Elm_AQ-17-10-03 20839 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIATPGTEGERDS*DDALLK.M 0.000 2.148 1.673 10.526 238 265 238 265 380 21 S 259 S259 S259 S259 NP_112621.1-S259s MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 433 21424 HCD 54 3 1066.531 -0.004 -1.125 3196.577 R.AAAASAAEAGIAT*PGTEGERDSDDALLK.M NP_112621.1 2 241 168 0 1 0.00 0.000 0.000 1 NP_112621.1 1066.197 3 1066.196 FALSE MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 21424 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIAT*PGTEGERDSDDALLK.M 32.347 Inf 0.989 10.526 238 265 238 265 380 12 T 250 T250 T250 T250 NP_112621.1-T250t MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 434 21424 HCD 54 3 1066.531 -0.004 -1.125 3196.577 R.AAAASAAEAGIATPGT*EGERDSDDALLK.M NP_112621.1 2 241 168 0 1 0.00 0.000 0.000 1 NP_112621.1 1066.197 3 1066.196 FALSE MoTrPAC_Pilot_TMT_P_S2_07_3Nov17_Elm_AQ-17-10-03 21424 AAAASAAEAGIATPGTEGERDSDDALLK R.AAAASAAEAGIAT*PGTEGERDSDDALLK.M 32.347 Inf 0.989 10.526 238 265 238 265 380 12 T 250 T250 T250 T250 NP_112621.1-T250t Table 2.7 shows the first 10 rows of the processed MS-GF+ output. 2.2.2 Prepare Reporter Ion Intensities Read MASIC Output # Read MASIC data masic_data &lt;- read_masic_data_from_DMS(data_package_num, interference_score = TRUE) Filter MASIC Data # Filter MASIC data masic_data &lt;- filter_masic_data(masic_data, interference_score_threshold = 0.5, s2n_threshold = 0) 2.2.3 Create Study Design Tables Fractions # Create fractions table fractions &lt;- data.frame(Dataset = unique(masic_data$Dataset)) %&gt;% mutate(PlexID = gsub(&quot;.*_P_(S\\\\d{1})_.*&quot;, &quot;\\\\1&quot;, Dataset)) Samples # TMT10 Reporter Converter table from MSnID package conv &lt;- reporter_converter$tmt10 plexes &lt;- unique(fractions$PlexID) # Reference channel ref_channel &lt;- &quot;131&quot; # Create samples table samples &lt;- data.frame(PlexID = rep(plexes, each = nrow(conv)), ReporterName = rep(conv$ReporterName, length(plexes))) %&gt;% mutate(ReporterAlias = sprintf(&quot;%s_%s&quot;, PlexID, ReporterName), MeasurementName = ReporterAlias, QuantBlock = 1, # Comment out this next part if the reference # is not one of the reporter ion channels. MeasurementName = ifelse(ReporterName == ref_channel, NA, MeasurementName) ) References # Create references table references &lt;- samples %&gt;% # Filter to reference channel filter(ReporterName == ref_channel) %&gt;% # Select required columns and rename ReporterAlias to Reference select(PlexID, Reference = ReporterAlias, QuantBlock) 2.2.4 Create Quantitative Cross-tab # Set aggregation level aggregation_level &lt;- c(&quot;accession&quot;, &quot;peptide&quot;) # Create cross-tab crosstab &lt;- create_crosstab(msnid, masic_data, aggregation_level = aggregation_level, fractions, samples, references) Table 2.8: First 10 rows of the phospho quantitative cross-tab. S1_126 S1_127C S1_127N S1_128C S1_128N S1_129C S1_129N S1_130C S1_130N S2_126 S2_127C S2_127N S2_128C S2_128N S2_129C S2_129N S2_130C S2_130N NP_001001512.2@K.S*SEPPPPPPVPEPTNAGK.R -0.5441083 -0.0291611 -0.5540885 -0.1812456 -0.5675833 -0.0427948 -0.8030560 -0.5236890 -1.0398773 NA NA NA NA NA NA NA NA NA NP_001001512.2@K.SS*EPPPPPPVPEPTNAGK.R -0.2806018 -0.2939827 -0.3923442 -0.3242804 -0.6512914 -0.4914234 -1.2105927 -0.6421375 -0.8869142 -0.3079991 -0.8072458 -0.4801256 -0.4458455 -0.7588038 -1.3958746 -0.6640721 -0.7046127 -0.3091972 NP_001001512.2@K.TNSS*PSVNTTASGVEDLNIIQVTIPDDDNER.L NA NA NA NA NA NA NA NA NA -1.4611181 -2.2975481 -1.6828088 -2.3039510 -1.8632844 NA -1.5981389 -2.4732843 -0.4736739 NP_001001512.2@K.TNSSPS*VNTTASGVEDLNIIQVTIPDDDNER.L -1.2580276 -1.3182692 -2.1938861 -2.0017857 0.0219220 -0.7086501 -1.6940153 -1.4681967 -1.5795032 0.3139811 -0.6805752 -0.8132341 -1.7933771 0.0127816 0.2726023 0.2266855 0.5058189 0.9332038 NP_001001512.2@R.RPS*TFGIPR.L NA NA NA NA NA NA NA NA NA -0.7930334 -1.2173509 -0.4608541 -1.2596689 -0.8004630 -0.8584401 -0.4918316 -0.2745069 0.2867235 NP_001001514.1@K.ET*RTSSES*IVSVPASSTSGSPSR.V NA NA NA NA NA NA NA NA NA -0.5242609 -0.2564000 -0.1703421 -0.8016035 -0.6177977 -1.8986707 -0.9217045 -1.1410773 -0.4219050 NP_001001514.1@K.ETRTSS*ESIVSVPASSTSGSPSR.V -0.3952598 -0.3773814 -0.1113785 -0.2246094 -0.5676749 -0.7561756 -0.9173361 -1.0505509 -1.4130691 -0.2275133 -0.8394326 -0.3245755 -0.9394990 -0.5237369 -0.8749379 -0.7834843 -0.5268181 -0.2208240 NP_001001514.1@K.ETRTSSES*IVS*VPASSTSGSPSR.V NA NA NA NA NA NA NA NA NA -0.1167323 0.0249531 0.1045728 -0.6020616 -0.1762188 -0.3440353 -0.2297419 0.1989361 0.4882626 NP_001001514.1@K.GDADT*RTNSPDLDSQS*LSLSSGADQEPLQR.M NA NA NA NA NA NA NA NA NA -0.0742108 -0.2566411 -0.4073881 -1.1553706 -0.7643052 -1.3815904 -1.3611955 -1.0650441 -0.0341310 NP_001001514.1@K.GDADTRTNSPDLDS*QS*LSLSSGADQEPLQR.M -0.8822947 -0.7983921 -0.6040902 -1.0568789 -0.5751194 -0.4792532 -1.1417354 -0.9907350 -0.8330389 NA NA NA NA NA NA NA NA NA We will save the cross-tab for later sections. # Modify cross-tab for saving crosstab &lt;- crosstab %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(&quot;phospho_peptide&quot;) # Save cross-tab write.table(crosstab, file = &quot;data/phospho_quant_crosstab.txt&quot;, sep = &quot;\\t&quot;, quote = FALSE, row.names = FALSE) "],["exploratory-data-analysis.html", "Section 3 Exploratory Data Analysis", " Section 3 Exploratory Data Analysis library(MSnSet.utils) library(ggplot2) library(dplyr) library(scales) # Set the theme for all plots. Base text size is set to 14 pts. theme_set(theme_bw(base_size = 14)) # Load the MSnSet data(cptac_oca) "],["count-features-in-samples.html", "3.1 Count Features in Samples", " 3.1 Count Features in Samples To count the number of features identified in each sample, we use colSums to tally the number of entries that are not NA. # Calculate the number of proteins # identified (not NA) in each sample plot_data &lt;- pData(oca.set) %&gt;% mutate(num_proteins = colSums(!is.na(exprs(oca.set)))) %&gt;% # For the lollipop plot, it is best to sort num_peptides # and preserve the ordering by converting the sample names # to a factor. This is how we can specify the order of categorical # variables in plots. arrange(num_proteins) %&gt;% mutate(sample_name = rownames(.), sample_name = factor(sample_name, levels = sample_name)) # Could also be accomplished with # oca.set$num_proteins = colSums(!is.na(exprs(oca.set))) # but we need to change the ordering for the lollipop plot Three methods of visualizing this information are presented below. We begin with the lollipop plot. 3.1.1 Lollipop Plot Lollipop plots are similar to bar graphs, but they are composed of line segments terminating in points. They are a good alternative to bar graphs because they better minimize the amount of non-data ink. This doesnt matter too much when figures are only made for digital media, but it still reduces the visual clutter that comes with bars; however, it is not a good alternative to stacked bar graphs. In ggplot, we can construct lollipop plots by combining a geom_segment() and a geom_point() layer. # Lollipop plot ggplot(plot_data) + geom_segment(aes(x = 0, xend = num_proteins, y = sample_name, yend = sample_name)) + geom_point(aes(x = num_proteins, y = sample_name)) + scale_x_continuous(name = &quot;Number of Proteins Detected&quot;, # Remove space between data and y axis # (start lines at x = 0) expand = expansion(mult = c(0, 0.05))) + # Remove unnecessary y-axis title and the major y-axis grid lines theme(axis.title.y = element_blank(), panel.grid.major.y = element_blank()) In this case, using a lollipop plot is not a very good use of space. Notice that the plot is lengthened so that all of the sample names are readable, and the number of proteins detected in each is about the same; a lot of the space is just taken up by lines. In this case, it would be better to use a table or another plot type like a boxplot. 3.1.2 Boxplot A boxplot is good for identifying and labeling potential outliers, but it is limited to displaying a summary of the data. We will be using graphics::boxplot() for this example, rather than the ggplot2 equivalent, because it is easier and the y-axis is uncluttered. # Boxplot boxplot(plot_data$num_proteins, horizontal = TRUE, xlab = &quot;Number of Proteins Detected&quot;, col = NA) Notice that the boxplot takes up a lot less space, but it is less informative because we can not directly compare samples. Also, we lose a lot of the fine details of the shape of the distribution. To address the latter point, we can instead use a density plot. 3.1.3 Density Plot A density plot is like a smoothed histogram. In fact, one of the benefits over the histogram is that we dont have to deal with bins, as the choice of the number of bins can drastically change the overall shape of a histogram. ggplot(plot_data) + geom_density(aes(x = num_proteins), # Change fill color, make it translucent, remove outline fill = &quot;lightblue&quot;, alpha = 0.5, color = NA) + scale_x_continuous(name = &quot;Number of Proteins Detected&quot;, # Remove space between data and y axis expand = expansion(mult = 0), limits = c(NA, 7800), breaks = seq(6600, 7800, 200)) + scale_y_continuous(name = &quot;Density&quot;, # Remove space between data and x axis (start y axis at 0) expand = expansion(mult = c(0, 0.05)), # Use scientific notation for labels labels = label_scientific()) + theme_bw(base_size = 14) + # Adjust plot margin so that the 7800 label is not cut off theme(plot.margin = unit(c(6, 16, 6, 6), units = &quot;pt&quot;)) While outliers in a boxplot appear as points beyond the whiskers, outliers in density plots will appear as small bumps in the tails of the distribution. While there are no outliers, in this case, we can see that there are two peaks where the number of identified proteins are concentrated. This is not something that could be captured with a boxplot, so it is useful to try different plot types. "],["estimate-blood-contamination.html", "3.2 Estimate Blood Contamination", " 3.2 Estimate Blood Contamination # NOTE: eval set to FALSE blood_proteins &lt;- &quot;HBA_HUMAN HBB_HUMAN HBD_HUMAN HBG1_HUMAN FIBA_HUMAN FIBB_HUMAN FIBG_HUMAN SPTB1_HUMAN THRB_HUMAN ALBU_HUMAN A1AG1_HUMAN A1AG2_HUMAN CAH1_HUMAN GLPA_HUMAN GLPB_HUMAN GLPC_HUMAN&quot; blood_proteins &lt;- gsub(&quot;\\\\s|\\\\n&quot;, &quot;\\\\|&quot;, blood_proteins) m1$blood_contamination &lt;- apply(exprs(m1)[grepl(blood_proteins, featureNames(m1)), ], 2, mean, na.rm = TRUE) "],["pca.html", "3.3 PCA", " 3.3 PCA 3.3.1 Overview This is the overview for PCA. 3.3.2 PCA Plots # Default plot plot_pca_v3(oca.set, phenotype = &quot;SUBTYPE&quot;) # New legend title legend.title &lt;- &quot;Subtype&quot; plot_pca_v3(oca.set, phenotype = &quot;SUBTYPE&quot;) + # Change the titles of the point color and ellipse fill legends guides(color = guide_legend(title = legend.title), # Do not include this line if show.ellipse = FALSE fill = guide_legend(title = legend.title)) + # Change base text size. theme_set() does not work here theme_bw(base_size = 14) Figure 3.1: This is the figure caption I am referencing Figure 3.1. 3.3.3 List Top-Contributing Features In MSnSet.utils, there is a function that allows us to determine which features contribute the most to each principal component. This is the main part of the code to do this. # V is the matrix of eigenvectors that have been scaled to unit vectors. cutoff &lt;- sqrt(1 / nrow(V)) res &lt;- apply(V, 2, function(w) { # Subset to values at least equal to the cutoff in magnitude x &lt;- w[which(abs(w) &gt;= cutoff)] # Order this subset by magnitude x[order(abs(x), decreasing = TRUE)] }) "],["DEA.html", "Section 4 Differential Expression Analysis", " Section 4 Differential Expression Analysis The overview goes here. For this chapter, we will need the following packages. library(MSnSet.utils) library(ggplot2) library(dplyr) library(tibble) library(scales) # Load the MSnSet data(&quot;longitudinal_biomarker_study&quot;) "],["dea-with-limma.html", "4.1 DEA with limma", " 4.1 DEA with limma This section covers differential expression analysis with the limma package. The basic workflow for DEA with limma is to fit a linear model to each feature, then, empirical Bayesian methods are used to moderate the test statistics The limma users guide is an invaluable resource. 4.1.1 Dichotomous Predictors res1 &lt;- limma_a_b(longitudinal_biomarker_study, model.str = &quot;~ Type&quot;, coef.str = &quot;Type&quot;) 4.1.2 Continuous Predictors 4.1.3 Reference Level Comparisons 4.1.4 Custom Contrasts "],["p-value-histograms.html", "4.2 p-value Histograms", " 4.2 p-value Histograms hist(res1$P.Value, breaks = seq(0, 1, 0.05), main = &quot;Histogram of Case vs Control p-values&quot;, xlab = &quot;p-value&quot;) The histogram is fairly uniform, which means that only a few of the features are likely to be significant after adjustment. hist(res1$adj.P.Val, breaks = seq(0, 1, 0.05), main = &quot;Histogram of Case vs Control Adjusted p-values&quot;, xlab = &quot;BH-adjusted p-value&quot;) After adjustment, only 2 proteins are significantly-different between the case and control groups. "],["volcano-plots.html", "4.3 Volcano Plots", " 4.3 Volcano Plots # Base volcano plot plot_volcano(logFC = res1$logFC, significance = res1$P.Value) plot_data &lt;- res1 %&gt;% rownames_to_column(&quot;feature&quot;) %&gt;% mutate(point_color = case_when( logFC &gt;= 0 &amp; P.Value &lt; 0.05 ~ &quot;Up&quot;, logFC &lt; 0 &amp; P.Value &lt; 0.05 ~ &quot;Down&quot;)) features_to_label &lt;- plot_data %&gt;% # Select top 3 most significant proteins in each group filter(point_color != &quot;NS&quot;) %&gt;% group_by(point_color) %&gt;% slice_min(order_by = P.Value, n = 3) %&gt;% mutate(feature_label = feature) plot_data &lt;- left_join(plot_data, features_to_label) # Add significance cutoff line, color points based on significance # and logFC, label the 3 most significant points for both positive # and negative logFC. plot_volcano(logFC = plot_data$logFC, significance = plot_data$P.Value, sig_threshold = 0.05, threshold_line_color = &quot;black&quot;, point_color = plot_data$point_color, feature_labels = plot_data$feature_label, plot_theme = theme_bw(base_size = 14)) + # Modify point colors scale_color_manual(values = c(&quot;red3&quot;, &quot;#5555ff&quot;), breaks = c(&quot;Up&quot;, &quot;Down&quot;), na.value = &quot;grey70&quot;) + # Remove legend theme(legend.position = &quot;none&quot;) + # Modify plot labels labs(x = expression(paste(&quot;log&quot;[2],&quot;(fold-change)&quot;)), y = &quot;Unadjusted p-value&quot;) "],["pathway-analysis.html", "Section 5 Pathway Analysis", " Section 5 Pathway Analysis In Section 4, we covered analysis at the individual feature level (protein, peptide, phosphoprotein, etc.). While DEA is useful, it is not without its own set of shortcomings. For instance, there may be no features that pass the significance threshold after correcting for multiple hypothesis testing. Alternatively, there may be many features that are statistically significant, and interpreting this list can be tedious and prone to investigator bias toward a hypothesis of interest (Maleki et al., 2020). Another issue is that single-feature analysis fails to detect subtle, yet coordinated changes in groups of related features (Subramanian et al., 2005). In order to address these, and other, issues, pathway analysis instead examines a priori defined gene setsgroups of genes that participate in the same biological pathway, share the same cellular location, etc. In this section, we will explore some common annotation databases, as well as two pathway analysis methods: Over-Representation Analysis (ORA) and Gene Set Enrichment Analysis (GSEA). References "],["annotation-databases.html", "5.1 Annotation Databases", " 5.1 Annotation Databases In this section, we will explore some of the common annotation databases used for pathway analysis. 5.1.1 Gene Ontology The Gene Ontology (GO) database is divided into three separate domains: Biological Process, Cellular Component, and Molecular Function (see the Gene Ontology overview for more details regarding each domain). Each domain is structured as a directed acyclic graph (DAG) where nodes are terms and edges are the relations between the terms (part of, is a, has part, regulates). Nodes can be connected to multiple child and parent nodes, where the group of genes annotated to a child node is a subset of those that are annotated to its parent node(s) (2021; Goeman et al., 2008). Semantic Similarity Due to the DAG structure of each domain, there is often redundancy in pathway analysis results. For example, suppose terms GO:0006119, GO:0009060, and GO:0046034 are significantly over-represented biological processes. GO:0009060 and GO:0046034 are the parent terms of GO:0006119. Due to this relationship, the terms likely provide much of the same information, so the inclusion of all three terms in the output is unnecessary. In order to resolve this redundancy, we can calculate the semantic similarity between pairs of GO terms, which assesses the likeness in meaning of two concepts (Pesquita, 2017). Basically, if two terms are highly related, we can use some other criteria (such as adjusted p-value or level in the DAG) to retain only one of the terms. Below, we use the GOSemSim package to calculate the semantic similarity between the terms. ## Calculate semantic similarity between GO terms library(GOSemSim) library(org.Hs.eg.db) # GO DATA for measuring semantic similarity. # keytype is &quot;ENTREZID&quot; by default and # information content is calculated (computeIC = TRUE) semData &lt;- godata(OrgDb = &quot;org.Hs.eg.db&quot;, ont = &quot;BP&quot;) terms &lt;- c(&quot;GO:0006119&quot;, &quot;GO:0009060&quot;, &quot;GO:0046034&quot;) # measure = &quot;Rel&quot; is the default for clusterProfiler::simplify # See code for clusterProfiler:::simplify_internal sim &lt;- mgoSim(GO1 = terms, GO2 = terms, semData = semData, measure = &quot;Rel&quot;, combine = NULL) Table 5.1: Semantic Similarity of select GO terms GO:0006119 GO:0009060 GO:0046034 GO:0006119 0.998 0.754 0.936 GO:0009060 0.754 0.999 0.128 GO:0046034 0.936 0.128 0.997 If measure is \"Lin\", \"Jiang\", or \"Wang\", the semantic similarity of a term with itself will be 1. This is not true for the other methods. We can see from Table 5.1 that GO:0009060 and GO:0046034 have low semantic similarity, while GO:0006119 is highly similar to its parent terms. This makes sense because the parent terms are not related/connected in the DAG. Now that we have the semantic similarities, we can remove redundant terms. clusterProfiler has a function called simplify that will calculate semantic similarity and remove terms. By default, if there are two terms with a semantic similarity greater than 0.7, simplify retains the term with the lowest adjusted p-value. See this post by Guangchuang Yu for more details on clusterProfiler::simplify. GO Subsets/Slims Another way to handle the redundancy of GO terms is to use a GO slim, which is a subset of more general or research-relevant terms from the GO. GO slims can be downloaded or the biomaRt package can be used to access GO slim accessions. ## Create human GO slim library(biomaRt) library(clusterProfiler) # gcSample data library(dplyr) mart &lt;- useMart(biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) # Uncomment to determine which attributes to select in getBM() # View(listAttributes(mart)) # The GO slim columns are goslim_goa_accession and goslim_goa_description. # We will map from the Entrez IDs in gcSample to these attributes. data(gcSample) universe &lt;- unique(unlist(gcSample)) GO_slim &lt;- getBM(filters = &quot;entrezgene_id&quot;, attributes = c(&quot;entrezgene_id&quot;, &quot;goslim_goa_accession&quot;, &quot;goslim_goa_description&quot;), values = universe, # Subset to these Entrez IDs mart = mart) %&gt;% # Convert entrezgene_id from integer to character mutate_all(as.character) entrezgene_id goslim_goa_accession goslim_goa_description 100 GO:0003674 molecular_function 100 GO:0016810 hydrolase activity, acting on carbon-nitrogen (but not peptide) bonds 100 GO:0008150 biological_process 100 GO:0009058 biosynthetic process 100 GO:0044281 small molecule metabolic process 100 GO:0034641 cellular nitrogen compound metabolic process Unfortunately, not every GO accession maps to a domain when we use biomaRt (unsure why this is the case), so we wont be able to separate the terms. However, there are two ways that we can still use these GO slim accessions. Either follow the steps for using clusterProfiler::enricher (shown in the Pfam subsection of Section 5.2.2) with conversion tables created from org.Hs.eg.db that have been subset to the GO slim accessions, or remove any non GO slim accessions from the final results and readjust the remaining p-values (the easier approach). 5.1.2 Reactome Home - Reactome Pathway Database 5.1.3 KEGG KEGG: Kyoto Encyclopedia of Genes and Genomes 5.1.4 Pfam Pfam: Home page Pfam Documentation profile Hidden Markov Models References "],["ora.html", "5.2 Over-Representation Analysis", " 5.2 Over-Representation Analysis 5.2.1 Overview Over-Representation Analysis (ORA) is used to determine which a priori defined gene sets are more present (over-represented) in a subset of interesting genes than what would be expected by chance (Huang et al., 2009). Essentially, it identifies the gene setsrather than the individual genesthat are significantly different between two conditions. For each gene set, an enrichment p-value is calculated using the Binomial distribution, Hypergeometric distribution, the Fisher exact test, or the Chi-square test. Although this list is not all-encompassing, these are the most popular statistical methods (Huang et al., 2009). Below is the formula for calculating the enrichment p-value for a particular gene set using the Hypergeometric distribution. \\[ P(X\\geq x) = 1 - P(X \\leq x-1) = 1 - \\sum\\limits_{i=0}^{x-1}\\frac{\\hphantom{}{M \\choose i }{N - M \\choose n-i}}{N \\choose n} \\] In this equation, \\(N\\) is the number of background genes, \\(n\\) is the number of interesting (i.e. statistically-significant) genes, \\(M\\) is the number of genes that are annotated to a particular gene set \\(S\\), and \\(x\\) is the number of interesting genes that are annotated to \\(S\\). The numerator of the sum is the number of samples of \\(n\\) genes that can be taken from a population of \\(N\\) genes where exactly \\(i\\) of the genes are annotated to \\(S\\) and \\(n-i\\) are not annotated to \\(S\\). The denominator of the sum is the total number of samples of size \\(n\\) that can be taken from a population of size \\(N\\). For example, suppose we have a list of 8000 genes, of which 400 are differentially expressed. Also suppose that 100 of the 8000 genes are annotated to a particular gene set \\(S\\). Of these 100 genes, 20 are differentially expressed. The probability that 20 or more (up to 100) genes annotated to \\(S\\) are differentially expressed by chance is given by \\[ P(X\\geq 20) = 1 - P(X \\leq 19) = 1-\\sum \\limits_{i=0}^{19}\\frac{\\hphantom{}{100 \\choose i}{8000 - 100 \\choose 400-i}}{8000 \\choose 400} = 7.88 \\times 10^{-8} \\] That is, it is extremely unlikely that 20 of the 100 genes from this set are significantly differentially expressed by chance (at least, prior to adjustment for multiple comparisons). The code to calculate this p-value is phyper(q = 20 - 1, m = 400, n = 8000 - 400, k = 100, lower.tail = FALSE) After a p-value has been calculated for each of the applicable gene sets, a multiple comparison adjustment should be performed. 5.2.2 Examples For these examples, we will show how to perform ORA with the GOstats, clusterProfiler, and ReactomePA packages. The databases that we will cover are Gene Ontology, Reactome, and Pfam. For details on these different annotation databases, please see Section 5.1. ## Setup # Required packages library(clusterProfiler) # GO, KEGG, and custom ORA library(ReactomePA) # Reactome ORA library(GOstats) # GO, KEGG, and Pfam ORA library(PFAM.db) # Map Pfam IDs to descriptions library(org.Hs.eg.db) # Human annotation database library(kableExtra) library(dplyr) Normally, we would use a DEA table to create two character vectors: one for the significantly expressed genes and the other for all genes that were tested (referred to as the background or universe); instead, we will use the gcSample data that comes with clusterProfiler and treat the eighth cluster as our vector of significant genes and the entire list as the gene universe. Each gene is represented by a human Entrez gene ID, which is the default keytype used by the clusterProfiler functions and the only keytype compatible with ReactomePA::enrichPathway. data(&quot;gcSample&quot;) # Data for examples sig_genes &lt;- gcSample[[8]] # significant genes universe &lt;- unique(unlist(gcSample)) # universe It is important to note that the genes should be unique from the start. The terms between any two clusters of gcSample may overlap, so we must use unique for the sake of these examples. If your DEA results are not gene-centric, do NOT use ORA. Instead, switch to GSEA and summarize the ranking metric in some way to make it gene-centric (i.e. take the average, min, max, etc. of the metrics for each gene group). Gene Ontology We will first use the clusterProfiler package to test which biological processes are over-represented in the set of interesting genes. For this example, we will only consider gene sets of size 20 to 500. In order to test either molecular functions, cellular components, or all three ontologies at once, set ont to \"MF\", \"CC\", or \"ALL\", respectively. ## GO BP ORA with clusterProfiler # This takes a while cp_ora_go &lt;- enrichGO( gene = sig_genes, OrgDb = &quot;org.Hs.eg.db&quot;, keyType = &quot;ENTREZID&quot;, ont = &quot;BP&quot;, # BP, CC, MF, or ALL for all ontologies pvalueCutoff = 0.05, qvalueCutoff = 1, # Do not filter by q-value pAdjustMethod = &quot;BH&quot;, universe = universe, minGSSize = 20, maxGSSize = 500, readable = TRUE # Convert Entrez ID to gene symbol ) Table 5.2: Top significantly over-represented biological processes from enrichGO output. ID Description GeneRatio BgRatio pvalue p.adjust geneID GO:0046034 ATP metabolic process 24/232 96/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0006119 oxidative phosphorylation 16/232 49/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0006402 mRNA catabolic process 22/232 93/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:1902600 proton transmembrane transport 12/232 28/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0016071 mRNA metabolic process 35/232 208/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:0006091 generation of precursor metabolites and energy 29/232 159/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0009060 aerobic respiration 12/232 32/3652 0 1e-04 COX4I1/MDH1/HIF1A GO:0006401 RNA catabolic process 22/232 104/3652 0 1e-04 HNRNPU/YWHAZ/RPL13A GO:0010608 posttranscriptional regulation of gene expression 28/232 168/3652 0 3e-04 HNRNPU/MATR3/YWHAZ GO:0042773 ATP synthesis coupled electron transport 11/232 31/3652 0 3e-04 COX4I1/COX8A/COX7C There were 4436 biological processes that were tested. Of these, 2049 passed the size filter, and only 182 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 5.2. Remove Redundant GO Terms By default, if two terms have a semantic similarity above 0.7, clusterProfiler::simplify retains the more significantly over-represented term. # Remove redundant GO terms with simplify cp_ora_go_sim &lt;- simplify(cp_ora_go) Table 5.3: Simplified top significantly over-represented biological processes from enrichGO output. ID Description GeneRatio BgRatio pvalue p.adjust geneID GO:0046034 ATP metabolic process 24/232 96/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0006119 oxidative phosphorylation 16/232 49/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0006402 mRNA catabolic process 22/232 93/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:1902600 proton transmembrane transport 12/232 28/3652 0 0e+00 COX4I1/COX8A/COX7C GO:0016071 mRNA metabolic process 35/232 208/3652 0 0e+00 HNRNPU/YWHAZ/RPL13A GO:0006091 generation of precursor metabolites and energy 29/232 159/3652 0 0e+00 COX4I1/PGK1/TPI1 GO:0010608 posttranscriptional regulation of gene expression 28/232 168/3652 0 3e-04 HNRNPU/MATR3/YWHAZ GO:0009205 purine ribonucleoside triphosphate metabolic process 9/232 21/3652 0 4e-04 RAN/ENO1/ATP5F1B GO:0034097 response to cytokine 45/232 357/3652 0 4e-04 HNRNPU/YWHAZ/SLC25A5 GO:0071345 cellular response to cytokine stimulus 42/232 325/3652 0 4e-04 HNRNPU/YWHAZ/SLC25A5 Notice that GO:0009060 is not present in Table 5.3 anymore, since it was highly similar to GO:0006119, and the latter was more significant. After removing redundant GO terms, 96 pass the significance threshold. Instead of retaining terms based on adjusted p-value, we could ignore significance and instead retain either parent or child terms (select_fun = min and select_fun = max, respectively). The code to do so is provided here. Another alternative would be to use a gene ID to GO slim ID conversion table. See the Semantic Similarity subsection of Section 5.1 for more details. Now, we will perform GO ORA with the GOstats package. We begin by creating an object of class GOHyperGParams and passing it to hyperGTest for calculation of Hypergeometric p-values. We do not filter by p-value, since adjusted p-values are not provided and we must calculate them ourselves. ## GO BP ORA with GOstats hyperg_ora_go &lt;- new( Class = &quot;GOHyperGParams&quot;, ontology = &quot;BP&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, # Do not filter by p-value testDirection = &quot;over&quot;, conditional = FALSE ) %&gt;% hyperGTest() # Hypergeometric testing Now, we need to filter by gene set size (limit 20 to 500), adjust the p-values, and filter based on the adjusted p-values. res_go_ora &lt;- summary(hyperg_ora_go) %&gt;% # Filter by size filter(Size &gt;= 20, Size &lt;= 500) %&gt;% # Adjust p-values mutate(p.adjust = p.adjust(Pvalue, method = &quot;BH&quot;)) %&gt;% # Filter and sort by adjusted p-values arrange(p.adjust) %&gt;% filter(p.adjust &lt; 0.05) Table 5.4: Over-represented biological processes obtained using the GOstats package. GOBPID Term OddsRatio ExpCount Count Size Pvalue p.adjust GO:0046034 ATP metabolic process 5.3654 6.0986 24 96 0 0e+00 GO:0006119 oxidative phosphorylation 7.6027 3.1128 16 49 0 0e+00 GO:0006402 mRNA catabolic process 4.9415 5.9080 22 93 0 0e+00 GO:1902600 proton transmembrane transport 11.6045 1.7788 12 28 0 0e+00 GO:0016071 mRNA metabolic process 3.3346 13.2136 35 208 0 0e+00 GO:0006091 generation of precursor metabolites and energy 3.6154 10.1008 29 159 0 0e+00 GO:0009060 aerobic respiration 9.2727 2.0329 12 32 0 1e-04 GO:0006401 RNA catabolic process 4.2646 6.6068 22 104 0 1e-04 GO:0010608 posttranscriptional regulation of gene expression 3.2157 10.6725 28 168 0 3e-04 GO:0042773 ATP synthesis coupled electron transport 8.4615 1.9693 11 31 0 3e-04 There were 4435 biological processes that were tested. Of these, 2049 passed the size filter, and only 182 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 5.4. The total number of biological processes that were tested is 1 less than the number reported from the enrichGO results. This is because enrichGO includes the biological_process root GO:0008150. Remove Redundant GO Terms While there is no function akin to clusterProfiler::simplify to process results, there is an argument called conditional. Setting conditional to TRUE tells hyperGTest to use the term-term relationships when calculating p-values (Falcon et al., 2021). This approach is actually more akin to Modular Enrichment Analysis (MEA) than Over-Representation Analysis (also called Singular Enrichment Analysis; Huang et al. (2009)). ## Conditional GO BP ORA with GOstats hyperg_ora_go_sim &lt;- new( Class = &quot;GOHyperGParams&quot;, ontology = &quot;BP&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, # Do not filter by p-value testDirection = &quot;over&quot;, conditional = TRUE # Use structure of GO graph ) %&gt;% hyperGTest() # Hypergeometric testing We will process the results the same as before and compare. Table 5.5: Simplified over-represented biological processes obtained using the GOstats package. GOBPID Term OddsRatio ExpCount Count Size Pvalue p.adjust GO:0046034 ATP metabolic process 7.4290 2.3261 12 38 0e+00 0.0011 GO:0042773 ATP synthesis coupled electron transport 8.4615 1.9693 11 31 0e+00 0.0011 GO:0043043 peptide biosynthetic process 3.2288 9.0208 24 142 0e+00 0.0028 GO:0046364 monosaccharide biosynthetic process 6.7593 2.2870 11 36 0e+00 0.0028 GO:0009145 purine nucleoside triphosphate biosynthetic process 10.1429 1.2705 8 20 0e+00 0.0044 GO:0009201 ribonucleoside triphosphate biosynthetic process 8.6888 1.3976 8 22 0e+00 0.0083 GO:0006094 gluconeogenesis 6.5618 1.8981 9 30 1e-04 0.0127 GO:0009141 nucleoside triphosphate metabolic process 6.2336 1.9693 9 31 1e-04 0.0130 GO:0034655 nucleobase-containing compound catabolic process 2.8081 9.2114 22 145 1e-04 0.0130 GO:0048002 antigen processing and presentation of peptide antigen 3.8578 4.4469 14 70 1e-04 0.0130 Now, only 2953 terms showed up in the summary. Of these, 1445 passed the size filter, and 31 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 5.5. The major difference between these results and the ones from enrichGO after using simplify is that p-value adjustment is not affected by simplify, as redundant GO terms are removed after. The conditional method is actually more akin to performing modular enrichment analysis (MEA) than ORA (also called singular enrichment analysis) Reactome GOstats does not have a dedicated class to test for Reactome pathway over-representation, but we can use ReactomePA. For this example, we will only consider pathways of size 20 to 500. enrichPathway only accepts Entrez gene IDs as input. In cases where the Entrez ID is not readily available, we must convert to them. Alternatively, we could use the custom ORA function enricher, which allows us to use any ID type (use demonstrated in Pfam example). ## Reactome ORA with ReactomePA cp_ora_reactome &lt;- enrichPathway( gene = sig_genes, organism = &quot;human&quot;, pvalueCutoff = 0.05, pAdjustMethod = &quot;BH&quot;, qvalueCutoff = 1, # Do not filter by q-value universe = universe, minGSSize = 20, maxGSSize = 500, readable = TRUE # Convert Entrez ID to gene symbol ) Table 5.6: Top significantly over-represented Reactome pathways from enrichPathway output. ID Description GeneRatio BgRatio pvalue p.adjust geneID R-HSA-8953897 Cellular responses to external stimuli 39/193 185/2548 0 0e+00 COX4I1/RPL13A/SKP1 R-HSA-2262752 Cellular responses to stress 37/193 181/2548 0 0e+00 COX4I1/RPL13A/SKP1 R-HSA-163200 Respiratory electron transport, ATP synthesis by chemiosmotic coupling, and heat production by uncoupling proteins. 15/193 37/2548 0 0e+00 COX4I1/COX8A/COX7C R-HSA-5663205 Infectious disease 38/193 212/2548 0 0e+00 PRKAR1A/SLC25A5/RPL13A R-HSA-9711123 Cellular response to chemical stress 18/193 61/2548 0 0e+00 COX4I1/SKP1/PSMB7 R-HSA-9707564 Cytoprotection by HMOX1 16/193 50/2548 0 0e+00 COX4I1/SKP1/PSMB7 R-HSA-1428517 The citric acid (TCA) cycle and respiratory electron transport 17/193 57/2548 0 0e+00 COX4I1/LDHB/COX8A R-HSA-72766 Translation 17/193 58/2548 0 0e+00 RPL13A/RPL29/KARS1 R-HSA-5628897 TP53 Regulates Metabolic Genes 12/193 34/2548 0 1e-04 COX4I1/YWHAZ/YWHAQ R-HSA-8953854 Metabolism of RNA 31/193 181/2548 0 3e-04 HNRNPU/YWHAZ/RPL13A There were 919 Reactome pathways that were tested. Of these, 388 passed the size filter, and 155 were significantly over-represented after multiple testing correction. The top 10 are shown in Table 5.6. Pfam While there is no dedicated ORA function for Pfam entries in clusterProfiler, there is a general ORA function called enricher that can be used with any term to gene conversion table. This function is also much faster than the dedicated enrichGO and enrichPathway functions, so it may be preferred if running many separate over-representation analyses. The conversion table is generated with the biomaRt package as follows. # NOT RUN --- library(biomaRt) mart &lt;- useMart(biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) View(listAttributes(mart)) # Determine which columns to return conv_tbl &lt;- getBM(filters = &quot;entrezgene_id&quot;, attributes = c(&quot;entrezgene_id&quot;, &quot;pfam&quot;), values = universe, mart = mart) %&gt;% mutate_all(as.character) saveRDS(conv_tbl, file = &quot;data/pfam_conv_tbl.rds&quot;) In addition to the term to gene conversion table, we can supply a term to name table that maps Pfam IDs to human-readable descriptions. While org.Hs.eg.db does not provide Pfam descriptions, the PFAM.db annotation data package has a Bimap with this information. Now that we have the two conversion tables, we will perform ORA and limit the output to Pfam entries of size 15 to 500. # Entrez to Pfam ID mapping file created with biomaRt package TERM2GENE &lt;- readRDS(&quot;data/pfam_conv_tbl.rds&quot;) %&gt;% # Remove blank terms filter(pfam != &quot;&quot;) %&gt;% # Reorder and rename columns. # ! These specific column names must be used in this exact order dplyr::select(term = pfam, gene = entrezgene_id) # Pfam IDs to descriptions library(PFAM.db) TERM2NAME &lt;- as.data.frame.Bimap(PFAMDE) # ! These specific column names must be used in this exact order colnames(TERM2NAME) &lt;- c(&quot;term&quot;, &quot;name&quot;) ## Pfam ORA with clusterProfiler cp_ora_pfam &lt;- enricher( gene = sig_genes, pvalueCutoff = 0.05, pAdjustMethod = &quot;BH&quot;, universe = universe, minGSSize = 15, maxGSSize = 500, qvalueCutoff = 1, TERM2GENE = TERM2GENE, TERM2NAME = TERM2NAME ) Table 5.7: Top Pfam entries from enricher output. ID Description GeneRatio BgRatio pvalue p.adjust geneID PF01391 Collagen triple helix repeat (20 copies) 7/236 31/3675 0.0029 0.0687 1293/1281/1277 PF00076 RNA recognition motif. (a.k.a. RRM, RBD, or RNP domain) 7/236 55/3675 0.0599 0.5363 1153/3182/5042 PF00092 von Willebrand factor type A domain 3/236 15/3675 0.0670 0.5363 1293/1292/1291 PF00071 Ras family 3/236 23/3675 0.1804 0.9022 5901/6009/388 PF07679 Immunoglobulin I-set domain 3/236 27/3675 0.2489 0.9022 23022/3490/25878 PF13499 EF-hand domain pair 2/236 20/3675 0.3711 0.9022 6717/80303 PF00271 Helicase conserved C-terminal domain 2/236 24/3675 0.4623 0.9022 1973/10521 PF00412 LIM domain 2/236 24/3675 0.4623 0.9022 1396/9124 PF13855 Leucine rich repeat 3/236 42/3675 0.5123 0.9022 4060/1634/25878 PF00046 Homeodomain 2/236 27/3675 0.5254 0.9022 5087/29956 There were 275 Pfam entries that were tested. Of these, 24 passed the size filter, and 0 were significantly over-represented after multiple testing correction. While none were significant, the top 10 are shown in Table 5.7 so that we can compare it to the results from hyperGTest. Now, we will perform Pfam ORA with the GOstats package. We begin by constructing a new object of class PFAMHyperGParams and then passing it to hyperGTest for calculation of Hypergeometric p-values. We do not filter by p-value, since adjusted p-values are not provided and we must calculate them ourselves. ## Pfam ORA with GOstats hyperg_pfam_ora &lt;- new( Class = &quot;PFAMHyperGParams&quot;, geneIds = sig_genes, universeGeneIds = universe, annotation = &quot;org.Hs.eg.db&quot;, pvalueCutoff = 1, testDirection = &quot;over&quot; ) %&gt;% hyperGTest() # Hypergeometric testing Now, we need to filter by gene set size (limit 15 to 500) and adjust the p-values. Normally, we would also filter based on the adjusted p-values, but we will skip this step so that we can compare the output with that of clusterProfiler::enricher. res_pfam_ora &lt;- summary(hyperg_pfam_ora) %&gt;% # Filter by Pfam entry size filter(Size &gt;= 15, Size &lt;= 500) %&gt;% # Adjust p-values mutate(p.adjust = p.adjust(Pvalue, method = &quot;BH&quot;)) %&gt;% # Sort by adjusted p-values arrange(p.adjust) The last step is to add the human-readable Pfam descriptions. We will use the TERM2NAME data frame from before and just change the column names for easy joining. # Pfam entries to descriptions colnames(TERM2NAME) &lt;- c(&quot;PFAMID&quot;, &quot;Description&quot;) res_pfam_ora &lt;- left_join(res_pfam_ora, TERM2NAME) Table 5.8: Top Pfam entries obtained using the GOstats package. PFAMID Description OddsRatio ExpCount Count Size Pvalue p.adjust PF01391 Collagen triple helix repeat (20 copies) 4.5163 1.9368 7 30 0.0024 0.0530 PF00076 RNA recognition motif. (a.k.a. RRM, RBD, or RNP domain) 2.1478 3.5509 7 55 0.0613 0.4980 PF00092 von Willebrand factor type A domain 3.6568 0.9684 3 15 0.0679 0.4980 PF00071 Ras family 2.1888 1.4849 3 23 0.1824 0.8976 PF07679 Immunoglobulin I-set domain 1.9016 1.6786 3 26 0.2338 0.8976 PF13499 EF-hand domain pair 1.8182 1.1621 2 18 0.3256 0.8976 PF00271 Helicase conserved C-terminal domain 1.3200 1.5495 2 24 0.4652 0.8976 PF00412 LIM domain 1.3200 1.5495 2 24 0.4652 0.8976 PF13855 Leucine rich repeat 1.1458 2.6470 3 41 0.4995 0.8976 PF00595 PDZ domain 1.2092 1.6786 2 26 0.5079 0.8976 260 Pfam entries were tested. Of these, 16 passed the size filter, and none were significantly over-represented after multiple testing correction. The top 10 are shown in Table 5.8. Notice that this table and Table 5.7 are different. For one, the sizes of the entries are not always the same. For example, PF01391 has size 31 according to the mapping file created from the biomaRt package, but only size 30 according to org.Hs.eg.db. This leads to differences in the number of total Pfam entries that remain after filtering by size and, subsequently, differences in the adjusted p-values. 5.2.3 Considerations The choice of the threshold for statistical significance and the multiple comparison adjustment method can greatly impact the analysis (Huang et al., 2009). ORA fails to incorporate direction of gene regulation. (Are the genes in a given set mainly up or down-regulated?). It is not a good idea to split DEA results by the sign of the logFC and apply ORA to the two sets. Use GSEA instead. If few genes are differentially expressed, ORA is unlikely to yield useful or reliable results. For example, suppose 30 out of 8000 genes are significant. 100 of the genes are annotated to a particular gene set, of which 3 are significant. The associated Hypergeometric p-value is 0.006, and this set would be considered significantly over-represented at the 0.01 level (at least, prior to adjustment for multiple comparisons); however, if only 2 of the genes in this set are significant, this p-value increases 10-fold to 0.0536 and is no longer significant even at the 0.05 level. If the DEA results are not gene-centric (i.e. DEA was performed at the protein or phosphosite level), then there may be cases where two proteins are associated with the same gene, but only one is significantly differentially abundant. In this case, there is no way to categorize the gene as significant or not, so ORA should not be used. The other problem that could arise if the DEA results are not gene-centric is that the same gene may be counted as significant multiple times, which leads to artificial over-representation. References "],["gsea.html", "5.3 Gene Set Enrichment Analysis", " 5.3 Gene Set Enrichment Analysis 5.3.1 Overview Gene Set Enrichment Analysis (GSEA) employs a no-cutoff strategy that utilizes some experimental value (such as fold change, the moderated t-statistic, or Z-Score) to rank a list of \\(N\\) genes in descending order. Using this ranked list \\(L\\), the values of the ranking metric, and an a priori defined gene set \\(S\\), we can calculate an enrichment score. This is done by walking down the list \\(L\\), increasing a running-sum statistic when we encounter a gene in \\(S\\) and decreasing it when we encounter genes not in \\(S\\). The maximum deviation from zero of this running-sum statistic is the enrichment score for \\(S\\), denoted by \\(ES(S)\\). If the genes in \\(S\\) are randomly distributed throughout \\(L\\), \\(ES(S)\\) will be relatively small; however, if they are not randomly distributed (i.e. primarily located near either end of \\(L\\)), then \\(ES(S)\\) will be relatively large (Mootha et al., 2003; Subramanian et al., 2005). To assess the statistical significance of each \\(ES(S)\\), we permute the phenotype labels in the expression data and recalculate the ranking metric and subsequent enrichment score \\(ES_{\\text{NULL}}\\). Alternatively, we could permute the genes: for a given \\(S\\) of size \\(k\\), we randomly select \\(k\\) genes from the list \\(L\\) and calculate an enrichment score \\(ES_{\\text{NULL}}\\). This is the method implemented by fgsea and, consequently, clusterProfiler, though it is not strictly accurate because it does not preserve the correlations between genes (Subramanian et al., 2005). Regardless of the permutation approach, it is repeated one thousand to tens of thousands of times to produce an empirical null distribution. Then, we define the nominal p-value as the proportion of \\(ES_{\\text{NULL}}\\) that are more extreme than \\(ES(S)\\). Once a p-value has been obtained for every gene set, we apply an appropriate adjustment for multiple hypothesis testing. The phenotype randomization approach is summarized in Figure 1: Schematic overview of GSEA in the paper by Mootha et al. (2003). The mathematical details of GSEA are provided below. Let \\(x = \\{x_1, ..., x_N : x_i &gt; x_j \\ \\forall i &lt; j\\}\\) be the vector of ranking metric values. Also let \\(S\\) be a particular gene set of size \\(k\\) and \\(NS = \\sum\\limits_{i \\in S}|x_i|\\). We define the value of the running sum at gene \\(i\\) as \\[ r_i = \\begin{cases} 0 &amp; \\text{if } i = 0, \\\\ r_{i-1} + \\frac{1}{NS}|x_i| &amp; \\text{if } 1 \\leq i \\leq N \\text{ and } i \\in S, \\\\ r_{i-1} - \\frac{1}{N-k} &amp; \\text{if } 1 \\leq i \\leq N \\text{ and } i \\not\\in S \\end{cases} \\] \\(ES(S)\\) is the largest (in terms of absolute value) element of \\(r_N\\). This notation is a slightly modified version of what is presented in the paper by Korotkevich et al. (2016). 5.3.2 Examples 5.3.2.1 Gene Ontology 5.3.2.2 Reactome 5.3.2.3 Pfam 5.3.3 Considerations GSEA is not influenced by an arbitrary cutoff for statistical significance. This is especially useful when only a few features pass this threshold after adjustment for multiple testing, and it also means that it does not depend on the choice of p-value adjustment. All genes in an experiment are allowed to contribute to the enrichment analysis in differing degrees (Huang et al., 2009). This addresses the point brought up at the beginning of Section 5 that biological changes may be the result of small changes in many related genes. GSEA allows for the detection of such changes. The sign of the enrichment score tell us in which category a set of genes is primarily up- or down-regulated. For example, suppose we test the difference between the means of two groups for each gene using the limma package. Since ranking metrics incorporate the direction of change, a positive enrichment score would mean that the majority of genes in that particular set are up-regulated in A relative to B/down-regulated in B relative to A. The choice of ranking metric is important. References "],["references-2.html", "References", " References "]]
