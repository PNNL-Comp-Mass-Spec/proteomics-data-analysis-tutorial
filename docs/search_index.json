[["index.html", "A Tutorial for Proteomics Data Analysis with R/Bioconductor Section 1 Welcome!", " A Tutorial for Proteomics Data Analysis with R/Bioconductor Tyler Sagendorf September 07, 2021 Section 1 Welcome! This tutorial is very much a work-in progress. Even sections that appear finished are likely to be changed. I will try to update this weekly, or when significant progress has been made. Thank you for your patience. "],["exploratory-data-analysis.html", "Section 2 Exploratory Data Analysis", " Section 2 Exploratory Data Analysis What is exploratory data analysis? Explain. library(MSnSet.utils) library(ggplot2) library(dplyr) library(scales) # Set the theme for all plots. Base text size is set to 14 pts. theme_set(theme_bw(base_size = 14)) # Load the MSnSet data(cptac_oca) "],["number-of-features-identified-in-each-sample.html", "2.1 Number of Features Identified in Each Sample", " 2.1 Number of Features Identified in Each Sample To count the number of features identified in each sample, we use colSums to tally the number of entries that are not NA. # Calculate the number of proteins # identified (not NA) in each sample plot_data &lt;- pData(oca.set) %&gt;% mutate(num_proteins = colSums(!is.na(exprs(oca.set)))) %&gt;% # For the lollipop plot, it is best to sort num_peptides # and preserve the ordering by converting the sample names # to a factor. This is how we can specify the order of categorical # variables in plots. arrange(num_proteins) %&gt;% mutate(sample_name = rownames(.), sample_name = factor(sample_name, levels = sample_name)) # Could also be accomplished with # oca.set$num_proteins = colSums(!is.na(exprs(oca.set))) # but we need to change the ordering for the lollipop plot Three methods of visualizing this information are presented below. We begin with the lollipop plot. 2.1.1 Lollipop Plot Lollipop plots are similar to bar graphs, but they are composed of line segments terminating in points. They are a good alternative to bar graphs because they better minimize the amount of non-data ink. This doesnt matter too much when figures are only made for digital media, but it still reduces the visual clutter that comes with bars; however, it is not a good alternative to stacked bar graphs. In ggplot, we can construct lollipop plots by combining a geom_segment() and a geom_point() layer. # Lollipop plot ggplot(plot_data) + geom_segment(aes(x = 0, xend = num_proteins, y = sample_name, yend = sample_name)) + geom_point(aes(x = num_proteins, y = sample_name)) + scale_x_continuous(name = &quot;Number of Proteins Detected&quot;, # Remove space between data and y axis # (start lines at x = 0) expand = expansion(mult = c(0, 0.05))) + # Remove unnecessary y-axis title and the major y-axis grid lines theme(axis.title.y = element_blank(), panel.grid.major.y = element_blank()) In this case, using a lollipop plot is not a very good use of space. Notice that the plot is lengthened so that all of the sample names are readable, and the number of proteins detected in each is about the same; a lot of the space is just taken up by lines. In this case, it would be better to use a table or another plot type like a boxplot. 2.1.2 Boxplot A boxplot is good for identifying and labeling potential outliers, but it is limited to displaying a summary of the data. We will be using graphics::boxplot() for this example, rather than the ggplot2 equivalent, because it is easier and the y-axis is uncluttered. # Boxplot boxplot(plot_data$num_proteins, horizontal = TRUE, xlab = &quot;Number of Proteins Detected&quot;, col = NA) Notice that the boxplot takes up a lot less space, but it is less informative because we can not directly compare samples. Also, we lose a lot of the fine details of the shape of the distribution. To address the latter point, we can instead use a density plot. 2.1.3 Density Plot A density plot is like a smoothed histogram. In fact, one of the benefits over the histogram is that we dont have to deal with bins, as the choice of the number of bins can drastically change the overall shape of a histogram. ggplot(plot_data) + geom_density(aes(x = num_proteins), # Change fill color, make it translucent, remove outline fill = &quot;lightblue&quot;, alpha = 0.5, color = NA) + scale_x_continuous(name = &quot;Number of Proteins Detected&quot;, # Remove space between data and y axis expand = expansion(mult = 0), limits = c(NA, 7800), breaks = seq(6600, 7800, 200)) + scale_y_continuous(name = &quot;Density&quot;, # Remove space between data and x axis (start y axis at 0) expand = expansion(mult = c(0, 0.05)), # Use scientific notation for labels labels = label_scientific()) + theme_bw(base_size = 14) + # Adjust plot margin so that the 7800 label is not cut off theme(plot.margin = unit(c(6, 16, 6, 6), units = &quot;pt&quot;)) While outliers in a boxplot appear as points beyond the whiskers, outliers in density plots will appear as small bumps in the tails of the distribution. While there are no outliers, in this case, we can see that there are two peaks where the number of identified proteins are concentrated. This is not something that could be captured with a boxplot, so it is useful to try different plot types. "],["estimate-blood-contamination.html", "2.2 Estimate Blood Contamination", " 2.2 Estimate Blood Contamination What are the major blood proteins? Hemoglobin alpha, beta, delta, gamma 1; fibrinogen alpha, beta, gamma; albumin, spectrin, # NOTE: eval set to FALSE blood_proteins &lt;- &quot;HBA_HUMAN HBB_HUMAN HBD_HUMAN HBG1_HUMAN FIBA_HUMAN FIBB_HUMAN FIBG_HUMAN SPTB1_HUMAN THRB_HUMAN ALBU_HUMAN A1AG1_HUMAN A1AG2_HUMAN CAH1_HUMAN GLPA_HUMAN GLPB_HUMAN GLPC_HUMAN&quot; blood_proteins &lt;- gsub(&quot;\\\\s|\\\\n&quot;, &quot;\\\\|&quot;, blood_proteins) m1$blood_contamination &lt;- apply(exprs(m1)[grepl(blood_proteins, featureNames(m1)), ], 2, mean, na.rm = TRUE) "],["pca.html", "2.3 PCA", " 2.3 PCA 2.3.1 Overview This is the overview for PCA. 2.3.2 PCA Plots # Default plot plot_pca_v3(oca.set, phenotype = &quot;SUBTYPE&quot;) # New legend title legend.title &lt;- &quot;Subtype&quot; plot_pca_v3(oca.set, phenotype = &quot;SUBTYPE&quot;) + # Change the titles of the point color and ellipse fill legends guides(color = guide_legend(title = legend.title), # Do not include this line if show.ellipse = FALSE fill = guide_legend(title = legend.title)) + # Change base text size. theme_set() does not work here theme_bw(base_size = 14) Figure 2.1: This is the figure caption I am referencing Figure 2.1. 2.3.3 List Top-Contributing Features In MSnSet.utils, there is a function that allows us to determine which features contribute the most to each principal component. This is the main part of the code to do this. # V is the matrix of eigenvectors that have been scaled to unit vectors. cutoff &lt;- sqrt(1 / nrow(V)) res &lt;- apply(V, 2, function(w) { # Subset to values at least equal to the cutoff in magnitude x &lt;- w[which(abs(w) &gt;= cutoff)] # Order this subset by magnitude x[order(abs(x), decreasing = TRUE)] }) "],["DEA.html", "Section 3 Differential Expression Analysis", " Section 3 Differential Expression Analysis The overview goes here. For this chapter, we will need the following packages. library(MSnSet.utils) library(ggplot2) library(dplyr) library(tibble) library(scales) # Load the MSnSet data(&quot;longitudinal_biomarker_study&quot;) "],["dea-with-limma.html", "3.1 DEA with limma", " 3.1 DEA with limma This section covers differential expression analysis with the limma package. The basic workflow for DEA with limma is to fit a linear model to each feature, then, empirical Bayesian methods are used to moderate the test statistics The limma users guide is an invaluable resource. 3.1.1 Dichotomous Predictors res1 &lt;- limma_a_b(longitudinal_biomarker_study, model.str = &quot;~ Type&quot;, coef.str = &quot;Type&quot;) 3.1.2 Continuous Predictors 3.1.3 Reference Level Comparisons 3.1.4 Custom Contrasts "],["p-value-histograms.html", "3.2 p-value Histograms", " 3.2 p-value Histograms hist(res1$P.Value, breaks = seq(0, 1, 0.05), main = &quot;Histogram of Case vs Control p-values&quot;, xlab = &quot;p-value&quot;) The histogram is fairly uniform, which means that only a few of the features are likely to be significant after adjustment. hist(res1$adj.P.Val, breaks = seq(0, 1, 0.05), main = &quot;Histogram of Case vs Control Adjusted p-values&quot;, xlab = &quot;BH-adjusted p-value&quot;) After adjustment, only 2 proteins are significantly-different between the case and control groups. "],["volcano-plots.html", "3.3 Volcano Plots", " 3.3 Volcano Plots # Base volcano plot plot_volcano(logFC = res1$logFC, significance = res1$P.Value) plot_data &lt;- res1 %&gt;% rownames_to_column(&quot;feature&quot;) %&gt;% mutate(point_color = case_when( logFC &gt;= 0 &amp; P.Value &lt; 0.05 ~ &quot;Up&quot;, logFC &lt; 0 &amp; P.Value &lt; 0.05 ~ &quot;Down&quot;)) features_to_label &lt;- plot_data %&gt;% # Select top 3 most significant proteins in each group filter(point_color != &quot;NS&quot;) %&gt;% group_by(point_color) %&gt;% slice_min(order_by = P.Value, n = 3) %&gt;% mutate(feature_label = feature) plot_data &lt;- left_join(plot_data, features_to_label) # Add significance cutoff line, color points based on significance # and logFC, label the 3 most significant points for both positive # and negative logFC. plot_volcano(logFC = plot_data$logFC, significance = plot_data$P.Value, sig_threshold = 0.05, threshold_line_color = &quot;black&quot;, point_color = plot_data$point_color, feature_labels = plot_data$feature_label, plot_theme = theme_bw(base_size = 14)) + # Modify point colors scale_color_manual(values = c(&quot;red3&quot;, &quot;#5555ff&quot;), breaks = c(&quot;Up&quot;, &quot;Down&quot;), na.value = &quot;grey70&quot;) + # Remove legend theme(legend.position = &quot;none&quot;) + # Modify plot labels labs(x = expression(paste(&quot;log&quot;[2],&quot;(fold-change)&quot;)), y = &quot;Unadjusted p-value&quot;) "],["enrich.html", "Section 4 Enrichment Analysis", " Section 4 Enrichment Analysis While single-gene analysis (Section 3) is a useful tool, it is not without its own set of shortcomings. For instance, there may be no genes that pass the significance threshold after correcting for multiple hypothesis testing. Alternatively, there may be many genes that are statistically significant, and interpreting this list can be tedious and prone to investigator bias toward a hypothesis of interest (Maleki et al., 2020). Another issue is that single-gene analysis fails to detect biological processesthat are distributed across an entire network of genes and subtle at the level of individual genes. That is, it is liable to miss effects that are the result of small changes in many related genes. In order to address these and other issues, enrichment analysis (also called over-representation analysis) analyzes gene setsgroups of genes that share [a] common biological function, chromosomal location, involvement in a pathway, etc.rather than individual genes (Subramanian et al., 2005). [General principle of enrichment analysis] Enrichment analysis approaches can be classified into three groups: singular enrichment analysis (SEA), gene set enrichment analysis (GSEA), and modular enrichment analysis (MEA) (Huang et al., 2009). References "],["sea.html", "4.1 SEA", " 4.1 SEA Singular Enrichment Analysis (SEA) is used to determine which gene sets are over-represented in a subset of interesting genes taken from a set of background genes. For each gene set, an enrichment p-value is calculated using the Binomial distribution, Hypergeometric distribution, the Fisher exact test, or the Chi-square test. Although this list is not all-encompassing, these are the most popular statistical methods (Huang et al., 2009). Below is the formula for calculating the enrichment p-value for a particular gene set using the Hypergeometric distribution. \\[ P(X\\geq x) = 1 - P(X \\leq x-1) = 1 - \\sum\\limits_{i=0}^{x-1}\\frac{\\hphantom{}{M \\choose i }{N - M \\choose n-i}}{N \\choose n} \\] In this formula, \\(N\\) is the number of background genes, \\(n\\) is the number of interesting (i.e. statistically-significant) genes, \\(M\\) is the number of genes that are annotated to a particular gene set \\(G_i\\), and \\(x\\) is the number of interesting genes that are annotated to \\(G_i\\) (i.e. \\(x = M \\bigcap n\\)). For example, suppose we have a list of 8000 genes, of which 400 are differentially expressed. Also suppose that 100 of the 8000 genes are annotated to a particular gene set \\(G_i\\). Of these 100 genes, 20 are differentially expressed. The probability that 20 or more (up to 100) genes annotated to \\(G_i\\) are differentially expressed by chance is given by \\[ P(X\\geq 20) = 1 - P(X \\leq 19) = 1-\\sum \\limits_{i=0}^{19}\\frac{\\\\{100 \\choose i}{8000 - 100 \\choose 400-i}}{8000 \\choose 400} = 7.88 \\times 10^{-8} \\] That is, it is unlikely that \\(G_i\\) is enriched by chance. The code to calculate this p-value is phyper(q = 20 - 1, m = 400, n = 8000 - 400, k = 100, lower.tail = FALSE) References "],["gsea.html", "4.2 GSEA", " 4.2 GSEA Gene Set Enrichment Analysis (GSEA) "],["databases.html", "4.3 Databases", " 4.3 Databases 4.3.1 Gene Ontology The Gene Ontology (GO) database is divided into three separate ontologies: Biological Process, Cellular Component, and Molecular Function. Gene Ontology overview 4.3.2 Reactome Home - Reactome Pathway Database 4.3.3 KEGG KEGG: Kyoto Encyclopedia of Genes and Genomes 4.3.4 Pfam Pfam: Home page "],["references.html", "References", " References "]]
